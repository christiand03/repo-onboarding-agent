{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to represent the package correctly.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies within a codebase. It takes a filename, an abstract syntax tree (AST), and a repository root path as inputs. It uses a custom visitor class to traverse the AST and extract import dependencies. The resulting graph captures relationships between files where one file imports another.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed for dependencies."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree representation of the file's source code."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory path of the repository containing the file."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph where nodes represent files and edges represent import relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.FileDependencyGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between files in a Git repository. It retrieves all files from the repository, filters them to include only Python files or those under the 'backend' directory, and then builds a dependency graph for each file. The function aggregates these individual file graphs into a single global graph that captures the overall dependency structure of the repository.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The GitRepository object containing the files to analyze for dependencies."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the dependency relationships among files in the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.build_file_dependency_graph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories. It resolves the given directory path to an absolute path and then uses the `rglob` method to recursively find all matching files. Each file path is then converted to a relative path with respect to the root directory. The function returns a list of these relative paths as `Path` objects.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory from which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of Path objects representing the relative paths of all .py files found in the directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analysis for example functions like 'add_item', 'check_stock', and 'generate_report', and simulates the use of an LLMHelper to process these inputs. It also constructs a ClassAnalysisInput for an 'InventoryManager' class and uses the LLMHelper to generate documentation for both functions and classes.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_callGraph": {
      "identifier": "backend.callgraph.build_callGraph",
      "description": {
        "overall": "This function constructs a call graph from an abstract syntax tree (AST) of Python code. It uses a custom CallGraph visitor to traverse the AST and extract function call relationships. The resulting graph includes only functions defined within the analyzed file, filtering out external dependencies. Nodes represent functions, and directed edges represent caller-callee relationships.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The abstract syntax tree representing the Python source code to analyze."
          },
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed, used for identification purposes."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the call relationships between functions in the analyzed file."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a safe version of the graph by relabeling all nodes with new identifiers prefixed by 'n' followed by their index. This ensures node names are safe for use in graph visualization tools like Graphviz. After relabeling, the original node labels are stored in the 'label' attribute of the new nodes. Finally, the modified graph is written to a file in DOT format using the pydot library.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph to be processed and saved."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The function builds a filtered call graph from a Git repository by parsing Python files and extracting function call relationships. It identifies functions defined within the repository and constructs a directed graph containing only those functions and their inter-call relationships. The filtering ensures that only locally-defined functions are included in the resulting graph. The function uses AST parsing to analyze each Python file and leverages a custom CallGraph visitor class to extract function call information. Finally, it returns a NetworkX DiGraph representing the filtered call graph.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "The Git repository object containing the files to analyze for building the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the filtered call graph containing only locally-defined functions and their inter-call relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The function 'wrap_cdata' takes a string input named 'content' and wraps it with CDATA tags, which are commonly used in XML to escape blocks of text that might otherwise be interpreted as markup. The function returns a formatted string that includes the original content enclosed within the CDATA section markers. This is typically used to safely include special characters or markup within XML documents.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The string content that needs to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "A string that contains the original content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The function extracts content from notebook outputs, handling both text and image data. It processes outputs of different types such as display_data, execute_result, stream, and error, returning a list of text snippets or placeholders. For images, it decodes Base64-encoded data and appends placeholders to an image list. The function prioritizes PNG over JPEG when both are present.",
        "parameters": [
          {
            "name": "outputs",
            "type": "Any",
            "description": "A collection of output objects from a notebook cell."
          },
          {
            "name": "image_list",
            "type": "List[Dict[str, Any]]",
            "description": "A mutable list to store decoded image data and metadata."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "List[str]",
            "description": "A list of text strings or XML placeholders representing the extracted content."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The function processes an image based on its MIME type by checking if the MIME type exists in a predefined data dictionary. If found, it decodes the base64 string, appends the image data to a global list, and returns an XML placeholder string with metadata. If any error occurs during processing, it returns an error message. If the MIME type is not found, it returns None.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str or None",
            "description": "Returns an XML placeholder string with image metadata if successful, otherwise returns an error message or None if the MIME type is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The function converts a Jupyter notebook, represented as a string of JSON content, into an XML format. It parses the notebook using nbformat, iterates through each cell, and transforms markdown and code cells into XML elements. For code cells, it also extracts and includes output content if present. The function returns a tuple consisting of the generated XML string and a list of extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "A string containing the raw JSON content of a Jupyter notebook."
          }
        ],
        "returns": [
          {
            "name": "xml_string",
            "type": "str",
            "description": "A string representing the converted notebook in XML format, with each cell wrapped in appropriate XML tags."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted image data or identifiers from the notebook's outputs."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.extract_output_content, backend.converter.wrap_cdata",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files to identify and convert Jupyter notebook files (.ipynb) into XML format along with associated images. It iterates through the notebook files, logs the processing status, and returns a dictionary mapping each notebook file path to its converted XML content and image data.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "List[File]",
            "description": "A list of file objects representing repository files, each expected to have a 'path' attribute and a 'content' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "Dict[str, Dict[str, Any]]",
            "description": "A dictionary where keys are the paths of notebook files and values are dictionaries containing 'xml' and 'images' keys with their respective converted data."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.mermaid_id": {
      "identifier": "backend.diagram_generation.emitter.mermaid_id",
      "description": {
        "overall": "The function 'mermaid_id' takes a string input named 'name' and returns a modified version of that string where all periods ('.') are replaced with underscores ('_'). This ensures compatibility with Mermaid diagram syntax, which does not allow periods in identifiers. The function performs a simple string transformation without any conditional logic or error handling.",
        "parameters": [
          {
            "name": "name",
            "type": "str",
            "description": "A string representing the identifier to be converted for use in Mermaid diagrams."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str",
            "description": "The input string with all periods replaced by underscores."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.analyze_project": {
      "identifier": "backend.diagram_generation.generator.analyze_project",
      "description": {
        "overall": "The function 'analyze_project' processes a list of repository files to build a project index and resolve function calls within the codebase. It filters Python files, parses their Abstract Syntax Trees (ASTs), collects symbols, and builds a module-based structure. The function then traverses these ASTs to identify function calls and resolves them using a call resolver. Finally, it returns both the constructed project index and the resolved call graph.",
        "parameters": [
          {
            "name": "all_files",
            "type": "list[RepoFile]",
            "description": "A list of repository files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index of the project modules and their symbol information."
          },
          {
            "name": "resolved_calls",
            "type": "ResolvedCall",
            "description": "A mapping of resolved function calls within the project."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.main_diagram_generation": {
      "identifier": "backend.diagram_generation.generator.main_diagram_generation",
      "description": {
        "overall": "The function `main_diagram_generation` processes a list of Python files to generate sequence diagrams in Mermaid format. It first analyzes the project structure and resolved function calls, then groups these calls by their originating functions. For each group, it emits a Mermaid sequence diagram representation. The result is a dictionary mapping function names to their corresponding Mermaid sequence diagram strings.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[str]",
            "description": "A list of paths to Python source files to be analyzed and processed for diagram generation."
          }
        ],
        "returns": [
          {
            "name": "seqs",
            "type": "dict[str, str]",
            "description": "A dictionary where keys are function names and values are Mermaid-formatted sequence diagram strings representing the call relationships for each function."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.diagram_generation.generator.analyze_project.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.enrich_report_with_diagrams": {
      "identifier": "backend.diagram_generation.generator.enrich_report_with_diagrams",
      "description": {
        "overall": "The function 'enrich_report_with_diagrams' takes a final report string and a dictionary of diagrams, then inserts the diagrams into the report at specific locations marked by function headers. It splits the report into lines, iterates through each line, appends it to a new list, and checks if a line contains a marker for a function header. If so, it appends the corresponding diagram from the diagrams dictionary. Finally, it joins all lines back into a single string.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "A string representing the final report content where diagrams need to be inserted."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary mapping function names to their corresponding diagram representations."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "A string representing the final report with diagrams inserted at appropriate locations."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.analyze_project": {
      "identifier": "backend.diagram_generation.main.analyze_project",
      "description": {
        "overall": "The function 'analyze_project' processes a list of Python files to build a project index and resolve function calls within the codebase. It parses each file into an Abstract Syntax Tree (AST), collects symbols, and builds a module-based structure. The function then traverses these trees to identify function calls and resolves them using a call resolver. Finally, it returns both the constructed project index and the resolved call graph.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[RepoFile]",
            "description": "A list of repository file objects representing Python source files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index of all modules parsed from the provided Python files, including their symbol information."
          },
          {
            "name": "resolved_calls",
            "type": "dict[str, list[ResolvedCall]]",
            "description": "A mapping of module names to lists of resolved function calls identified during traversal of the ASTs."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.construct_overview_diagram": {
      "identifier": "backend.diagram_generation.main.construct_overview_diagram",
      "description": {
        "overall": "This function constructs an overview diagram by extracting package information from a project's modules. It iterates through each module in the project, collects their overlying packages, and aggregates them into a list. The function then deduplicates these packages using a set and returns the resulting list of packages. The function appears to be designed to prepare data for diagram generation but does not utilize all collected data in its current implementation.",
        "parameters": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An object representing the project index containing modules and their associated metadata."
          }
        ],
        "returns": [
          {
            "name": "packages",
            "type": "list[list[str]]",
            "description": "A list of lists containing package names extracted from the project's modules."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.main_diagram_generation": {
      "identifier": "backend.diagram_generation.main.main_diagram_generation",
      "description": {
        "overall": "This function generates sequence diagrams for a given Python project by analyzing its structure and resolving function calls. It initializes a Git repository, retrieves all Python files, and processes them to build a project index and resolve inter-function dependencies. The function then organizes these resolved calls into sequence diagrams and writes them to a markdown file.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.diagram_generation.main.analyze_project",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.attach_with_parents": {
      "identifier": "backend.diagram_generation.symbol_collector.attach_with_parents",
      "description": {
        "overall": "This function traverses an Abstract Syntax Tree (AST) and assigns parent references to each node in the tree. It uses the `walk` function to iterate through all nodes and `iter_child_nodes` to access each node's children, setting the `parent` attribute of each child to point to its parent node. This allows for bidirectional navigation within the AST structure.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The root node of the Abstract Syntax Tree to process."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The function creates a bar chart comparing token counts between JSON and TOON formats and saves it to a specified path. It uses matplotlib to generate the visualization, including labels, titles, and value annotations on the bars. The chart displays the percentage savings in the title.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of tokens in the JSON format."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of tokens in the TOON format."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage savings represented in the chart title."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the generated chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function calculates the net time duration between a start and end time, excluding sleep periods caused by rate limits. It specifically handles cases where the model name starts with 'gemini-', applying adjustments based on batch processing. If the model is not a gemini model, it returns the total duration directly. For zero items, it returns zero. Otherwise, it computes the number of batches, determines the sleep count, and subtracts the total sleep time from the overall duration.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float or datetime",
            "description": "The starting timestamp or time value."
          },
          {
            "name": "end_time",
            "type": "float or datetime",
            "description": "The ending timestamp or time value."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items processed."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The size of each batch for processing."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used, which affects how rate limiting is handled."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float or int",
            "description": "The calculated net time after subtracting sleep durations due to rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The `main_workflow` function orchestrates a comprehensive code analysis pipeline for a given GitHub repository. It begins by validating and extracting API keys and model configurations, followed by cloning the repository and extracting essential information such as file trees and project metadata. The function then performs relationship analysis and constructs an Abstract Syntax Tree (AST) schema. Using helper LLMs, it analyzes individual functions and classes, generating detailed documentation. Finally, it prepares inputs for a main LLM to produce a final report, including performance metrics and visualizations.",
        "parameters": [
          {
            "name": "user_input",
            "type": "str",
            "description": "Input provided by the user, typically containing a GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "Dictionary containing API keys and base URLs for various language models and services."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "Dictionary specifying the names of helper and main language models to be used."
          },
          {
            "name": "status_callback",
            "type": "Callable[[str], None]",
            "description": "Optional callback function to report progress updates."
          },
          {
            "name": "check_stop",
            "type": "Callable[[], bool]",
            "description": "Optional callback function to check if the workflow should be interrupted."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final markdown report generated by the main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and token usage metrics for the workflow."
          }
        ],
        "usage_context": {
          "calls": "backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.diagram_generation.generator.main_diagram_generation, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.enrich_report_with_diagrams, backend.main.get_key_and_url, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, schemas.types.MethodContextInput",
          "called_by": "This function calls no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The function 'update_status' is designed to handle status updates within a workflow process. It first checks if a stop condition has been triggered by calling the 'check_stop' function, and if so, logs an interrupt message and raises an 'InterruptedError'. If a 'status_callback' function is defined, it is invoked with the provided message. Finally, the message is logged using the standard logging mechanism.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "A string message representing the status update to be processed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.get_key_and_url": {
      "identifier": "backend.main.get_key_and_url",
      "description": {
        "overall": "The function determines the appropriate API key and base URL for a given model name. It checks the model name prefix to decide which key and URL to return. For GPT models, it returns the OpenAI API key and no URL. For Gemini models, it validates the presence of a Gemini API key before returning it along with no URL. For the 'llama3' model, it returns None for the key and the Ollama base URL. For other models, it first checks for user-defined Open Source keys and URLs, falling back to default system-scoped keys and URLs if none are provided.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string representing the name of the model for which the API key and base URL are to be determined."
          }
        ],
        "returns": [
          {
            "name": "key",
            "type": "Union[str, None]",
            "description": "The API key corresponding to the model type, or None if not applicable."
          },
          {
            "name": "url",
            "type": "Union[str, None]",
            "description": "The base URL for the model's API endpoint, or None if not applicable."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.enrich_report_with_diagrams": {
      "identifier": "backend.main.enrich_report_with_diagrams",
      "description": {
        "overall": "The function `enrich_report_with_diagrams` takes a final report string and a dictionary of diagrams, then inserts diagrams into the report at specific locations. It splits the report into lines and iterates through them, appending each line to a new list. When it encounters a line containing \"#### Function:\", it checks if any filename from the diagrams dictionary is present in that line. If so, it appends the corresponding diagram to the new list. Finally, it joins all lines back into a single string and returns the enriched report.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "A string representing the final report content where diagrams need to be inserted."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary mapping filenames to diagram content that should be inserted into the report."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "A modified version of the final report with diagrams inserted after lines containing \"#### Function:\"."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function orchestrates the analysis of Jupyter notebooks within a GitHub repository. It begins by extracting a GitHub URL from the input, clones the repository, and processes all notebook files found. It determines the appropriate API key and base URL based on the specified model, initializes an LLM instance, and sequentially analyzes each notebook using the LLM. The results are aggregated into a final report along with timing metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "A string containing the input, expected to include a GitHub URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys and URLs for various models and services."
          },
          {
            "name": "model",
            "type": "str",
            "description": "A string specifying the model to be used for analysis, determining the API key and base URL."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to report progress updates."
          },
          {
            "name": "check_stop",
            "type": "callable",
            "description": "An optional function to check if the workflow should be interrupted."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "A string containing the aggregated analysis reports for all notebooks."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and model information."
          }
        ],
        "usage_context": {
          "calls": "backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The function `gemini_payload` constructs a structured payload for use with a Gemini API by combining basic information, a notebook path, and parsed XML content with embedded image placeholders. It processes the XML to replace image placeholders with base64-encoded image data from a provided list. The resulting payload is a list of dictionaries representing text and image components.",
        "parameters": [
          {
            "name": "info",
            "type": "Any",
            "description": "Basic information to be included in the payload."
          },
          {
            "name": "path",
            "type": "Any",
            "description": "The current notebook path to be included in the payload."
          },
          {
            "name": "xml",
            "type": "str",
            "description": "XML content that contains image placeholders to be replaced with actual images."
          },
          {
            "name": "imgs",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries containing image data, indexed by position in the XML."
          }
        ],
        "returns": [
          {
            "name": "payload",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries representing text and image components for the Gemini API."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not under the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The function encrypts a given text string using a Fernet cipher suite. It first checks if the input text is empty or if the cipher suite is not available, returning the original text in such cases. If both conditions are met, it strips whitespace from the input text, encodes it to bytes, encrypts it using the cipher suite, and then decodes the result back to a string.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text string to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted version of the input text, or the original text if encryption was not performed."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The function decrypt_text is designed to decrypt a given encrypted text string using a cipher suite. It first checks if the input text or the cipher suite is empty, returning the original text in such cases. If both are present, it attempts to decrypt the text by encoding it, performing the decryption, and then decoding the result back to a string. In case of any exception during the decryption process, it gracefully returns the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The encrypted text string that needs to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str",
            "description": "The decrypted text string if decryption is successful; otherwise, the original input text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. It hashes the password using a hasher utility before storing the user information. The function also initializes additional fields such as API keys with empty strings. It returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user, used as the '_id' field in the database."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The plain text password of the user, which gets hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The unique identifier of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It uses the pymongo library to perform a find operation on the collection and returns the results as a list. The function does not take any parameters and directly accesses the database collection.",
        "parameters": [],
        "returns": [
          {
            "name": "result",
            "type": "list",
            "description": "A list containing all user documents retrieved from the 'dbusers' collection in the MongoDB database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The function fetch_user retrieves a user document from a MongoDB collection named 'dbusers' based on the provided username. It uses the find_one method to search for a document where the '_id' field matches the given username. The function does not perform any additional processing or validation on the retrieved data before returning it.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to locate the specific user document in the database."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "Any",
            "description": "The user document retrieved from the 'dbusers' collection, or None if no matching document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name field of a user document in a MongoDB collection identified by the user's username. It uses the MongoDB update_one method to modify only the name field, leaving other fields unchanged. The function returns the count of modified documents, which should be 1 if the update was successful or 0 if no matching document was found.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user whose name needs to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name value to set for the specified user."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation. This will typically be 1 if a matching document was found and updated, or 0 if no matching document was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates the Gemini API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key needs to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be stored for the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "The function updates the GPT API key for a specified user in the database. It first encrypts the provided API key and then performs an update operation on the user document in the 'dbusers' collection. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and performs an update operation on the user document. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL needs to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new Ollama base URL to be set for the specified user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This should typically be 1 if the user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the OpenSource API key for a given user in the database. It first encrypts the provided API key using an encryption function, then performs a MongoDB update operation to store the encrypted key under the user's document. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose OpenSource API key needs to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The OpenSource API key to be updated for the specified user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open source base URL for a user in the database. It takes a username and a new open source base URL as inputs, strips any leading or trailing whitespace from the URL, and then performs an update operation on the user document in the database. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL needs to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open source base URL to be set for the user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This should typically be 1 if the user exists and the update was successful."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "Optional[str]",
            "description": "The Gemini API key associated with the user, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The function retrieves a GPT API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gpt_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "Optional[str]",
            "description": "The GPT API key associated with the provided username, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the OpenSource API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'opensrc_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to look up the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The OpenSource API key associated with the username, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "The function retrieves the open source base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'opensrc_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "Optional[str]",
            "description": "The open source base URL associated with the provided username, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The function deletes a user from the database by their username and returns the count of deleted documents. It uses a MongoDB collection named 'dbusers' to perform the deletion operation based on the user's unique identifier (_id). The function assumes that the user exists and will return 1 if the deletion is successful, or 0 if no matching document was found.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted, either 1 if the user was found and deleted, or 0 if no such user existed."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys for a given username from a database. It first fetches the user document using the username as the identifier. If the user does not exist, it returns None for all keys. Otherwise, it decrypts specific API keys (Gemini and GPT) while returning others directly. It returns five values: the decrypted Gemini API key, the Ollama base URL, the decrypted GPT API key, the decrypted OpenSource API key, and the OpenSource base URL.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key for the user, or an empty string if not found."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL for the user, or an empty string if not found."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSource API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSource base URL for the user, or an empty string if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The function 'insert_chat' creates a new chat entry in a database collection. It generates a unique identifier using UUID, assigns the provided username and chat name, and records the creation timestamp. The function then inserts this chat document into the database and returns the ID of the newly inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "result.inserted_id",
            "type": "str",
            "description": "The unique identifier of the newly inserted chat document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet den Benutzernamen als Filterkriterium und sortiert die Ergebnisse nach dem Erstellungsdatum in aufsteigender Reihenfolge. Das Ergebnis ist eine Liste der Chat-Dokumente, die dem Benutzer zugeordnet sind.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "Der Benutzername, dessen Chats abgerufen werden sollen."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "Eine Liste aller Chats, die dem angegebenen Benutzernamen zugeordnet sind, sortiert nach Erstellungsdatum."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a lookup using MongoDB's find_one method with a query that matches both the username and chat name. The function returns a boolean value indicating the presence or absence of the chat entry.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if a chat with the specified username and chat_name exists in the database; False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and updates all associated exchanges in the database. It first updates the chat entry in the chats collection, then updates all related exchange entries in the exchanges collection. The function returns the number of modified chat documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to assign to the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of chat documents that were successfully modified during the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "This function inserts a new exchange record into a MongoDB collection. It generates a unique ID for the exchange, constructs a dictionary with all the provided details including optional fields with default values, and attempts to insert this document into the database. If the insertion fails, it catches the exception, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in response to the question."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback associated with the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used in the exchange, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main component used in the exchange, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Total time taken for the exchange, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Time taken by the helper component, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Time taken by the main component, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Number of JSON tokens used, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Number of Toon tokens used, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Percentage saved during the exchange, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique identifier generated for the inserted exchange record."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when an exception occurs during database insertion."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves all exchange records from a MongoDB collection for a given username, sorted by creation timestamp in ascending order. It queries the 'dbexchanges' collection using the provided username as a filter and sorts the results by the 'created_at' field. The function returns the list of matching exchange records.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchange records by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange records matching the provided username, sorted by creation timestamp in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with specific criteria and orders the results by creation date in ascending order. The function returns the fetched documents as a list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the exchanges to be retrieved."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat associated with the exchanges to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange documents matching the provided username and chat name, sorted by creation date in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "This function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document with the new feedback value. The function returns the number of documents modified as a result of the operation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The feedback value to be set in the document."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message associated with a specific exchange ID in a MongoDB collection. It uses the 'update_one' method to modify a document where the '_id' field matches the provided exchange ID, setting the 'feedback_message' field to the new value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be set for the specified exchange."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes a document from the 'dbexchanges' collection in a MongoDB database based on a given exchange ID. It performs a deletion operation and returns the count of deleted documents. The function takes a single string parameter representing the unique identifier of the exchange to be deleted.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "A string representing the unique identifier of the exchange document to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the collection, typically 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "This function deletes all exchanges and the chat entry associated with a given username and chat name from the database. It first removes all exchange records matching the criteria, then deletes the corresponding chat record. The function returns the count of deleted chat entries, which should be 1 if the operation was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "del_chat.deleted_count",
            "type": "int",
            "description": "The number of chat documents deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The function 'clean_names' takes a list of strings representing model paths and extracts the final component of each path by splitting on the '/' delimiter. It returns a new list containing only these final components. This is commonly used to simplify model identifiers by removing directory prefixes.",
        "parameters": [
          {
            "name": "model_list",
            "type": "List[str]",
            "description": "A list of strings where each string represents a full path to a model, typically including directory components separated by '/'."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "List[str]",
            "description": "A list of strings containing the final component of each path in the input list, obtained by splitting on '/' and taking the last element."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The function filters a given list of models based on a specified category name. It retrieves keywords associated with the category and applies filtering logic depending on whether 'STANDARD' is included in those keywords. If 'STANDARD' is present, it returns only models that exist in a predefined standard list. Otherwise, it filters models whose names contain any of the retrieved keywords. If no models match the criteria, the original list is returned.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "A list of model names to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category used to determine filtering criteria."
          }
        ],
        "returns": [
          {
            "name": "filtered_models",
            "type": "list",
            "description": "A list of models that match the filtering criteria. If no filter matches, the original source_list is returned."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_abort": {
      "identifier": "frontend.frontend.handle_abort",
      "description": {
        "overall": "The function 'handle_abort' is designed to signal an abort request within a Streamlit application by setting a flag in the session state and displaying a toast message indicating that the abort is being processed. It does not take any parameters and does not return any value. The function directly manipulates the Streamlit session state and uses Streamlit's toast functionality to provide user feedback.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function handles the saving of a Gemini API key entered by the user in the frontend interface. It retrieves the key from the session state, updates the database with the new key for the current user, clears the input field, and displays a success message to the user.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function retrieves an Ollama URL from the Streamlit session state and updates the database with the new URL for the current user. It also displays a success toast message upon completion. The function is designed to handle user input related to Ollama configuration.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_ollama_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_last_activity": {
      "identifier": "frontend.frontend.get_last_activity",
      "description": {
        "overall": "The function 'get_last_activity' determines the timestamp of the last message in a specified chat. It retrieves the chat's exchanges from the session state, checks if any exist, and extracts the datetime of the most recent exchange. If the datetime is stored as a string, it attempts to parse it into a datetime object. If no exchanges are found or parsing fails, it defaults to returning 'datetime.min'.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat for which to retrieve the last activity timestamp."
          }
        ],
        "returns": [
          {
            "name": "dt",
            "type": "datetime.datetime",
            "description": "The datetime of the last message in the chat, or datetime.min if no messages exist or parsing fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The function loads user-specific chat and exchange data from a database into the Streamlit session state. It first checks if the user data is already loaded; if not, it fetches chats and exchanges associated with the given username. It initializes session state variables for chats and exchanges, handling missing feedback values by setting them to NaN. If no chats exist, it creates an initial chat and sets it as active. Finally, it sorts chats by last activity and sets the most recent one as the active chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load chat and exchange data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value for a given exchange object in the database and triggers a Streamlit rerun to refresh the UI. It takes an exchange dictionary and a new feedback value, assigns the value to the 'feedback' key of the exchange, updates the corresponding record in the database using the exchange's ID, and then calls st.rerun() to update the frontend display.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing an exchange object, expected to contain keys such as '_id' and 'feedback'."
          },
          {
            "name": "val",
            "type": "Any",
            "description": "The new feedback value to be assigned to the exchange object."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "This function handles the deletion of an exchange from the database and updates the session state to reflect the removal of the exchange from the specified chat. It first deletes the exchange from the database using its ID, then checks if the exchange exists in the session state for the given chat and removes it if present. Finally, it triggers a rerun of the Streamlit app to update the UI.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is to be removed."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_exchange_by_id",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The function handles the deletion of a chat by first removing the chat from the database and then cleaning up the session state. It ensures that the active chat is updated appropriately, either to another existing chat or by creating a new default chat if none remain. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_full_chat, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from any URL present in that text. It uses regular expressions to find a URL, parses it using urllib.parse.urlparse, extracts the path component, and then derives the repository name from the last segment of the path. If the repository name ends with '.git', it removes the extension. If no URL is found or the path is empty, the function returns None.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string that may contain a URL from which the repository name is to be extracted."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name from the URL, with '.git' suffix removed if present."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when no valid URL is found in the input text or when the URL path is empty."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The function 'stream_text_generator' takes a string input and yields each word from the string followed by a space, with a small delay between each yield. It is designed to simulate a streaming effect for text output. The function splits the input text on spaces and processes each word individually.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input string that will be split into words and streamed one at a time."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text based on Mermaid code block delimiters and handles regular markdown content and Mermaid diagrams differently. Regular markdown content is rendered using Streamlit's markdown functionality, while Mermaid diagrams are rendered using a dedicated mermaid component. If rendering fails, it falls back to displaying the diagram as plain code.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The input markdown text that may contain Mermaid code blocks enclosed in triple backticks with 'mermaid' language identifier."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the regular markdown text content using Streamlit's write_stream functionality."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "frontend.frontend.stream_text_generator",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The function `render_exchange` renders a chat exchange in a Streamlit interface, displaying a user's question and an assistant's response. It handles both regular responses and error messages differently, showing error messages directly with a styled error component and providing feedback options for normal responses. The function also includes UI elements for deleting exchanges, downloading responses, and adding notes to exchanges.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the question, answer, feedback, and other metadata such as '_id'."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat, used for handling actions like deleting exchanges."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, frontend.frontend.render_text_with_mermaid",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_provider": {
      "identifier": "frontend.frontend.get_provider",
      "description": {
        "overall": "The function 'get_provider' determines the provider name based on the given model name. It evaluates the model name against specific conditions using string matching operations. If the model name starts with 'gemini', it returns 'Google Gemini'. If the model name is exactly 'llama3', it returns 'ollama'. If the model name starts with 'gpt-5', it returns 'gpt'. For all other cases, it defaults to returning 'Open Source LLM'.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string representing the name of the model for which the provider needs to be determined."
          }
        ],
        "returns": [
          {
            "name": "provider",
            "type": "str",
            "description": "A string indicating the provider associated with the given model name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.config_provider": {
      "identifier": "frontend.frontend.config_provider",
      "description": {
        "overall": "The `config_provider` function handles the configuration interface for different AI models within a Streamlit-based frontend. It dynamically displays settings forms based on the provided `model_name` and updates corresponding database entries when users submit changes. The function checks for the presence of various keys and URLs, displaying appropriate status indicators and allowing users to modify these configurations through interactive UI elements.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string identifier indicating which AI model's configuration is being handled."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key, database.db.update_gpt_key, database.db.update_ollama_url, database.db.update_opensrc_key, database.db.update_opensrc_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.check_stop_callback": {
      "identifier": "frontend.frontend.check_stop_callback",
      "description": {
        "overall": "This function is designed to check whether the user has requested to abort a process by examining the session state in Streamlit. It retrieves a boolean value indicating if the 'abort_requested' flag is set. The function serves as a callback mechanism to allow the backend to periodically poll for user interruption signals.",
        "parameters": [],
        "returns": [
          {
            "name": "return_value",
            "type": "bool",
            "description": "A boolean value indicating whether the user has requested to abort the process. Returns True if 'abort_requested' is set to True in the session state, otherwise returns False."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is a specialized AST (Abstract Syntax Tree) visitor that traverses Python source code to extract structural information about imports, classes, and functions. It leverages the `ast.NodeVisitor` base class to walk through nodes in the parsed AST and builds a schema representation of the module's structure. This schema includes details such as import statements, class definitions with their methods, and function definitions along with their metadata like line numbers, docstrings, and source segments.",
        "init_method": {
          "description": "Initializes the ASTVisitor with source code, file path, and project root. It computes the module path using a helper function and sets up an initial schema structure to collect information about imports, functions, and classes.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The full source code of the file being analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The absolute or relative path to the file being processed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project, used to compute module paths."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import nodes in the AST by extracting the names of imported modules and appending them to the schema's imports list. It processes each alias in the import statement and adds it to the list of imports collected so far.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when an import node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles 'from ... import ...' statements in the AST by extracting the fully qualified names of imported items and appending them to the schema's imports list. Each imported item is prefixed with the module name to form a complete reference.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when an 'import from' node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes class definition nodes in the AST by creating a detailed schema entry for the class. It includes metadata such as the class name, docstring, source segment, and line numbers. Additionally, it tracks the current class being visited to associate methods with it.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when a class definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Handles function definition nodes in the AST. If a class is currently being visited, it associates the function as a method of that class. Otherwise, it treats the function as a top-level function. In both cases, it collects metadata including arguments, docstrings, source segments, and line numbers.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when a function definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles asynchronous function definition nodes in the AST by delegating processing to the standard function visitor method. This ensures that async functions are treated similarly to regular functions in terms of schema collection.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an async function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method delegates to visit_FunctionDef.",
                "called_by": "This method is called automatically by the AST traversal mechanism when an async function definition node is encountered."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.AST_Schema.path_to_module utility function to compute module paths based on file and project root.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Trees (ASTs) and building a structured schema that includes functions, classes, and their relationships. It merges relationship data such as outgoing calls, incoming calls, dependencies, and instantiation contexts into the schema. The class also handles error cases during parsing and ensures that only valid Python files are processed.",
        "init_method": {
          "description": "The constructor for ASTAnalyzer does not take any parameters and simply passes, indicating that no initialization logic is required.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method takes a full schema and raw relationship data, and enriches the schema with contextual information about function calls, incoming calls, and class dependencies. It iterates over functions and classes in the schema, updating their context with call and called-by information, and computes dependencies for classes based on method calls.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary representing the full schema of the repository, including file paths and AST nodes."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "A dictionary containing raw relationship data, specifically outgoing and incoming call mappings."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated schema with enriched relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call other functions or methods.",
                "called_by": "This method is not called by any other function or method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method analyzes a list of files in a Git repository by parsing each Python file's content into an AST, visiting the nodes using an ASTVisitor, and collecting schema information. It constructs a full schema including imports, functions, and classes while handling potential parsing errors gracefully.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects containing path and content information."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "An object representing the Git repository being analyzed."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary representing the full schema of the repository after processing the files."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.AST_Schema.ASTVisitor class to parse and visit AST nodes.",
                "called_by": "This method is not called by any other function or method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.AST_Schema.ASTVisitor class for parsing and visiting AST nodes.",
          "instantiated_by": "This class is not instantiated by any other class or function according to the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve Python file dependencies, particularly focusing on handling relative imports. It extends NodeVisitor to traverse AST nodes representing import statements and builds a dependency graph by tracking which files depend on others. The class resolves relative imports by examining the repository structure and checking for module existence or symbol exports in __init__.py files.",
        "init_method": {
          "description": "Initializes the FileDependencyGraph with a filename and repository root path. Sets up the instance variables to track the current file being analyzed and the root directory of the repository.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for dependencies."
            },
            {
              "name": "repo_root",
              "type": "Any",
              "description": "The root directory path of the repository being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "Resolves relative imports by analyzing the AST node representing an import statement. It determines the actual module or symbol names that can be imported based on the file structure and checks for their existence in the repository. The method handles cases where imports use relative paths like '..' and ensures that only valid modules or symbols are returned.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names that could be imported."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists to resolve relative imports.",
                "called_by": "This method is not called by any other method within the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import statements by adding the imported module names to the dependency graph. It tracks dependencies between files and their imports, storing them in a dictionary keyed by the filename.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "An AST node representing an import statement."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "Optional base name of the module being imported."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method within the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes 'from ... import ...' style import statements. It extracts the module name and resolves it to determine the correct base name for dependency tracking. If the import is relative, it attempts to resolve it using the _resolve_module_name method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' style import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other method within the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists for resolving relative imports.",
          "instantiated_by": "This class is not instantiated by any other classes or functions according to the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class serves as a centralized interface for interacting with various Large Language Models (LLMs) such as Google Gemini, OpenAI GPT, custom APIs, and Ollama. It handles API configuration, prompt loading, and structured output generation for both function and class documentation. The class supports batching requests to manage rate limits and ensures robust error handling during LLM interactions.",
        "init_method": {
          "description": "Initializes the LLMHelper with necessary API credentials, prompt files, and model configurations. It loads system prompts from specified files, sets up the appropriate LLM client based on the model name, and configures batch processing settings.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "API key for authenticating with the LLM provider."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for function documentation generation."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for class documentation generation."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "Name of the LLM model to use, defaulting to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Base URL for custom API endpoints, optional."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures the batch size for processing requests based on the specified model name. Different models have different recommended batch sizes to optimize performance and avoid rate limiting issues.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "Name of the LLM model being used."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the __init__ method."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Generates validated documentation for a batch of functions using the configured LLM. It processes inputs in batches, respecting rate limits, and returns a list of validated FunctionAnalysis objects or None for failed items.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function inputs to document."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated FunctionAnalysis objects or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Generates validated documentation for a batch of classes using the configured LLM. It processes inputs in batches, respects rate limits, and returns a list of validated ClassAnalysis objects or None for failed items.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class inputs to document."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated ClassAnalysis objects or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were explicitly listed in the context.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs), including Google's Gemini, OpenAI's GPT, custom API endpoints, and local Ollama models. It initializes with an API key, a path to a system prompt file, and a model identifier, configuring the appropriate LLM client based on the model type. The class supports two primary interaction modes: synchronous calls via `call_llm` and streaming responses via `stream_llm`, both utilizing the configured system prompt and user input.",
        "init_method": {
          "description": "Initializes the MainLLM instance by validating the API key, loading the system prompt from a specified file, and setting up the appropriate LLM client based on the model name. It supports multiple LLM providers including Google Generative AI, OpenAI-compatible APIs, and Ollama, with specific handling for custom models requiring environment variables.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key used for authenticating with the LLM provider."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt used for initializing the LLM."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use, which determines the LLM provider and configuration."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Optional base URL for connecting to a custom LLM endpoint."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "Sends a synchronous request to the configured LLM with a system prompt and user input, returning the content of the response. It logs the start and success of the call, and handles exceptions by logging errors and returning None.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The content of the LLM's response, or None if an error occurs."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "Initiates a streaming request to the configured LLM with a system prompt and user input, yielding content chunks as they become available. It logs the start of the streaming process and handles exceptions by logging errors and yielding an error message.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "chunk_content",
                  "type": "str",
                  "description": "Yields content chunks from the LLM's streaming response, or an error message if an exception occurs."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on external libraries such as langchain_google_genai, langchain_ollama, langchain_openai, and langchain_core.messages for LLM interactions and message handling.",
          "instantiated_by": "This class is instantiated by components within the backend module, likely in response to user requests or system initialization."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It initializes with a structured dictionary to hold extracted data and provides methods to parse and extract specific sections from these files. The class supports cleaning content, finding relevant files by pattern, extracting markdown sections, and parsing TOML and requirements files. The main method orchestrates the extraction process based on file availability and prioritizes information sources.",
        "init_method": {
          "description": "Initializes the ProjektInfoExtractor with a predefined structure for storing project information. It sets up placeholders for various project details including overview and installation instructions, and defines a constant for indicating missing information.",
          "parameters": [
            {
              "name": "self",
              "type": "ProjektInfoExtractor",
              "description": "Reference to the instance of the class."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from the input string, which can occur due to encoding errors when reading files in UTF-8 format but they were actually encoded in UTF-16. It ensures that the content is clean before further processing.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The input string that may contain null bytes."
                }
              ],
              "returns": [
                {
                  "name": "cleaned_content",
                  "type": "str",
                  "description": "The input string with all null bytes removed."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by other internal methods like _parse_readme, _parse_toml, and _parse_requirements to sanitize content before processing."
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches for a file among a list of files based on a set of patterns. It performs a case-insensitive search to find a matching file extension and returns the first match found.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file extensions or names to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                }
              ],
              "returns": [
                {
                  "name": "matched_file",
                  "type": "Optional[Any]",
                  "description": "The first matching file object or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the extrahiere_info method to locate relevant project files like README, pyproject.toml, and requirements.txt."
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text under a specified Markdown heading (indicated by ##). It uses regular expressions to find the section associated with one of the given keywords and returns the content between the heading and the next heading or end of the document.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The full content of the Markdown file."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords to look for as headings."
                }
              ],
              "returns": [
                {
                  "name": "extracted_text",
                  "type": "Optional[str]",
                  "description": "The text content under the matched heading or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by _parse_readme to extract specific sections like Features, Tech Stack, Status, Installation, and Quick Start from the README file."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file to extract various project details such as title, description, key features, tech stack, current status, setup instructions, and quick start guide. It uses helper methods to clean content and extract specific sections from the Markdown content.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize the input and _extrahiere_sektion_aus_markdown to extract specific sections.",
                "called_by": "This method is called by extrahiere_info to parse the README file content."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file to extract project metadata such as name, description, and dependencies. It handles potential errors during parsing and updates the info dictionary accordingly.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize the input and handles exceptions related to TOML parsing.",
                "called_by": "This method is called by extrahiere_info to parse the pyproject.toml file content."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file to extract dependencies. It filters out comments and empty lines and only populates dependencies if they haven't already been set from a TOML file.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize the input.",
                "called_by": "This method is called by extrahiere_info to parse the requirements.txt file content."
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the extraction of project information by identifying relevant files and calling appropriate parsing methods. It prioritizes pyproject.toml over requirements.txt and README for extracting information, formats dependencies, and derives a default title from the repository URL if needed.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository to derive a default title from if necessary."
                }
              ],
              "returns": [
                {
                  "name": "info",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information."
                }
              ],
              "usage_context": {
                "calls": "Calls _finde_datei to locate relevant files, and _parse_readme, _parse_toml, and _parse_requirements to parse the content of those files.",
                "called_by": "This method is the main interface for extracting project information and is likely called by higher-level components in the application."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not depend on any external libraries beyond standard Python modules and typing constructs.",
          "instantiated_by": "This class is not instantiated by any other component mentioned in the provided context."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to construct a call graph from Python source code by traversing the Abstract Syntax Tree (AST). It tracks function definitions, imports, and function calls to build a directed graph representing the relationships between different functions and modules. The class maintains mappings for local definitions and imports to resolve function names correctly, including handling class methods and asynchronous functions. It also manages scope information for functions and classes during traversal.",
        "init_method": {
          "description": "Initializes the CallGraph with a filename and sets up internal data structures for tracking function definitions, imports, and call relationships. It initializes the graph structure using NetworkX and prepares dictionaries and sets for storing local definitions, import mappings, and function edges.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being processed to generate the call graph."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "Recursively extracts the dotted name components from an AST node representing a function call. It handles different types of AST nodes like Name, Attribute, and Call to build a list of name components that represent the full path of a function or method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node to extract name components from."
                }
              ],
              "returns": [
                {
                  "name": "parts",
                  "type": "list[str]",
                  "description": "A list of strings representing the dotted name components."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the _resolve_all_callee_names method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "Resolves a list of name components (from _recursive_call) into fully qualified names based on local definitions, import mappings, and current class context. It checks for local definitions first, then import mappings, and finally constructs full names using the file and class context.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists containing name components for potential callees."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of fully qualified names for the callees."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _recursive_call method.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "Constructs a fully qualified name for a function or method using the filename, optional class name, and base name. This helps in creating unique identifiers for functions within their respective scopes.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name of the function or method."
                },
                {
                  "name": "class_name",
                  "type": "Optional[str]",
                  "description": "The name of the class if the function belongs to one."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The fully qualified name constructed from the filename, class name, and base name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_FunctionDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "Determines the current caller's name based on whether there is an active function or class context. If no function is active, it defaults to the global scope or the filename.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The name of the current caller, either the function name or a default scope identifier."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST nodes representing import statements. It maps imported module names to their actual module names in the import mapping dictionary, which is used later for resolving function names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles AST nodes representing from-import statements. It maps imported names to their corresponding module paths in the import mapping dictionary, allowing resolution of names from imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing a from-import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles AST nodes representing class definitions. It temporarily sets the current class context during traversal of the class body and restores the previous context after traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Handles AST nodes representing function definitions. It registers the function in local definitions, adds it to the graph, and manages the current function context during traversal. It also ensures that both direct and class-method names are registered.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _make_full_name and generic_visit methods.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles AST nodes representing async function definitions. It delegates processing to the visit_FunctionDef method since async functions are treated similarly to regular functions in terms of call graph construction.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AST node representing an async function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the visit_FunctionDef method.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Handles AST nodes representing function calls. It determines the caller, resolves the callee names, and records the edge in the graph. It also updates the edges dictionary to track call relationships.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing a function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _current_caller, _recursive_call, and _resolve_all_callee_names methods.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "Handles AST nodes representing if statements. Special handling is performed for if statements checking '__name__' which typically indicate main execution blocks. In such cases, it temporarily changes the current function context to '<main_block>' during traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The AST node representing an if statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the ast module for parsing Python source code and networkx for graph operations.",
          "instantiated_by": "This class is instantiated by other components in the system that require call graph generation from Python source files."
        }
      },
      "error": null
    },
    "backend.diagram_generation.call_resolver.CallResolver": {
      "identifier": "backend.diagram_generation.call_resolver.CallResolver",
      "description": {
        "overall": "The CallResolver class is responsible for resolving raw function calls in a Python project into structured, resolved calls by analyzing their context and mapping them to actual function definitions. It operates on a ProjectIndex which contains information about modules, functions, classes, and imports. The main entry point is the resolve_all method, which processes a dictionary of raw calls grouped by module and resolves each one using helper methods tailored to different AST node types (Name and Attribute). These helpers determine whether a call refers to a local function, an imported function, a method, or a dynamically resolved function.",
        "init_method": {
          "description": "Initializes the CallResolver with a ProjectIndex object that holds metadata about the project's modules, functions, and imports. This index is used throughout the resolution process to look up function definitions and related information.",
          "parameters": [
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "An index containing metadata about the project's modules, functions, classes, and imports."
            }
          ]
        },
        "methods": [
          {
            "identifier": "resolve_all",
            "description": {
              "overall": "Processes a dictionary of raw calls grouped by module and resolves each call into a list of ResolvedCall objects. It iterates over the input dictionary, and for each call, delegates resolution to the resolved method.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "dict[str, list[RawCall]]",
                  "description": "A dictionary mapping module names to lists of RawCall objects representing unresolved function calls."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "dict[str, list[ResolvedCall]]",
                  "description": "A dictionary mapping module names to lists of ResolvedCall objects representing resolved function calls."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "resolved",
            "description": {
              "overall": "Resolves a single RawCall object based on the type of the function node in the call. It checks if the node is an ast.Name or ast.Attribute and routes the resolution to appropriate private helper methods (_resolve_name or _resolve_attribute). If the node type is neither, it returns a ResolvedCall with UNKNOWN call type.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "A raw call object containing information about the function call being resolved."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects representing the resolved version(s) of the input call."
                }
              ],
              "usage_context": {
                "calls": "This method calls the private helper methods _resolve_name or _resolve_attribute depending on the type of the function node.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_name",
            "description": {
              "overall": "Handles resolution of function calls represented as ast.Name nodes. It looks up the function name in the current module's functions or imports. If found in imports, it resolves the target module and function. Returns a list of ResolvedCall objects indicating direct or imported function calls.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "A raw call object containing information about the function call being resolved."
                },
                {
                  "name": "node",
                  "type": "ast.Name",
                  "description": "An AST node representing a simple function name."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects representing the resolved version(s) of the input call."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is called by the resolved method when the function node is an ast.Name."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_attribute",
            "description": {
              "overall": "Handles resolution of function calls represented as ast.Attribute nodes. It handles cases like 'self.method', 'module.function', and dynamic lookups across all classes in the project. It attempts to resolve the attribute as a method of a class, an imported function, or a dynamically resolved function. Returns a list of ResolvedCall objects indicating the resolved call type.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "A raw call object containing information about the function call being resolved."
                },
                {
                  "name": "node",
                  "type": "ast.Attribute",
                  "description": "An AST node representing an attribute access expression."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects representing the resolved version(s) of the input call."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is called by the resolved method when the function node is an ast.Attribute."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several data types including CallType, RawCall, ResolvedCall, and ProjectIndex, which are imported from diagram_generation.data_types.",
          "instantiated_by": "This class is not instantiated by any other method or class in the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.callgraph.TreeVisitor": {
      "identifier": "backend.diagram_generation.callgraph.TreeVisitor",
      "description": {
        "overall": "The TreeVisitor class is designed to traverse an Abstract Syntax Tree (AST) to extract call relationships between functions and methods within a Python project. It maintains context about the current function and class being visited during traversal, enabling accurate tracking of call sites. The visitor collects these calls into a list of RawCall objects which encapsulate details such as the caller, the called function, line number, and contextual information.",
        "init_method": {
          "description": "Initializes the TreeVisitor with a module symbol and a project index. It sets up internal state variables including references to the current function and class, and initializes an empty list to store call records.",
          "parameters": [
            {
              "name": "module",
              "type": "ModuleSymbol",
              "description": "Represents the module being analyzed."
            },
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "Provides access to the entire project's modules and their symbols."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles the visitation of class definitions in the AST. It temporarily updates the current class context before visiting child nodes and restores the previous class context afterward. This ensures that subsequent visits to function definitions correctly associate with the appropriate class.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other user-defined functions but relies on generic_visit to continue traversal.",
                "called_by": "This method is invoked automatically by the AST visitor framework when encountering a ClassDef node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definitions in the AST. It manages the current function context by setting it based on whether the function belongs to a class or is a top-level function. After processing the function body, it restores the previous function context to maintain proper scoping.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other user-defined functions but relies on generic_visit to continue traversal.",
                "called_by": "This method is invoked automatically by the AST visitor framework when encountering a FunctionDef node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes call expressions in the AST to determine if they represent valid function calls within the project. It checks whether the called function exists in the module or project and, if so, records the call with associated metadata including the caller, line number, and context information.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Call",
                  "description": "The AST node representing a function call expression."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method constructs and appends a RawCall object to the internal calls list and invokes generic_visit to continue traversing the AST subtree.",
                "called_by": "This method is invoked automatically by the AST visitor framework when encountering a Call node."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were specified.",
          "instantiated_by": "No instantiation locations were specified."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.FunctionSymbol": {
      "identifier": "backend.diagram_generation.data_types.FunctionSymbol",
      "description": {
        "overall": "The FunctionSymbol class represents a symbolic representation of a function, capturing essential metadata such as its name, module, qualified name, input parameters, return type, and line number. It serves as a data container for function-related information used in diagram generation processes.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, relying instead on default initialization behavior for its attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies as indicated by the empty dependencies list.",
          "instantiated_by": "This class is not instantiated by any other component as per the instantiated_by list."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ClassSymbol": {
      "identifier": "backend.diagram_generation.data_types.ClassSymbol",
      "description": {
        "overall": "The ClassSymbol class represents a symbolic representation of a class within a diagram generation system. It encapsulates essential metadata about a class, including its name, module of origin, and a collection of its methods represented as FunctionSymbol objects. This class serves as a data structure for organizing and managing class-related information during the diagram generation process.",
        "init_method": {
          "description": "The ClassSymbol class does not define an explicit __init__ method, relying on default initialization behavior. It declares three instance variables: name (a string), module (a string), and methods (a dictionary mapping strings to FunctionSymbol objects).",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on external modules such as ast.expr, dataclasses.dataclass, enum.Enum, and typing.Optional, which are likely used for type annotations and AST manipulation.",
          "instantiated_by": "This class is not explicitly instantiated by any other component within the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ModuleSymbol": {
      "identifier": "backend.diagram_generation.data_types.ModuleSymbol",
      "description": {
        "overall": "The ModuleSymbol class represents a module in a Python codebase, encapsulating metadata about the module such as its name, the packages it belongs to, and the functions and classes it contains. It also tracks the module's imports. This class serves as a data structure for organizing and representing module-level information during diagram generation.",
        "init_method": {
          "description": "The ModuleSymbol class does not define an explicit __init__ method, relying on default initialization behavior for its attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond standard Python typing constructs.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallContext": {
      "identifier": "backend.diagram_generation.data_types.CallContext",
      "description": {
        "overall": "The CallContext class is a data structure designed to hold symbolic references to a module, function, and optionally a class. It serves as a container for contextual information related to a call site within a codebase, likely used in diagram generation or static analysis tools to track relationships between different code elements.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, relying on default initialization behavior for dataclass-like attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on symbols such as ModuleSymbol, FunctionSymbol, and ClassSymbol, which are likely defined elsewhere in the codebase.",
          "instantiated_by": "This class is not explicitly instantiated by any known components based on the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.RawCall": {
      "identifier": "backend.diagram_generation.data_types.RawCall",
      "description": {
        "overall": "The RawCall class is a data structure designed to represent a call to a function within a program, capturing essential metadata such as the caller, the function node, line number, and context. It serves as a simplified representation of a function call, likely used during diagram generation processes to track and analyze function interactions.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, relying instead on dataclass-style initialization based on the declared attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on no external modules or libraries beyond standard typing and AST components.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallType": {
      "identifier": "backend.diagram_generation.data_types.CallType",
      "description": {
        "overall": "The CallType class is an enumeration that defines various types of function or method calls within a codebase. It provides a standardized set of values to categorize different kinds of call interactions, such as direct calls, method calls, imported calls, dynamic calls, and unknown calls. This enum serves as a type-safe way to represent and distinguish between these call types in diagram generation and analysis.",
        "init_method": {
          "description": "The CallType class is initialized as an Enum with predefined constant values representing different types of calls. Each value is assigned a string identifier that describes the nature of the call.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond standard Python enums.",
          "instantiated_by": "This class is not instantiated by any other code components as it is a static enumeration."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ResolvedCall": {
      "identifier": "backend.diagram_generation.data_types.ResolvedCall",
      "description": {
        "overall": "The ResolvedCall class is a data structure designed to represent a resolved function call within a diagram generation system. It encapsulates information about the caller, the callee (if available), the type of call, and the line number where the call occurs. This class serves as a lightweight container for storing and passing around details related to function calls in a static analysis or visualization context.",
        "init_method": {
          "description": "The ResolvedCall class does not define an explicit __init__ method. Instead, it relies on dataclass-style attribute definitions to initialize its fields. The constructor implicitly initializes the caller, callee, call_type, and lineno attributes based on the provided type annotations and values during instantiation.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies as indicated by the empty dependencies list.",
          "instantiated_by": "This class is not instantiated by any other components as indicated by the empty instantiated_by list."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ProjectIndex": {
      "identifier": "backend.diagram_generation.data_types.ProjectIndex",
      "description": {
        "overall": "The ProjectIndex class serves as a container for managing modules within a project, specifically storing them in a dictionary keyed by their identifiers. It provides a method to retrieve all classes across all modules in a flattened list format.",
        "init_method": {
          "description": "Initializes the ProjectIndex with a dictionary of modules. The constructor does not perform any additional initialization beyond assigning the modules attribute.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "all_classes",
            "description": {
              "overall": "Retrieves a flattened list of all ClassSymbol instances from all modules stored in the ProjectIndex. It iterates over each module in the modules dictionary and then over each class within each module's classes dictionary, collecting all classes into a single list.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectIndex",
                  "description": "Reference to the current instance of the ProjectIndex class."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[ClassSymbol]",
                  "description": "A list containing all ClassSymbol instances from all modules."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were specified for this class.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidSequenceEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidSequenceEmitter",
      "description": {
        "overall": "The MermaidSequenceEmitter class is responsible for generating Mermaid sequence diagram representations from a list of ResolvedCall objects. It constructs the diagram by collecting participants, emitting call interactions, and handling return responses. The class uses helper functions to format identifiers and ensures proper ordering of calls based on line numbers.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, so it inherits the default initialization behavior from the base object class.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a complete Mermaid sequence diagram string from a list of ResolvedCall objects. It begins with the Mermaid diagram header, collects participants, sorts calls by line number, emits each call and its potential response, and concludes with the diagram closing tag.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects representing function calls to be included in the diagram."
                }
              ],
              "returns": [
                {
                  "name": "str",
                  "type": "str",
                  "description": "A formatted Mermaid sequence diagram string."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods within the class.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_participants",
            "description": {
              "overall": "The _collect_participants method gathers unique participant names from the provided ResolvedCall objects. It extracts caller and callee names using the mermaid_id helper function and ensures all participants are included in the diagram.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects from which to extract participant names."
                }
              ],
              "returns": [
                {
                  "name": "list[str]",
                  "type": "list[str]",
                  "description": "A list of participant names formatted for use in the Mermaid diagram."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.diagram_generation.emitter.mermaid_id function to format participant names.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_response",
            "description": {
              "overall": "The _emit_response method generates a Mermaid notation line representing a return statement from a callee back to a caller in the sequence diagram.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A ResolvedCall object representing the call for which to generate a return statement."
                }
              ],
              "returns": [
                {
                  "name": "str",
                  "type": "str",
                  "description": "A formatted Mermaid return statement line."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.diagram_generation.emitter.mermaid_id function to format the callee and caller names.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_call",
            "description": {
              "overall": "The _emit_call method formats a ResolvedCall object into a Mermaid notation line representing a function call from a caller to a callee, including the call's input parameters.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A ResolvedCall object representing the call to be emitted."
                }
              ],
              "returns": [
                {
                  "name": "str",
                  "type": "str",
                  "description": "A formatted Mermaid call statement line."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.diagram_generation.emitter.mermaid_id function to format the caller and callee names.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.diagram_generation.emitter.mermaid_id function for formatting identifiers in the generated diagrams.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidOverviewArchitectureEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidOverviewArchitectureEmitter",
      "description": {
        "overall": "The MermaidOverviewArchitectureEmitter class is responsible for generating a Mermaid diagram representation of the architectural overview of modules within a system. It takes a dictionary of ModuleSymbol objects and constructs a graph structure showing the dependencies between these modules based on their imports.",
        "init_method": {
          "description": "The class does not define an explicit constructor (__init__ method), so it inherits the default initialization behavior from the base object class.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a Mermaid graph representation of module dependencies. It iterates through the provided modules, extracts source and destination module names, and constructs directional edges representing import relationships between modules.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary mapping module names to ModuleSymbol objects which contain information about module imports."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "A string containing the Mermaid graph definition with nodes and edges representing module dependencies."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods directly.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class has no external dependencies listed.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidClassDiagramEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidClassDiagramEmitter",
      "description": {
        "overall": "The MermaidClassDiagramEmitter class is responsible for generating Mermaid.js class diagram representations from a collection of module symbols. It processes modules, their classes, and methods to construct a textual diagram format suitable for visualization. The emitter also handles relationships between modules by rendering import statements as associations in the diagram.",
        "init_method": {
          "description": "The constructor for MermaidClassDiagramEmitter does not accept any parameters and initializes no instance attributes. It is a simple class designed to encapsulate the logic for emitting Mermaid class diagrams.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a Mermaid class diagram string representation from a dictionary of module symbols. It iterates over each module and its classes, formatting class definitions with their methods and adding import relationships between modules.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary mapping module names to ModuleSymbol objects containing class and method information."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "A string representing the Mermaid class diagram with formatted classes and import relationships."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id function to generate unique identifiers for classes and modules.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.diagram_generation.emitter.mermaid_id function for generating Mermaid-compatible identifiers.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.SymbolCollector": {
      "identifier": "backend.diagram_generation.symbol_collector.SymbolCollector",
      "description": {
        "overall": "The SymbolCollector class is designed to traverse an Abstract Syntax Tree (AST) of Python code and collect symbolic information about modules, including their imports, classes, and functions. It extends the ast.NodeVisitor class to customize traversal behavior for different AST node types. The collected symbols are stored in a ModuleSymbol object which encapsulates details such as function signatures, class methods, and import statements.",
        "init_method": {
          "description": "Initializes the SymbolCollector with a module name and a list of packages. It sets up an internal ModuleSymbol object to store collected symbolic information about the module being processed.",
          "parameters": [
            {
              "name": "module_name",
              "type": "str",
              "description": "The name of the module being processed."
            },
            {
              "name": "packages",
              "type": "list[str]",
              "description": "A list of package names that the module belongs to."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_has_return",
            "description": {
              "overall": "Checks whether a given function definition node contains any return statement. It iterates through the body of the function and identifies if any statement is of type Return.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "bool",
                  "description": "True if the function has at least one return statement, false otherwise."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_ClassDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_declare_input_parameters",
            "description": {
              "overall": "Extracts the names of input parameters from a function definition node. It iterates through the arguments of the function and collects the names of the parameters.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of strings representing the names of the input parameters."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_ClassDef and visit_AsyncFunctionDef methods."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST nodes representing import statements. It processes each imported name and stores it in the module's imports dictionary with an optional alias.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import",
                  "description": "The AST node representing an import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No value is returned."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called during AST traversal by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles AST nodes representing 'from ... import ...' statements. It resolves the base module name and maps imported names to their full qualified names, storing them in the module's imports dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No value is returned."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called during AST traversal by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes AST nodes representing class definitions. It creates a ClassSymbol for the class and iterates through its methods to collect information about each method, including whether it has a return statement and its input parameters.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No value is returned."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _has_return and _declare_input_parameters helper methods.",
                "called_by": "This method is called during AST traversal by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles AST nodes representing asynchronous function definitions. It checks if the function is part of a class and skips processing if so. Otherwise, it creates a FunctionSymbol for the async function, collecting information about its parameters and return status.",
              "parameters": [
                {
                  "name": "node",
                  "type": "AsyncFunctionDef",
                  "description": "The AST node representing an asynchronous function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No value is returned."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _has_return and _declare_input_parameters helper methods.",
                "called_by": "This method is called during AST traversal by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Handles AST nodes representing regular function definitions. It delegates the processing to the visit_AsyncFunctionDef method, effectively treating regular functions the same as asynchronous ones in terms of symbol collection.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a regular function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No value is returned."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called during AST traversal by the generic_visit method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on various AST-related modules and data types such as ModuleSymbol, FunctionSymbol, and ClassSymbol.",
          "instantiated_by": "This class is not directly instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as the blob object, content, and size to optimize resource usage. The class provides properties to access these lazily-loaded values and includes utility methods for word count analysis and dictionary serialization.",
        "init_method": {
          "description": "Initializes a RepoFile object with the file path and the commit tree from which the file originates. It sets up internal attributes to store the file path, the commit tree, and placeholders for the blob, content, and size which are loaded on-demand.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "This property lazy-loads the Git blob object associated with the file. It retrieves the blob from the commit tree using the stored file path. If the file is not found in the tree, it raises a FileNotFoundError.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly based on the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "This property lazy-loads and decodes the content of the file. It uses the previously loaded blob to read the raw data and decode it into a UTF-8 string, ignoring any encoding errors.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly based on the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "This property lazy-loads and returns the size of the file in bytes. It accesses the size attribute of the blob object associated with the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly based on the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "This method performs a simple analysis by counting the number of words in the file's content. It splits the content by whitespace and returns the total word count.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The number of words in the file's content."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly based on the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "This method returns a string representation of the RepoFile object, useful for debugging and logging purposes. It displays the file path of the RepoFile.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr",
                  "type": "str",
                  "description": "A string representation of the RepoFile object including its path."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly based on the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "This method converts the RepoFile object into a dictionary format. It includes basic file information such as path, name, size, and type. Optionally, it can also include the file's content if specified.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "If True, includes the file's content in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary containing file metadata and optionally the content."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly based on the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated anywhere according to the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to its files through RepoFile objects. It supports listing all files, retrieving a hierarchical file tree, and cleaning up the temporary directory upon closing. The class implements context manager protocols (__enter__ and __exit__) to facilitate automatic resource management.",
        "init_method": {
          "description": "Initializes a GitRepository instance by cloning the specified repository URL into a temporary directory. It sets up necessary attributes such as the repository URL, temporary directory path, and references to the cloned repository and its latest commit. If cloning fails, it raises a RuntimeError after cleaning up resources.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "Retrieves a list of all files in the repository and creates RepoFile objects for each file. These objects are stored in the instance's 'files' attribute and returned. The method uses git ls-files to obtain the file paths and constructs RepoFile instances based on those paths.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing all files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.getRepo.RepoFile to instantiate RepoFile objects.",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "Deletes the temporary directory and its contents associated with the repository. This method is typically called when the repository is no longer needed to free up system resources.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "Enables the use of the GitRepository instance in a 'with' statement, returning the instance itself to allow for context management.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The GitRepository instance."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "Automatically closes the GitRepository instance when exiting a 'with' block, ensuring proper cleanup of temporary resources.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "exc_type",
                  "type": "Any",
                  "description": "Exception type if an exception occurred in the with block."
                },
                {
                  "name": "exc_val",
                  "type": "Any",
                  "description": "Exception value if an exception occurred in the with block."
                },
                {
                  "name": "exc_tb",
                  "type": "Any",
                  "description": "Exception traceback if an exception occurred in the with block."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "Generates a hierarchical representation of the repository's file structure. If no files have been retrieved yet, it first fetches all files. Then, it builds a nested dictionary structure representing directories and files, optionally including file content.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include file content in the returned tree structure."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A nested dictionary representing the file tree structure."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.getRepo.RepoFile for creating file representations.",
          "instantiated_by": "This class is not explicitly instantiated by any other component listed in the context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is responsible for analyzing Python project structures to extract and resolve relationships between code elements such as functions, classes, and methods. It traverses the project directory to find Python files, parses their Abstract Syntax Trees (ASTs) to collect definitions, and resolves inter-file call relationships using a custom visitor. The resulting call graph is stored internally and can be retrieved in a structured format showing both incoming and outgoing relationships.",
        "init_method": {
          "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including dictionaries for storing definitions, call graphs, and ASTs, along with a set of directories to ignore during traversal.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory path of the Python project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "The main analysis method that orchestrates the process of finding Python files, collecting definitions from those files, and resolving inter-file calls. It clears the AST cache after processing and returns the populated call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "defaultdict(list)",
                  "description": "A dictionary mapping callee identifiers to lists of caller information."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "Transforms the internal call graph into a more accessible format by separating outgoing and incoming relationships. Each relationship is represented as a set of identifiers, which are then sorted for consistent output.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing two keys: 'outgoing' and 'incoming', each mapping identifiers to sorted lists of related identifiers."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "Recursively walks through the project root directory to locate all Python (.py) files, excluding certain directories like .git, venv, etc., as specified in the ignore_dirs attribute.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list[str]",
                  "description": "A list of absolute paths to Python files found in the project."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "Parses a given Python file's content into an AST and collects definitions such as functions, methods, and classes. It associates these definitions with their respective file paths and line numbers, categorizing them based on whether they are top-level functions or methods within classes.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file whose definitions need to be collected."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls backend.relationship_analyzer.path_to_module to determine the module path of a file.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "Traverses the AST to find the parent node of a given AST node. This is used to determine if a function or method is defined inside a class.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The AST tree to search within."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node for which the parent needs to be found."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST or None",
                  "description": "The parent AST node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "Uses a CallResolverVisitor to traverse the AST of a file and resolve calls made within that file. It updates the internal call_graph with the resolved calls from the visitor.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file whose calls need to be resolved."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls backend.relationship_analyzer.CallResolverVisitor to resolve calls in a file.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.relationship_analyzer.CallResolverVisitor and backend.relationship_analyzer.path_to_module for resolving calls and determining module paths respectively.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is a subclass of ast.NodeVisitor designed to traverse Python AST nodes to resolve and track function calls within a module. It maintains scope information, class and function contexts, and maps call sites to their respective definitions. It records calls made to functions and methods, categorizing them by caller type (module, local function, method, or function) and associates them with metadata such as file name, line number, and caller identity. Additionally, it tracks instance types for assignments involving class instantiations.",
        "init_method": {
          "description": "Initializes the CallResolverVisitor with a file path, project root, and a set of definitions. It sets up internal state including module path, scope tracking, instance type mapping, and call recording structures.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The absolute path to the Python file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project, used to compute relative module paths."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary mapping qualified names to their definitions, used to validate resolved call targets."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles AST ClassDef nodes by updating the current class name context during traversal. It saves the previous class name, updates the current one to the new class name, recursively visits child nodes, and restores the previous class name after traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other user-defined functions directly.",
                "called_by": "This method is called by the parent class's generic_visit mechanism when traversing AST nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes AST FunctionDef nodes to update the current caller name context. It constructs a fully qualified identifier for the function based on whether it's inside a class or at the module level, updates the current caller name, recursively visits child nodes, and restores the previous caller name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other user-defined functions directly.",
                "called_by": "This method is called by the parent class's generic_visit mechanism when traversing AST nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes AST Call nodes to determine the qualified name of the called function. If the qualified name exists in the definitions, it records the call site with metadata including file name, line number, caller name, and caller type (module, local function, method, or function).",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing a function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other user-defined functions directly.",
                "called_by": "This method is called by the parent class's generic_visit mechanism when traversing AST nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST Import nodes by adding imported names to the current scope mapping. Each imported alias is stored in the scope dictionary under its asname or original name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other user-defined functions directly.",
                "called_by": "This method is called by the parent class's generic_visit mechanism when traversing AST nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes AST ImportFrom nodes to resolve and store imports from other modules. It handles relative imports by computing the correct module path and stores the mapping in the scope dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing a from ... import ... statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other user-defined functions directly.",
                "called_by": "This method is called by the parent class's generic_visit mechanism when traversing AST nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Handles AST Assign nodes to track variable assignments that involve class instantiation. If the assigned value is a call to a known class (from scope), it records the variable name and its qualified class name in the instance_types dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node representing an assignment statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other user-defined functions directly.",
                "called_by": "This method is called by the parent class's generic_visit mechanism when traversing AST nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the qualified name of a function call node. It checks if the function name is in the current scope, or constructs a local qualified name. For attribute access (e.g., obj.method), it resolves the object's type or module and combines it with the method name to form a qualified name.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.expr",
                  "description": "The AST node representing the function being called."
                }
              ],
              "returns": [
                {
                  "name": "resolved_name",
                  "type": "str or None",
                  "description": "The qualified name of the function if resolvable, otherwise None."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other user-defined functions directly.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.relationship_analyzer.path_to_module for resolving module paths.",
          "instantiated_by": "This class is not explicitly instantiated by any other component in the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.AnalysisMode": {
      "identifier": "schemas.enums.AnalysisMode",
      "description": {
        "overall": "The AnalysisMode class is an enumeration that defines different levels of analysis detail. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumerated type. The enum includes four distinct modes: OVERVIEW, STANDARD, DETAILED, and DEEP_DIVE, each associated with a specific string identifier.",
        "init_method": {
          "description": "The class is initialized as a string-based enumeration, inheriting from both str and Enum. No explicit initialization parameters are required as the enum values are predefined as class attributes.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__new__",
            "description": {
              "overall": "The __new__ method is implicitly used to create new instances of the enum members. It ensures that each enum member is properly instantiated as a string value with the specified identifier.",
              "parameters": [
                {
                  "name": "cls",
                  "type": "type",
                  "description": "The class being instantiated."
                },
                {
                  "name": "value",
                  "type": "str",
                  "description": "The string value associated with the enum member."
                }
              ],
              "returns": [
                {
                  "name": "instance",
                  "type": "AnalysisMode",
                  "description": "A new instance of the AnalysisMode enum with the given value."
                }
              ],
              "usage_context": {
                "calls": "This method internally calls the parent class constructors to ensure proper instantiation of enum members.",
                "called_by": "This method is called by the Python enum machinery during the creation of enum instances and is not directly invoked by user code."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not directly instantiated by any other code within the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramFocus": {
      "identifier": "schemas.enums.DiagramFocus",
      "description": {
        "overall": "The DiagramFocus class is an enumeration that defines different focus areas for diagram visualization. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumeration. The class provides predefined constants representing various diagram focuses such as architecture, data flow, dependencies, and call graph.",
        "init_method": {
          "description": "The class does not define a custom __init__ method, relying on the default initialization behavior inherited from str and Enum.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__new__",
            "description": {
              "overall": "This method is responsible for creating new instances of the enum members. It overrides the default __new__ behavior to ensure that each enum member is properly initialized with a string value.",
              "parameters": [
                {
                  "name": "cls",
                  "type": "type",
                  "description": "The class being instantiated."
                },
                {
                  "name": "value",
                  "type": "str",
                  "description": "The string value associated with the enum member."
                }
              ],
              "returns": [
                {
                  "name": "instance",
                  "type": "DiagramFocus",
                  "description": "A new instance of the DiagramFocus enum with the specified value."
                }
              ],
              "usage_context": {
                "calls": "This method internally uses the standard enum creation mechanism.",
                "called_by": "This method is called by the enum metaclass during instantiation of enum members."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not directly instantiated by any other code components as indicated by the context."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramType": {
      "identifier": "schemas.enums.DiagramType",
      "description": {
        "overall": "The DiagramType class is an enumeration that defines various Mermaid diagram types as string values. It inherits from both str and Enum, allowing each diagram type to be used as a string while maintaining the benefits of an enumerated type for type safety and clarity. This class serves as a centralized and standardized way to represent different diagram types within the application.",
        "init_method": {
          "description": "The class does not define a custom __init__ method. It relies on the default initialization inherited from str and Enum, which sets up the enum values based on the class attributes defined in the body of the class.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.GraphType": {
      "identifier": "schemas.enums.GraphType",
      "description": {
        "overall": "The GraphType class is an enumeration that defines different types of input graphs used within the system. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumeration. The class specifies three distinct graph types: CALLGRAPH, DEPENDENCY, and COMBINED, each associated with a specific string identifier.",
        "init_method": {
          "description": "The GraphType class does not define a custom __init__ method. It relies on the default initialization behavior inherited from the Enum base class, which sets up the enum members based on their assigned values.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__new__",
            "description": {
              "overall": "The __new__ method is responsible for creating new instances of the GraphType enum. It ensures that each enum member is properly initialized with its corresponding string value. This method is automatically invoked during enum creation and handles the internal mechanics of enum instantiation.",
              "parameters": [
                {
                  "name": "cls",
                  "type": "type",
                  "description": "The class being instantiated."
                },
                {
                  "name": "value",
                  "type": "str",
                  "description": "The string value associated with the enum member."
                }
              ],
              "returns": [
                {
                  "name": "instance",
                  "type": "GraphType",
                  "description": "A new instance of the GraphType enum with the specified value."
                }
              ],
              "usage_context": {
                "calls": "This method internally uses the standard Enum.__new__ mechanism to create enum instances.",
                "called_by": "This method is called by the Python enum machinery during the instantiation of enum members."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not directly instantiated by any other component in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the metadata of a single function parameter. It encapsulates three core attributes: the parameter's name, its type, and a descriptive explanation. This class ensures data integrity and structure for parameter descriptions within a larger system, likely used in API documentation, function analysis, or code generation tools.",
        "init_method": {
          "description": "The constructor initializes a ParameterDescription instance with three required fields: name, type, and description. These fields are typed as strings and are expected to be provided during instantiation.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the function parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The data type of the function parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A human-readable description of the function parameter's purpose or usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any other classes or modules beyond its base class BaseModel and standard typing constructs.",
          "instantiated_by": "This class is not directly instantiated by any other components listed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model designed to represent and validate the description of a function's return value. It encapsulates three essential attributes: the name of the return value, its type, and a textual description. This class ensures data integrity and structure for return value metadata, making it suitable for use in API schemas, documentation systems, or any application requiring standardized return value definitions.",
        "init_method": {
          "description": "The class is initialized with three required fields: 'name', 'type', and 'description'. These fields define the essential properties of a function's return value. As a Pydantic BaseModel, it inherits validation capabilities and serialization features.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on other classes or modules beyond Pydantic and its own schema definitions.",
          "instantiated_by": "This class is not instantiated by any other components based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model designed to represent and validate the calling context of a function. It encapsulates two string fields: 'calls', which describes the functions or methods that are called by the function in question, and 'called_by', which indicates the functions or methods that call the function in question. This class serves as a data structure for documenting and enforcing the usage context within a code analysis or diagram generation system.",
        "init_method": {
          "description": "The UsageContext class does not define a custom __init__ method. It inherits the initialization behavior from pydantic.BaseModel, which handles the creation and validation of instances based on the defined fields.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel for its functionality, ensuring data validation and serialization capabilities.",
          "instantiated_by": "This class is not explicitly instantiated by any other component within the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed information about a function's purpose, parameters, return values, and usage context. It serves as a structured representation for documenting function signatures and their associated metadata, making it suitable for use in automated documentation systems or API analysis tools.",
        "init_method": {
          "description": "The constructor initializes the FunctionDescription model with required fields: overall description, a list of parameter descriptions, a list of return value descriptions, and a usage context object.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A textual summary describing the overall purpose and functionality of the function."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the function."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects detailing each return value of the function."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "An object describing the usage context of the function, such as where it is called or what it is used for."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class serves as the primary data model for representing a function's metadata and analysis results within a structured JSON schema. It encapsulates essential information about a function including its unique identifier, a detailed description of its purpose and behavior, and an optional error field for capturing any issues during analysis. This class is designed to be a self-contained representation of a function's analysis, making it suitable for serialization and transmission across different components of a system.",
        "init_method": {
          "description": "Initializes a FunctionAnalysis instance with a required identifier string, a FunctionDescription object, and an optional error message. The constructor sets up the core attributes needed to represent a function's analysis.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function being analyzed."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object containing detailed information about the function's purpose, parameters, and behavior."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to capture any errors encountered during function analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It encapsulates a textual description of the constructor's purpose and a list of parameter descriptions that define its interface.",
        "init_method": {
          "description": "Initializes a ConstructorDescription instance with a description of the constructor and a list of ParameterDescription objects detailing its parameters.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A string describing the purpose or behavior of the __init__ method."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects that detail each parameter accepted by the __init__ method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model designed to encapsulate information about a class's external dependencies and the entities that instantiate it. It serves as a structured representation of metadata related to class usage and integration within a system.",
        "init_method": {
          "description": "Initializes a ClassContext instance with two string fields: 'dependencies' to describe external dependencies and 'instantiated_by' to indicate what instantiates the class.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string indicating the entity or entities that instantiate the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to encapsulate a comprehensive analysis of a class. It holds information about the class's overall purpose, its constructor details, a list of its methods along with their descriptions, and contextual usage information. This structure serves as a standardized way to represent detailed class metadata and analysis results.",
        "init_method": {
          "description": "Initializes an instance of the ClassDescription class with fields for overall purpose, constructor description, list of methods, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose of the class."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object containing detailed information about the class's constructor."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects representing the methods of the class."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing contextual information about how the class is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any external modules beyond those imported at the top level.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as the primary data structure for representing the complete JSON schema of a class within a documentation or analysis system. It encapsulates essential metadata about the class, including its identifier, a detailed description, and an optional error message. This class is designed to be a Pydantic BaseModel, ensuring data validation and serialization capabilities.",
        "init_method": {
          "description": "Initializes a new instance of the ClassAnalysis class with the required identifier and description fields, and an optional error field set to None by default.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An instance of ClassDescription providing detailed information about the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store any error messages related to the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It is a Pydantic BaseModel that enforces data structure and validation for call-related metadata.",
        "init_method": {
          "description": "Initializes a CallInfo instance with file path, function name, call mode, and line number attributes.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file path where the call occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that made the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, such as 'method', 'function', or 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number in the file where the call occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were specified for this class.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to represent structured context for analyzing a function. It encapsulates two key pieces of information: a list of function names that the analyzed function calls, and a list of CallInfo objects indicating which functions call the analyzed function. This model serves as a data structure to hold metadata about function call relationships, aiding in static analysis or diagram generation tasks.",
        "init_method": {
          "description": "The class is initialized with two fields: 'calls', which is a list of strings representing function names called by the analyzed function, and 'called_by', which is a list of CallInfo objects describing functions that call the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the names of functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing functions that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any external modules beyond those imported at the top level, including pydantic.BaseModel and schemas.enums types.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class serves as a structured input model for generating FunctionAnalysis objects. It encapsulates all necessary information including the mode of analysis, identifier, source code, imports, and contextual data required for processing. This class is designed to be a data transfer object that ensures consistent and validated input for function analysis operations.",
        "init_method": {
          "description": "Initializes the FunctionAnalysisInput class with required fields including the analysis mode, identifier, source code, imports list, and context information. The class inherits from BaseModel, providing serialization and validation capabilities.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal[\"function_analysis\"]",
              "description": "Specifies the analysis mode as 'function_analysis' to indicate the type of analysis being performed."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The complete source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements used in the function's source code."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "Additional contextual information required for the function analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on pydantic.BaseModel for data validation and serialization, and utilizes schemas.enums.AnalysisMode, schemas.enums.DiagramFocus, and schemas.enums.DiagramType for enum-based configurations.",
          "instantiated_by": "This class is instantiated by components responsible for preparing function analysis requests, likely within a larger analysis pipeline or service layer."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to structure contextual information about a method within a class. It encapsulates details such as the method's identifier, the methods it calls, the methods that call it, its arguments, and its docstring. This class serves as a standardized way to represent and exchange metadata about methods in a structured format, likely used in a larger system for analysis, documentation, or diagram generation.",
        "init_method": {
          "description": "The class is initialized with a set of fields that define the structure of the method context. It inherits from BaseModel, which provides validation and serialization capabilities.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__init__",
            "description": {
              "overall": "Initializes the MethodContextInput instance with the provided values for identifier, calls, called_by, args, and docstring. This method leverages Pydantic's BaseModel initialization to handle validation and assignment of the fields.",
              "parameters": [
                {
                  "name": "identifier",
                  "type": "str",
                  "description": "A string identifier for the method."
                },
                {
                  "name": "calls",
                  "type": "List[str]",
                  "description": "A list of strings representing the identifiers of methods called by this method."
                },
                {
                  "name": "called_by",
                  "type": "List[CallInfo]",
                  "description": "A list of CallInfo objects representing the methods that call this method."
                },
                {
                  "name": "args",
                  "type": "List[str]",
                  "description": "A list of strings representing the argument names of the method."
                },
                {
                  "name": "docstring",
                  "type": "Optional[str]",
                  "description": "An optional string containing the docstring of the method."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the base class __init__ method from pydantic.BaseModel to initialize the fields.",
                "called_by": "This method is typically called internally by Pydantic during instantiation of the MethodContextInput class."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel for validation and serialization features, and uses types from typing module like List and Optional.",
          "instantiated_by": "This class is instantiated by internal components of the system that require structured representation of method contexts, though specific instantiation points are not detailed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to structure contextual information required for analyzing a class. It encapsulates three key pieces of information: a list of dependencies, a list of call information for instances where the class is instantiated, and a list of method contexts detailing the behavior and relationships of methods within the class.",
        "init_method": {
          "description": "The constructor initializes the ClassContextInput model with three fields: dependencies, instantiated_by, and method_context. These fields are intended to hold lists of strings, CallInfo objects, and MethodContextInput objects respectively, providing a structured way to represent class analysis context.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of string identifiers representing the dependencies of the class being analyzed."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects indicating where and how the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects describing the context and behavior of methods within the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not directly depend on any external modules beyond those imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput is a Pydantic model designed to define the structure of input data required for generating a ClassAnalysis object. It encapsulates essential metadata including the mode of analysis, a unique identifier for the class being analyzed, the source code of the class, a list of import statements, and contextual information about the class.",
        "init_method": {
          "description": "Initializes the ClassAnalysisInput model with fields representing the mode of analysis, class identifier, source code, imports, and associated context. It leverages Pydantic's BaseModel for data validation and serialization.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal[\"class_analysis\"]",
              "description": "A literal string value that specifies the mode of analysis as 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class being analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements used in the source file containing the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "An object containing contextual information related to the class being analyzed."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports list, which includes standard typing utilities and Pydantic components.",
          "instantiated_by": "This class is not instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.DiagramRequest": {
      "identifier": "schemas.types.DiagramRequest",
      "description": {
        "overall": "The DiagramRequest class is a Pydantic BaseModel designed to define the structure of input data required for requesting diagram generation. It specifies the necessary components such as nodes and edges, along with optional configuration parameters like mode and focus that dictate how the diagram should be generated.",
        "init_method": {
          "description": "Initializes the DiagramRequest instance with required fields for nodes and edges, and optional fields for mode and focus, defaulting to STANDARD analysis mode and ARCHITECTURE diagram focus.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing the nodes in the diagram."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing the edges connecting nodes in the diagram."
            },
            {
              "name": "mode",
              "type": "AnalysisMode",
              "description": "The analysis mode for diagram generation, defaults to STANDARD."
            },
            {
              "name": "focus",
              "type": "DiagramFocus",
              "description": "The focus area for the diagram generation, defaults to ARCHITECTURE."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were explicitly listed for this class.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.GraphInput": {
      "identifier": "schemas.types.GraphInput",
      "description": {
        "overall": "The GraphInput class represents a serializable form of a call graph, designed to encapsulate the structural elements of a graph including nodes, edges, graph type, and associated metadata. It inherits from pydantic.BaseModel, enabling validation and serialization capabilities. This class serves as a data transfer object for representing graph structures in a standardized format.",
        "init_method": {
          "description": "Initializes the GraphInput class with required fields for representing a graph structure. The constructor sets up the basic attributes needed to define a graph including nodes, edges, graph type, and optional metadata.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing the nodes in the graph."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing the edges connecting nodes in the graph."
            },
            {
              "name": "graph_type",
              "type": "str",
              "description": "A string indicating the type of graph being represented."
            },
            {
              "name": "metadata",
              "type": "dict",
              "description": "An optional dictionary containing additional metadata about the graph, defaulting to an empty dictionary."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.DiagramOutput": {
      "identifier": "schemas.types.DiagramOutput",
      "description": {
        "overall": "The DiagramOutput class is a Pydantic BaseModel designed to represent the output schema for generated diagram information. It encapsulates three key fields: the type of diagram, the Mermaid code representing the diagram, and an explanation of the diagram's content. This class serves as a structured data container for diagram-related outputs, ensuring consistent formatting and validation of diagram data.",
        "init_method": {
          "description": "The class is initialized with three required fields: diagramtype, mermaid_code, and explanation. These fields define the core properties of a diagram output, including its type, the Mermaid code representation, and a textual explanation.",
          "parameters": [
            {
              "name": "diagramtype",
              "type": "DiagramType",
              "description": "The type of diagram being represented."
            },
            {
              "name": "mermaid_code",
              "type": "str",
              "description": "The Mermaid code that represents the diagram."
            },
            {
              "name": "explanation",
              "type": "str",
              "description": "A textual explanation of the diagram's content."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed for this class.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    }
  }
}