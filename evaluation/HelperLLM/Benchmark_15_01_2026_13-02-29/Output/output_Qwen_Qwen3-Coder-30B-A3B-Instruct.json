{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The function 'path_to_module' converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies by traversing an Abstract Syntax Tree (AST) of a given file. It uses a custom visitor class to extract import dependencies and builds a NetworkX DiGraph from these relationships. The function takes a filename, an AST tree, and a repository root path as inputs, and returns a graph showing which files depend on others.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which the dependency graph is being built."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree representation of the file being analyzed."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory path of the repository containing the file."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing file dependencies, where nodes are file names and edges represent import relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.FileDependencyGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between files in a Git repository. It retrieves all files from the repository, filters them to include only Python files and those under the 'backend' directory, and then builds a dependency graph for each file. The individual file graphs are merged into a single global graph that captures the overall dependency structure of the repository.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The GitRepository object containing the files to analyze for dependencies."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the dependency relationships between files in the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.build_file_dependency_graph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories. It resolves the given directory path to an absolute path, then uses recursive globbing to find all .py files. Each file path is normalized relative to the root directory. The function returns a list of pathlib.Path objects representing these files.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The directory path from which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[pathlib.Path]",
            "description": "A list of pathlib.Path objects representing all Python files found in the directory and its subdirectories, relative to the root directory."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analyses for example functions such as 'add_item', 'check_stock', and 'generate_report'. These analyses are then processed by an LLMHelper instance to generate documentation for a class named 'InventoryManager'. The function simulates how these components interact in a real-world scenario.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_callGraph": {
      "identifier": "backend.callgraph.build_callGraph",
      "description": {
        "overall": "This function constructs a call graph from an abstract syntax tree (AST) of Python code. It utilizes a custom CallGraph visitor class to traverse the AST and extract function call relationships. The resulting graph includes only those nodes and edges that correspond to functions defined within the same file or module. The function returns a NetworkX directed graph representing these intra-module call relationships.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The abstract syntax tree of the Python source code to analyze."
          },
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file from which the AST was generated, used for context in the call graph."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the intra-module function call relationships extracted from the AST."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a copy of the graph and generates a safe node naming scheme by replacing original node names with 'n{i}' format, where 'i' is an index. The original node names are preserved in the 'label' attribute of the new nodes. Finally, it writes the modified graph to a DOT file at the specified output path.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph to be processed and saved to a DOT file."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The function builds a filtered call graph from a Git repository by parsing Python files and extracting function call relationships. It first collects all Python files and their Abstract Syntax Trees (ASTs), then uses a custom CallGraph visitor to identify functions and edges. The resulting global call graph is filtered to only include edges between functions defined within the repository. The function returns a NetworkX DiGraph representing this filtered call graph.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "The Git repository object containing the files to analyze for building the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the filtered call graph of functions defined in the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The function 'wrap_cdata' takes a string input named 'content' and wraps it with CDATA tags, which are commonly used in XML to preserve special characters and prevent them from being interpreted as markup. The function returns a formatted string that includes the original content enclosed within the CDATA section markers. This is useful for safely embedding text that might contain characters like '<', '>', or '&'.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The string content that needs to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "A string that contains the input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The function extracts content from notebook outputs, handling both text and image data. It processes outputs of different types such as display_data, execute_result, stream, and error, returning a list of text snippets or image placeholders. For images, it decodes Base64-encoded data and appends it to an image list while generating a placeholder XML string. The function prioritizes PNG over JPEG when both are present.",
        "parameters": [
          {
            "name": "outputs",
            "type": "Any",
            "description": "A collection of output objects from a notebook cell."
          },
          {
            "name": "image_list",
            "type": "List[Dict[str, Any]]",
            "description": "A mutable list to store decoded image data along with metadata."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "List[str]",
            "description": "A list of text strings or XML placeholders representing the extracted content."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The function processes an image based on its MIME type by checking if the MIME type exists in a predefined data dictionary. If found, it decodes the base64 string, appends the image data to a global list, and returns an XML placeholder string with the image index and MIME type. If any error occurs during processing, it returns an error message. If the MIME type is not found, it returns None.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str or None",
            "description": "Returns an XML placeholder string with image details if successful, otherwise returns an error message or None if the MIME type is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The function converts a Jupyter notebook, represented as a string of JSON content, into an XML format. It parses the notebook using nbformat, iterates through each cell, and transforms markdown and code cells into XML elements. For code cells, it also extracts and includes output content if present. The function handles parsing errors gracefully by returning an error message and an empty list.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "A string containing the raw JSON content of a Jupyter notebook."
          }
        ],
        "returns": [
          {
            "name": "xml_output",
            "type": "str",
            "description": "A string representing the converted XML content of the notebook cells, joined by double newlines."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted image data or metadata from the notebook's outputs."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.extract_output_content, backend.converter.wrap_cdata",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files to identify and convert Jupyter notebook files (.ipynb) into XML format. It iterates through the notebook files, logs the processing status, and returns a dictionary mapping each notebook file path to its corresponding XML output and associated images. The function relies on an external helper function to perform the actual conversion.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "List[File]",
            "description": "A list of file objects representing repository files, each expected to have a 'path' attribute and a 'content' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "Dict[str, Dict[str, Any]]",
            "description": "A dictionary where keys are the paths of notebook files and values are dictionaries containing 'xml' and 'images' keys with their respective outputs."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.mermaid_id": {
      "identifier": "backend.diagram_generation.emitter.mermaid_id",
      "description": {
        "overall": "The function 'mermaid_id' takes a string input named 'name' and returns a modified version of that string where all periods ('.') are replaced with underscores ('_'). This is necessary because Mermaid identifiers are not allowed to contain periods. The function performs a simple string transformation using the built-in 'replace' method.",
        "parameters": [
          {
            "name": "name",
            "type": "str",
            "description": "A string representing the identifier to be converted for use in Mermaid diagrams."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str",
            "description": "The input string with all periods replaced by underscores, suitable for use as a Mermaid identifier."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.analyze_project": {
      "identifier": "backend.diagram_generation.generator.analyze_project",
      "description": {
        "overall": "The function 'analyze_project' processes a list of repository files to build a project index and resolve inter-module calls. It filters Python files, parses their ASTs, collects symbols, and builds a call graph. The function returns both the project index and the resolved calls.",
        "parameters": [
          {
            "name": "all_files",
            "type": "list[RepoFile]",
            "description": "A list of repository files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index of the project modules and their symbol information."
          },
          {
            "name": "resolved_calls",
            "type": "dict[str, ResolvedCall]",
            "description": "A dictionary mapping module names to their resolved call information."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.main_diagram_generation": {
      "identifier": "backend.diagram_generation.generator.main_diagram_generation",
      "description": {
        "overall": "The function `main_diagram_generation` processes a list of Python files to generate sequence diagrams in Mermaid format. It begins by analyzing the project structure and resolving function calls. It then groups these resolved calls by their caller functions and emits sequence diagrams for each group using a Mermaid sequence emitter. The result is a dictionary mapping function names to their corresponding Mermaid sequence diagram strings.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[str]",
            "description": "A list of paths to Python source files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "seqs",
            "type": "dict[str, str]",
            "description": "A dictionary mapping function names to their respective Mermaid sequence diagram strings."
          }
        ],
        "usage_context": {
          "calls": "backend.diagram_generation.generator.analyze_project",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.enrich_report_with_diagrams": {
      "identifier": "backend.diagram_generation.generator.enrich_report_with_diagrams",
      "description": {
        "overall": "The function 'enrich_report_with_diagrams' takes a final report string and a dictionary of diagrams, then inserts the diagrams into the report at specific locations. It splits the report into lines and iterates through each line to check for markers indicating where diagrams should be inserted. When a marker is found, the corresponding diagram is appended to the enriched report. Finally, it joins all lines back together with newline characters.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "A string representing the final report content where diagrams need to be inserted."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary mapping function names to their corresponding diagram representations."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "A new string representing the final report with diagrams inserted at appropriate locations."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.analyze_project": {
      "identifier": "backend.diagram_generation.main.analyze_project",
      "description": {
        "overall": "The function 'analyze_project' processes a list of Python files to build a project index and resolve function calls within the codebase. It parses each file into an Abstract Syntax Tree (AST), collects symbols, and builds a module-based structure. It then traverses these trees to identify function calls and resolves them using a call resolver. Finally, it returns both the project index and the resolved function calls.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[RepoFile]",
            "description": "A list of RepoFile objects representing Python source files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index of the project modules, including collected symbols and metadata."
          },
          {
            "name": "resolved_calls",
            "type": "ResolvedCall",
            "description": "A mapping of resolved function calls within the project."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.construct_overview_diagram": {
      "identifier": "backend.diagram_generation.main.construct_overview_diagram",
      "description": {
        "overall": "The function 'construct_overview_diagram' processes a 'ProjectIndex' object to extract and organize package information from its modules. It iterates through each module in the project, collects their overlying packages, and aggregates them into a list. The function then deduces a set of unique overlying packages from this collection. Finally, it prepares a list of module imports but does not utilize it in the returned result. The function returns a list of lists containing strings representing the collected packages.",
        "parameters": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An object representing the project index, containing modules with associated metadata including overlying packages."
          }
        ],
        "returns": [
          {
            "name": "packages",
            "type": "list[list[str]]",
            "description": "A list of lists where each inner list contains strings representing the overlying packages extracted from the project's modules."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.main_diagram_generation": {
      "identifier": "backend.diagram_generation.main.main_diagram_generation",
      "description": {
        "overall": "This function generates sequence diagrams for a given Python project by analyzing its structure and resolving function calls. It initializes a Git repository, retrieves all Python files, and processes them to build a project index and resolve inter-function dependencies. The function then groups these resolved calls by their callers and emits sequence diagrams using a Mermaid emitter. Finally, it writes the generated diagrams to a markdown file.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.diagram_generation.main.analyze_project",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.attach_with_parents": {
      "identifier": "backend.diagram_generation.symbol_collector.attach_with_parents",
      "description": {
        "overall": "The function 'attach_with_parents' traverses an abstract syntax tree (AST) and assigns parent references to each node in the tree. It iterates through all nodes using 'walk', and for each node, it iterates through its children using 'iter_child_nodes'. Each child node then receives a 'parent' attribute pointing to its parent node. This process ensures that every node in the tree maintains a reference to its parent, facilitating hierarchical navigation and analysis of the AST structure.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The root node of the abstract syntax tree to be processed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The function creates a bar chart comparing token counts between JSON and TOON formats and saves the resulting image to a specified file path. It uses matplotlib to generate the visualization, including labels, colors, and annotations for the bar values. The chart includes a title indicating the savings percentage and grid lines for improved readability.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of tokens in the JSON format."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of tokens in the TOON format."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage savings represented in the chart title."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the generated chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function calculates the net time duration by subtracting sleep times related to rate limits from the total time elapsed between a start and end timestamp. It specifically handles cases where the model name starts with 'gemini-' and adjusts the calculation based on the number of items and batch size. If the model is not a gemini model, it returns the total duration directly. For zero items, it returns zero. Otherwise, it computes the number of batches, determines the sleep count, and subtracts the total sleep time from the overall duration.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float or datetime",
            "description": "The starting timestamp of the operation."
          },
          {
            "name": "end_time",
            "type": "float or datetime",
            "description": "The ending timestamp of the operation."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items processed during the operation."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The number of items per batch for processing."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used, which affects whether rate limit calculations are applied."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float or int",
            "description": "The calculated net time after subtracting sleep durations due to rate limits, ensuring it is never negative."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The `main_workflow` function orchestrates a comprehensive code analysis and documentation generation process for a given GitHub repository. It begins by validating and extracting API keys and model configurations, followed by cloning the repository and analyzing its structure. The function then performs static analysis on the codebase using AST and relationship analyzers, prepares inputs for helper LLMs to analyze functions and classes, and finally invokes a main LLM to generate a final report. Throughout the process, it manages status updates, handles errors gracefully, and saves results including markdown reports and token-saving charts.",
        "parameters": [
          {
            "name": "user_input",
            "type": "str",
            "description": "A string containing user-provided input, typically a GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary mapping service names (e.g., 'gemini', 'gpt') to their respective API keys or URLs."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary specifying the names of helper and main models to be used for LLM operations."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to report progress updates during execution."
          },
          {
            "name": "check_stop",
            "type": "callable",
            "description": "An optional function to check whether the workflow should be interrupted."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final markdown-formatted report generated by the main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and token usage statistics for the analysis."
          }
        ],
        "usage_context": {
          "calls": "backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.diagram_generation.generator.main_diagram_generation, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.enrich_report_with_diagrams, backend.main.get_key_and_url, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, schemas.types.MethodContextInput",
          "called_by": "This function calls no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The function 'update_status' is designed to handle status updates within a workflow process. It first checks if a stop condition has been triggered by calling 'check_stop()', and if so, logs an interrupt message and raises an 'InterruptedError'. If a 'status_callback' function is defined, it invokes this callback with the provided message. Finally, it logs the message using the standard logging mechanism.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "A string message representing the status update to be logged and optionally passed to a callback function."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.get_key_and_url": {
      "identifier": "backend.main.get_key_and_url",
      "description": {
        "overall": "The function determines the appropriate API key and base URL for a given model name. It evaluates the model name to decide which key and URL to return based on predefined conditions. The function supports different models such as GPT, Gemini, Llama3, and Open Source models, with specific handling for each case including fallback mechanisms.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string representing the name of the model for which the API key and base URL are to be determined."
          }
        ],
        "returns": [
          {
            "name": "key",
            "type": "Union[str, None]",
            "description": "The API key corresponding to the model, or None if not applicable."
          },
          {
            "name": "url",
            "type": "Union[str, None]",
            "description": "The base URL corresponding to the model, or None if not applicable."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.enrich_report_with_diagrams": {
      "identifier": "backend.main.enrich_report_with_diagrams",
      "description": {
        "overall": "The function `enrich_report_with_diagrams` takes a final report string and a dictionary of diagrams, then inserts diagrams into the report at specific locations. It splits the report into lines and iterates through them, appending each line to a new list. When it encounters a line containing \"#### Function:\", it checks if any filename from the diagrams dictionary is present in that line. If so, it appends the corresponding diagram to the report. Finally, it joins all lines back into a single string and returns the enriched report.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "A string representing the final report content where diagrams need to be inserted."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary mapping filenames to diagram content that should be inserted into the report."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "A string representing the final report with diagrams inserted at appropriate locations."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function orchestrates the analysis of Jupyter notebooks within a GitHub repository. It handles API key and model provider selection, clones the repository, extracts basic project information, processes notebooks into a structured format, and generates reports using an LLM. The function includes error handling for missing repositories or invalid inputs, and supports interruptible execution via a callback mechanism.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "A string containing the input, typically expected to include a GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary mapping API key identifiers to their respective values for various providers like Gemini, GPT, ScadsLLM, etc."
          },
          {
            "name": "model",
            "type": "str",
            "description": "A string specifying the language model to use for generating reports, such as 'gpt-4', 'gemini-pro', or 'llama3'."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to report progress updates during execution."
          },
          {
            "name": "check_stop",
            "type": "callable",
            "description": "An optional callback function to check if the operation should be interrupted."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "A string containing the final report generated from analyzing the notebooks."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and model-related metrics for the execution."
          }
        ],
        "usage_context": {
          "calls": "backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The function `gemini_payload` constructs a structured payload for use with a Gemini API by combining basic information, a notebook path, and parsed XML content with embedded image placeholders. It processes the XML to replace image placeholders with base64-encoded image data from a provided list. The result is a list of dictionaries representing text and image components for the API request.",
        "parameters": [
          {
            "name": "info",
            "type": "Any",
            "description": "Basic information to be included in the payload."
          },
          {
            "name": "path",
            "type": "Any",
            "description": "The current notebook path to be included in the payload."
          },
          {
            "name": "xml",
            "type": "str",
            "description": "XML content containing image placeholders to be processed."
          },
          {
            "name": "imgs",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries containing image data, indexed by placeholder position."
          }
        ],
        "returns": [
          {
            "name": "payload",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries representing text and image components for the API request."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to ensure proper module naming.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The function encrypts a given text string using a Fernet cipher suite. It first checks if the input text is empty or if the cipher suite is not initialized, returning the original text in such cases. If both conditions are met, it encodes the stripped text, encrypts it, and returns the decrypted result as a string.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text string to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted version of the input text, returned as a string."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The function decrypts a given text string using a cipher suite. It first checks if the input text or the cipher suite is empty, returning the original text in such cases. If both are present, it attempts to decrypt the text by encoding it, performing the decryption, and then decoding the result back to a string. In case of any exception during decryption, it gracefully returns the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The encrypted text string that needs to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str",
            "description": "The decrypted text string if decryption is successful; otherwise, the original input text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. It hashes the password using a hasher utility before storing the user data. The function also initializes several API key fields with empty strings. It returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user, used as the '_id' field in the database."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The plain text password of the user, which gets hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "result.inserted_id",
            "type": "Any",
            "description": "The unique identifier of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It uses the pymongo library to perform a find operation on the collection and returns the results as a list. The function does not take any parameters and directly accesses the database without applying any filters or additional processing.",
        "parameters": [],
        "returns": [
          {
            "name": "result",
            "type": "list",
            "description": "A list containing all user documents retrieved from the 'dbusers' collection in the MongoDB database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The function fetch_user retrieves a user document from a MongoDB collection based on the provided username. It uses the find_one method to query the database with a filter matching the '_id' field to the given username. The function assumes the existence of a global variable 'dbusers' which represents a MongoDB collection. No explicit validation or error handling is present in the function body.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to locate the specific user document in the database."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "Any",
            "description": "The user document retrieved from the database if found; otherwise, None is returned implicitly by find_one when no match is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name field of a user document in a MongoDB collection identified by the username. It uses the MongoDB update_one method to modify only the name field, leaving other fields unchanged. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier of the user whose name needs to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name value to set for the specified user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation. This will typically be 1 if the user exists, or 0 if no matching document was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates the Gemini API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key needs to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be stored for the user, which will be encrypted before saving."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "This function updates the GPT API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key needs to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This indicates whether the user's GPT API key was updated."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and performs an update operation on the user document in the database. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL needs to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new Ollama base URL to be set for the specified user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This should typically be 1 if the user exists and the update was successful."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the OpenSRC API key for a given user in the database. It first encrypts the provided API key using an encryption function, then performs a MongoDB update operation to store the encrypted key under the user's document. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose OpenSRC API key needs to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The OpenSRC API key to be updated for the specified user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open source base URL for a user in the database. It takes a username and a new open source base URL as inputs, strips any leading or trailing whitespace from the URL, and attempts to update the corresponding document in the 'dbusers' collection. The function returns the number of documents that were modified as a result of the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL needs to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open source base URL to be set for the user. Leading and trailing whitespace will be stripped before updating."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This will typically be 0 if no matching document was found, or 1 if exactly one document was updated."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str or None",
            "description": "The Gemini API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The function retrieves a GPT API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gpt_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the OpenSource API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'opensrc_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to locate the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The OpenSource API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function retrieves the open source base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'opensrc_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str or None",
            "description": "The open source base URL associated with the user, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The function 'delete_user' removes a user document from a MongoDB collection based on the provided username. It uses the 'delete_one' method to target a specific user by their '_id', which corresponds to the username. The function then returns the count of deleted documents, which will be 1 if the user was found and deleted, or 0 if no such user existed.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, either 1 if the user was found and deleted, or 0 if no matching user was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys for a given username from a database. It fetches user data using the username as a key, then decrypts specific API keys (Gemini and GPT) while returning others as plain text. If the user is not found, it returns None for all values. The function assumes the existence of a MongoDB collection and decryption utilities.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key for the user, or an empty string if not found."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL for the user, or an empty string if not found."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSource API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSource base URL for the user, or an empty string if not found."
          }
        ],
        "usage_context": {
          "calls": "database.db.decrypt_text",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The function 'insert_chat' creates a new chat entry in a database with a unique identifier, associated username, chat name, and timestamp. It generates a UUID for the chat ID, records the current datetime as creation time, and inserts the chat document into a MongoDB collection named 'dbchats'. The function returns the ID of the newly inserted chat document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          }
        ],
        "returns": [
          {
            "name": "result.inserted_id",
            "type": "str",
            "description": "The unique identifier of the newly inserted chat document."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet den Benutzernamen als Filterkriterium und sortiert die Ergebnisse nach dem Erstellungsdatum in aufsteigender Reihenfolge. Das Ergebnis ist eine Liste der Chat-Dokumente, die dem Benutzer zugeordnet sind.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "Der Benutzername, dessen Chats abgerufen werden sollen."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "Eine Liste aller Chat-Dokumente, die dem angegebenen Benutzernamen zugeordnet sind, sortiert nach Erstellungsdatum."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a query using MongoDB's find_one method to locate the document matching both criteria. If a matching document is found, the function returns True; otherwise, it returns False. The function does not modify any data but only retrieves and evaluates the existence of a record.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if a chat with the specified username and chat_name exists in the database, False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and updates all associated exchanges in the database. It first updates the chat entry in the chats collection, then updates all related exchange entries in the exchanges collection. The function returns the number of modified chat documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to assign to the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of chat documents that were successfully modified during the renaming operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The function `insert_exchange` is designed to insert a new exchange record into a MongoDB collection. It takes various parameters related to a user's interaction, such as question, answer, feedback, and usage metrics, and stores them in a structured dictionary format. The function generates a unique ID for each exchange and attempts to insert the record into the database. If the insertion fails, it catches the exception and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question posed by the user."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in response to the question."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback provided by the user regarding the answer."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who initiated the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session associated with the exchange."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper tool used during the exchange (optional)."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main tool used during the exchange (optional)."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Total time taken for the exchange (optional)."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Time spent using the helper tool (optional)."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Time spent using the main tool (optional)."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Number of JSON tokens used (optional)."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Number of Toon tokens used (optional)."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Percentage of savings achieved (optional)."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique identifier generated for the inserted exchange record."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when the database insertion fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves all exchange records from a MongoDB collection for a given username. It sorts the results by creation timestamp in ascending order to ensure chronological display. The function performs a database query using the pymongo library and returns the sorted list of exchange documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier of the user whose exchange records are to be fetched."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange documents retrieved from the database, sorted by creation timestamp in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with specific criteria and orders the results by creation date in ascending order. The function returns the fetched exchanges as a list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the exchanges to be retrieved."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat associated with the exchanges to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange documents matching the provided username and chat name, sorted by creation date in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "The function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document with the new feedback value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The feedback value to be set in the document."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified as a result of the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message associated with a specific exchange document in a MongoDB collection. It takes an exchange ID and a new feedback message string, then attempts to update the corresponding document by setting the 'feedback_message' field. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be set in the exchange document."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified as a result of the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes a document from the 'dbexchanges' collection in a MongoDB database based on a provided exchange ID. It uses the 'delete_one' method to remove the matching document and returns the count of deleted documents. The function takes a single string parameter representing the exchange ID.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "A unique identifier for the exchange document to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the collection, typically 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The function deletes all exchanges and the chat entry associated with a given username and chat name from the database. It first removes all exchange records matching the criteria, then deletes the corresponding chat record. Finally, it returns the count of deleted chat entries. This ensures data consistency between the frontend and backend by removing all related chat data in a single operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "del_chat.deleted_count",
            "type": "int",
            "description": "The number of chat entries that were deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The function 'clean_names' takes a list of strings representing model paths and extracts the final component of each path by splitting on the '/' delimiter. It returns a new list containing only these final components. This is useful for simplifying model identifiers to their base names.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list[str]",
            "description": "A list of strings where each string represents a full path to a model, typically separated by forward slashes."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "list[str]",
            "description": "A list of strings containing the final component of each path in the input list, obtained by splitting on '/' and taking the last element."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The function filters a given list of models based on a specified category name. It retrieves keywords associated with the category and applies filtering logic depending on whether 'STANDARD' is included in those keywords. If 'STANDARD' is present, it returns only models that exist in a predefined standard list. Otherwise, it filters models whose names contain any of the retrieved keywords. If no models match the criteria, the original list is returned.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "A list of model names to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category used to determine filtering criteria."
          }
        ],
        "returns": [
          {
            "name": "filtered_models",
            "type": "list",
            "description": "A list of model names that match the filtering criteria. If no matches are found, the original source_list is returned."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_abort": {
      "identifier": "frontend.frontend.handle_abort",
      "description": {
        "overall": "The function 'handle_abort' is designed to signal an abort request within a Streamlit application. It sets a flag in the session state to indicate that an abort has been requested and displays a toast message to the user indicating that the abort is being processed. This function does not take any parameters and does not return any value.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function handles the saving of a Gemini API key entered by the user in a Streamlit frontend application. It retrieves the key from the session state, updates the database with the new key for the current user, clears the input field, and displays a success message to the user.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function retrieves an Ollama URL from the Streamlit session state and updates the database with the new URL for the current user. It also displays a success toast message upon completion. The function is designed to handle user input related to Ollama configuration.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_ollama_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_last_activity": {
      "identifier": "frontend.frontend.get_last_activity",
      "description": {
        "overall": "The function 'get_last_activity' determines the timestamp of the last message in a specified chat. It retrieves the chat's exchanges from the session state, checks if any exist, and extracts the datetime of the most recent exchange. If the datetime is stored as a string, it attempts to parse it into a datetime object. If no exchanges are found or parsing fails, it returns the minimum datetime value.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat for which to retrieve the last activity timestamp."
          }
        ],
        "returns": [
          {
            "name": "dt",
            "type": "datetime.datetime",
            "description": "The timestamp of the last message in the chat, or datetime.min if no messages exist or parsing fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The function loads user-specific chat and exchange data from a database into the Streamlit session state. It first checks if the user data is already loaded; if not, it fetches chats and exchanges associated with the given username. It initializes session state variables for chats and exchanges, handling missing feedback values by setting them to NaN. If no chats exist, it creates an initial chat and sets it as active. Finally, it sorts chats by last activity and sets the most recent one as the active chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load chat and exchange data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value for a given exchange object in the database and triggers a rerun of the Streamlit application. It takes an exchange dictionary and a new feedback value, assigns the new value to the 'feedback' key in the exchange dictionary, updates the corresponding record in the database using the exchange's ID, and then refreshes the Streamlit UI.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing an exchange object, expected to contain keys such as '_id' and 'feedback'."
          },
          {
            "name": "val",
            "type": "Any",
            "description": "The new feedback value to be assigned to the exchange object."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "The function handles the deletion of an exchange from the database and updates the session state accordingly. It first deletes the exchange by its ID using a database function, then checks if the exchange exists in the session state for a given chat and removes it if found. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is to be deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_exchange_by_id",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The function handles the deletion of a chat by first removing the chat data from the database using a database function, then cleaning up the session state by removing the deleted chat. If no chats remain after deletion, it creates a new default chat and sets it as the active one. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_full_chat, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from any URL present in that text. It uses regular expressions to find a URL, parses it using urllib.parse.urlparse, and then extracts the last segment of the URL path, which typically represents the repository name. If the extracted name ends with '.git', it removes the extension. If no URL is found or the path is empty, it returns None.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string that may contain a URL from which to extract the repository name."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name from the URL, with '.git' suffix removed if present."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when no valid URL is found in the input text or when the URL path is empty."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The function 'stream_text_generator' takes a string input and yields each word from the string followed by a space, with a small delay between each yield. It is designed to simulate a streaming text generator where words are produced one at a time. This function uses the 'time.sleep' function to introduce a brief pause between yielding each word.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string input containing the text to be streamed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text based on Mermaid code block delimiters and handles regular text and Mermaid diagrams differently. Regular text is rendered using Streamlit's markdown or streaming capabilities, while Mermaid diagrams are rendered using the st_mermaid component. If rendering fails, it falls back to displaying the diagram as plain code.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "A string containing markdown text that may include Mermaid code blocks enclosed in triple backticks with 'mermaid' language identifier."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A boolean flag indicating whether to stream the regular text content using Streamlit's write_stream functionality."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The function `render_exchange` is responsible for rendering a single exchange (question and answer pair) within a chat interface using Streamlit. It displays the user's question, processes and shows the assistant's answer, and provides interactive feedback mechanisms such as like/dislike buttons, note-taking, and download options. The function also handles error messages differently by displaying them directly without an assistant bubble.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the question, answer, feedback, and other metadata such as '_id'."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat session, used for handling deletion operations."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, frontend.frontend.render_text_with_mermaid",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_provider": {
      "identifier": "frontend.frontend.get_provider",
      "description": {
        "overall": "The function 'get_provider' determines the provider name based on the given model name. It evaluates the model name against specific conditions using string matching operations. If the model name starts with 'gemini', it returns 'Google Gemini'. If the model name is exactly 'llama3', it returns 'ollama'. If the model name starts with 'gpt-5', it returns 'gpt'. For all other cases, it defaults to returning 'Open Source LLM'.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string representing the name of the model for which the provider needs to be identified."
          }
        ],
        "returns": [
          {
            "name": "provider",
            "type": "str",
            "description": "A string indicating the provider associated with the given model name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.config_provider": {
      "identifier": "frontend.frontend.config_provider",
      "description": {
        "overall": "The `config_provider` function handles the configuration interface for different AI models within a Streamlit-based frontend. It displays status indicators for various API keys and URLs, and allows users to update these settings via forms. The function branches based on the `model_name` parameter to determine which configuration options to present and how to process updates.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string identifier that determines which model's configuration settings are displayed and updated."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key, database.db.update_gpt_key, database.db.update_ollama_url, database.db.update_opensrc_key, database.db.update_opensrc_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.check_stop_callback": {
      "identifier": "frontend.frontend.check_stop_callback",
      "description": {
        "overall": "This function is designed to check whether the user has requested to abort a process by examining the session state in Streamlit. It retrieves a boolean value indicating if the 'abort_requested' flag is set. The function serves as a callback mechanism to allow the backend to respond to user interactions, specifically the pressing of a stop button.",
        "parameters": [],
        "returns": [
          {
            "name": "return_value",
            "type": "bool",
            "description": "A boolean value indicating whether the user has requested to abort the process. Returns True if 'abort_requested' is set to True in the session state, otherwise returns False."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse an Abstract Syntax Tree (AST) generated from Python source code. It collects information about imports, classes, and functions, organizing them into a structured schema. The visitor maintains context about the current class being processed and builds detailed metadata for each element encountered during traversal.",
        "init_method": {
          "description": "Initializes the ASTVisitor with source code, file path, and project root. It computes the module path using a helper function and sets up an initial schema structure to store collected information including imports, functions, and classes. It also initializes a variable to track the currently visited class.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The full source code string of the file being analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The file path of the source code being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import nodes in the AST by extracting the names of imported modules and appending them to the schema's imports list. It ensures that all imported modules are recorded for later use in analysis.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when an import node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes import-from nodes in the AST by extracting the fully qualified names of imported items and appending them to the schema's imports list. This includes handling cases where modules are imported from other modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing an import-from statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when an import-from node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes class definition nodes in the AST by creating a detailed schema entry for the class, including its identifier, name, docstring, source code segment, and line numbers. It appends this information to the schema's classes list and tracks the current class being processed.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when a class definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Handles function definition nodes in the AST. If a class is currently being processed, it records the function as a method within that class. Otherwise, it treats the function as a top-level function and adds it to the schema's functions list. It captures details such as arguments, docstrings, and source code segments.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called automatically by the AST traversal mechanism when a function definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Processes asynchronous function definition nodes in the AST by delegating to the standard function definition handler. This allows async functions to be treated similarly to regular functions in terms of schema collection.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method delegates processing to visit_FunctionDef.",
                "called_by": "This method is called automatically by the AST traversal mechanism when an async function definition node is encountered."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.AST_Schema.path_to_module for computing module paths.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Trees (ASTs) and building a structured schema that includes information about imports, functions, classes, and their relationships. It merges relationship data such as outgoing calls, incoming calls, dependencies, and instantiation contexts into the parsed schema. The class also handles error cases during parsing and ensures proper handling of file paths and project roots.",
        "init_method": {
          "description": "Initializes an instance of the ASTAnalyzer class. The constructor currently does not perform any initialization actions.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method integrates relationship data\u2014such as outgoing and incoming calls\u2014into a full schema representation of a Python repository. It processes function and class nodes to attach call and called-by information, and computes class dependencies based on method calls outside the class scope.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary containing the full schema of the repository, including file structures and AST node details."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "A dictionary containing raw relationship data, including outgoing and incoming call mappings."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated schema with integrated relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call other functions or methods.",
                "called_by": "This method is not called by any other function or method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method performs a complete analysis of a list of Python files within a Git repository. It parses each file's content into an AST, uses an ASTVisitor to extract schema nodes, and builds a structured representation of the repository including imports, functions, and classes. It also manages path resolution and handles potential parsing errors gracefully.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects representing Python source files to be analyzed."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "An object representing the Git repository containing the files to be analyzed."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary containing the structured schema of the repository with file-wise AST node information."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.AST_Schema.ASTVisitor class to parse and extract schema nodes from the source code.",
                "called_by": "This method is not called by any other function or method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.AST_Schema.ASTVisitor class for parsing and extracting schema nodes from Python source code.",
          "instantiated_by": "This class is not instantiated by any other class or function according to the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve Python import dependencies within a repository. It extends NodeVisitor to traverse AST nodes representing import statements and builds a dependency graph by tracking which files depend on others. The class handles both absolute and relative imports, resolving relative paths based on the repository structure and checking for module existence or symbol exports in __init__.py files.",
        "init_method": {
          "description": "Initializes the FileDependencyGraph with a filename and repository root path. Sets up the instance variables to track the current file being analyzed and the root directory of the repository.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for dependencies."
            },
            {
              "name": "repo_root",
              "type": "Any",
              "description": "The root directory path of the repository being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "Resolves relative import statements by determining the actual module or symbol names that would be imported. It analyzes the import level and path to locate matching files or symbols in the repository structure. The method checks for both direct module existence and symbol availability in __init__.py files.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
                "called_by": "This method is not called by any other method within the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles Import AST nodes by adding the imported module names to the dependency mapping. It ensures that the import dependencies dictionary is initialized for the current file and records the imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "An AST node representing an import statement."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "Optional base name for the import."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions according to the provided context.",
                "called_by": "This method is not called by any other method within the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes ImportFrom AST nodes to handle 'from ... import ...' statements. It extracts the module name and resolves relative imports by delegating to _resolve_module_name when necessary. It records the dependencies in the import_dependencies mapping.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions according to the provided context.",
                "called_by": "This method is not called by any other method within the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
          "instantiated_by": "This class is not instantiated by any other class or function according to the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class serves as a centralized interface for interacting with various language models, including Google Gemini, OpenAI, custom APIs, and Ollama. It handles API configuration, prompt loading, and batch processing of function and class documentation generation. The class supports structured output validation using Pydantic models and includes rate-limiting mechanisms to manage API usage.",
        "init_method": {
          "description": "Initializes the LLMHelper with API credentials and model configurations. It loads system prompts from specified files, configures batch settings based on the model name, and sets up appropriate language model clients depending on the model type. The class also prepares structured output validators for function and class analysis.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "API key for accessing the language model service."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for function documentation generation."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for class documentation generation."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "Name of the language model to use. Defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Base URL for custom API endpoints. Optional."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures the batch size for processing requests based on the specified model name. Different models have different recommended batch sizes to optimize performance and avoid rate limiting issues. If the model name is unrecognized, it defaults to a conservative batch size.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "Name of the language model being configured."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the __init__ method."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Processes a batch of function inputs to generate and validate documentation using the configured language model. It splits inputs into batches according to the configured batch size, sends them to the LLM, and handles errors by filling failed batches with None values while maintaining order. Includes rate-limiting delays between batches.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function input models to process."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analysis results or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other functions."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Processes a batch of class inputs to generate and validate documentation using the configured language model. Similar to generate_for_functions, it batches inputs, sends them to the LLM, and manages errors by filling failed batches with None values while preserving order. Includes rate-limiting delays between batches.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class input models to process."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analysis results or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other functions."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several external modules including langchain components for LLM integration, Pydantic models for input/output validation, and standard libraries like os, json, logging, and time.",
          "instantiated_by": "This class is not instantiated by any other functions or classes within the provided context."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs). It supports multiple model types including Google's Gemini models, OpenAI's GPT models, custom API endpoints, and local Ollama instances. The class initializes with an API key, a path to a system prompt file, and optional model and base URL parameters. It dynamically selects and configures the appropriate LLM client based on the specified model name. The class provides two main interaction methods: one for synchronous calls that return the full response content, and another for streaming responses chunk by chunk.",
        "init_method": {
          "description": "Initializes the MainLLM instance by validating the API key, loading the system prompt from a file, and configuring the appropriate LLM client based on the model name. It supports different LLM backends such as Google Generative AI, OpenAI-compatible APIs, and Ollama.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key used for authenticating with the LLM service."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt that will be loaded and used for LLM interactions."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use. Defaults to 'gemini-2.5-pro'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Optional base URL for connecting to a custom LLM endpoint."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "Sends a user input message to the configured LLM and returns the complete response content. It constructs a message sequence including the system prompt and the user input, invokes the LLM with these messages, and handles potential exceptions during the call.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The full content of the LLM's response, or None if an error occurs."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "Streams the response from the LLM in chunks as they become available. It constructs a message sequence including the system prompt and the user input, initiates a streaming request to the LLM, and yields each chunk of content as it arrives. In case of errors, it yields an error message instead.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "chunk_content",
                  "type": "str",
                  "description": "Yields content chunks from the LLM response or an error message if an exception occurs."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several external libraries including langchain_google_genai.ChatGoogleGenerativeAI, langchain_ollama.ChatOllama, langchain_openai.ChatOpenAI, and langchain_core.messages.HumanMessage and SystemMessage.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It initializes with a predefined structure for storing extracted information and provides methods to parse different file types, clean content, find relevant files, and extract specific sections from markdown files. The class orchestrates the extraction process by determining which files are present and parsing them in a prioritized order to fill in project details like title, description, features, technology stack, and installation instructions.",
        "init_method": {
          "description": "Initializes the ProjektInfoExtractor with a default information structure containing placeholders for project overview and installation details. It sets up a dictionary with nested keys for project overview and installation, each with placeholder values indicating missing information.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from content, which can occur due to encoding errors when reading files in UTF-16 format but interpreted as UTF-8. It ensures that the content is clean before further processing.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The string content potentially containing null bytes to be cleaned."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "The cleaned string with null bytes removed."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by other internal methods such as `_parse_readme`, `_parse_toml`, and `_parse_requirements` to sanitize input content before processing."
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches for a file among a list of files based on a set of patterns, performing a case-insensitive comparison. It iterates through the provided files and checks if any file path ends with one of the specified patterns.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file extension patterns to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[Any]",
                  "description": "The matching file object if found, otherwise None."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the `extrahiere_info` method to locate relevant project files such as README, pyproject.toml, and requirements.txt."
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text under a specific Markdown heading (indicated by ##) using regular expressions. It searches for a given list of keywords and captures the content until the next heading or end of file.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The full content of a markdown file."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords to look for as section headers."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[str]",
                  "description": "The extracted content under the matched heading, or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the `_parse_readme` method to extract specific sections like Features, Tech Stack, Status, Installation, and Quick Start from README files."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file to extract various project details including title, description, key features, technology stack, current status, setup instructions, and quick start guide. It uses helper methods to clean content and extract sections from markdown.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file to be parsed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls `_clean_content`, `_extrahiere_sektion_aus_markdown` to process and extract information from the README content.",
                "called_by": "This method is called by the `extrahiere_info` method during the information extraction process."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file to extract project metadata such as name, description, and dependencies. It handles potential TOML decoding errors gracefully and logs warnings if the required library is not installed.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file to be parsed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls `_clean_content` to sanitize the input content before parsing.",
                "called_by": "This method is called by the `extrahiere_info` method during the information extraction process."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file to extract dependency information. It filters out comments and empty lines, and only populates dependencies if they haven't already been set by another parser.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file to be parsed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls `_clean_content` to sanitize the input content before parsing.",
                "called_by": "This method is called by the `extrahiere_info` method during the information extraction process."
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the entire information extraction process by identifying relevant project files, parsing them in a priority order (pyproject.toml first, then requirements.txt, then README), and formatting the final output. It also derives a default project title from the repository URL if necessary.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects representing project files."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository, used to derive a default project title if needed."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information organized under 'projekt_uebersicht' and 'installation' keys."
                }
              ],
              "usage_context": {
                "calls": "Calls `_finde_datei`, `_parse_toml`, `_parse_requirements`, and `_parse_readme` to locate and parse relevant files.",
                "called_by": "This method is the main interface for extracting project information and is typically called by higher-level components in the application."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on standard Python libraries including re, os, tomllib, and typing modules for type hints.",
          "instantiated_by": "This class is instantiated by other components in the backend module, likely during the processing of project documentation or metadata extraction tasks."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is an AST visitor designed to analyze Python source code and construct a call graph representation. It tracks function and method definitions, imports, and function calls to build a directed graph that shows relationships between different callable entities in the code. The graph includes nodes representing functions and edges representing calls between them, supporting both local and imported function references.",
        "init_method": {
          "description": "Initializes the CallGraph with a filename and sets up internal data structures including tracking for current function and class scope, local definitions, a NetworkX directed graph for storing the call relationships, import mappings, and sets for tracking functions and edges.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for call graph construction."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "Recursively traverses an AST node to extract the dotted name components of a function or attribute access. It handles various AST node types like Call, Name, and Attribute to reconstruct the full path of a reference.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node to traverse for extracting name components."
                }
              ],
              "returns": [
                {
                  "name": "parts",
                  "type": "list[str]",
                  "description": "A list of string components forming the dotted name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the _resolve_all_callee_names method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "Resolves a list of dotted name components into fully qualified names by checking against local definitions, import mappings, and constructing appropriate names based on the current class and file context.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists representing name components for potential callees."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved fully qualified names for the callees."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _recursive_call method to resolve name components.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "Constructs a fully qualified name for a function or method by combining the filename, optional class name, and base name. This helps in uniquely identifying functions within the context of the file and class hierarchy.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name of the function or method."
                },
                {
                  "name": "class_name",
                  "type": "Optional[str]",
                  "description": "The name of the class if the function is a method."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The fully qualified name constructed from the filename, class name, and base name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_FunctionDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "Determines the current caller's name based on whether a function is currently being visited. If there is no active function, it defaults to the global scope or the filename.",
              "parameters": [
                {
                  "name": "self",
                  "type": "CallGraph",
                  "description": "The instance of the CallGraph class."
                }
              ],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The name of the current caller, either the function name or a default scope identifier."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST Import nodes by mapping aliases to their actual module names and storing them in the import mapping dictionary for later resolution of function calls.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the generic AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles AST ImportFrom nodes by mapping aliases to their respective modules and stores these mappings for resolving function calls originating from imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing an import from statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the generic AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes AST ClassDef nodes by temporarily setting the current class name during traversal, allowing proper scoping for function definitions within classes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the generic AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes AST FunctionDef nodes by registering the function in local definitions, adding it as a node in the call graph, and tracking its full name for future call resolution.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _make_full_name and generic_visit methods.",
                "called_by": "This method is called by the generic AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles AST AsyncFunctionDef nodes by delegating processing to the visit_FunctionDef method, treating async functions similarly to regular functions in terms of call graph construction.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AST node representing an asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the visit_FunctionDef method.",
                "called_by": "This method is called by the generic AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Processes AST Call nodes by identifying the caller and resolving the callee names, then adds edges to the call graph to represent the function call relationship.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing a function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _current_caller, _recursive_call, and _resolve_all_callee_names methods.",
                "called_by": "This method is called by the generic AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "Handles AST If nodes, particularly those related to main block checks (__name__ == '__main__'), by temporarily changing the current function context to '<main_block>' during traversal of such blocks.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The AST node representing an if statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the generic AST traversal mechanism."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the ast module for parsing Python source code and networkx for graph operations.",
          "instantiated_by": "This class is not explicitly instantiated in the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.call_resolver.CallResolver": {
      "identifier": "backend.diagram_generation.call_resolver.CallResolver",
      "description": {
        "overall": "The CallResolver class is responsible for resolving raw function calls in a project into their corresponding resolved representations. It operates on a ProjectIndex to determine the nature of calls, whether they are direct, imported, method-based, or dynamic, and maps them to appropriate callee entities. The class provides functionality to process collections of raw calls and resolve them into structured data that can be used for diagram generation.",
        "init_method": {
          "description": "Initializes the CallResolver with a ProjectIndex, which serves as the central data structure for accessing module and class information during call resolution.",
          "parameters": [
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "An index of the project's modules and classes used for resolving function calls."
            }
          ]
        },
        "methods": [
          {
            "identifier": "resolve_all",
            "description": {
              "overall": "Processes a dictionary of raw calls grouped by module and resolves each call into a list of resolved calls. It iterates over the provided calls and delegates resolution to the 'resolved' method for each individual call.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "dict[str, list[RawCall]]",
                  "description": "A mapping of module names to lists of raw calls to be resolved."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "dict[str, list[ResolvedCall]]",
                  "description": "A mapping of module names to lists of resolved calls."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods within the class.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "resolved",
            "description": {
              "overall": "Resolves a single raw call by determining the type of function node (Name or Attribute) and delegating to the appropriate private resolution method. If the node type is neither Name nor Attribute, it returns a resolved call with UNKNOWN type.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call to be resolved."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved calls derived from the raw call."
                }
              ],
              "usage_context": {
                "calls": "This method calls the private methods '_resolve_name' and '_resolve_attribute' depending on the type of the function node.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_name",
            "description": {
              "overall": "Resolves a raw call when the function node is an ast.Name. It checks if the name corresponds to a function in the current module or an imported alias, and constructs a resolved call accordingly.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call containing the name node to resolve."
                },
                {
                  "name": "node",
                  "type": "ast.Name",
                  "description": "The AST node representing the function name."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved calls based on the name resolution."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods within the class.",
                "called_by": "This method is called by the 'resolved' method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_attribute",
            "description": {
              "overall": "Resolves a raw call when the function node is an ast.Attribute. It handles cases like method calls on 'self', imports, and dynamic lookups across all classes in the project to find matching methods.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call containing the attribute node to resolve."
                },
                {
                  "name": "node",
                  "type": "ast.Attribute",
                  "description": "The AST node representing the function attribute."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved calls based on the attribute resolution."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods within the class.",
                "called_by": "This method is called by the 'resolved' method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several data types including CallType, RawCall, ResolvedCall, and ProjectIndex, but no external dependencies are listed.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.callgraph.TreeVisitor": {
      "identifier": "backend.diagram_generation.callgraph.TreeVisitor",
      "description": {
        "overall": "The TreeVisitor class is designed to traverse an Abstract Syntax Tree (AST) to extract call relationships between functions and methods within a Python project. It extends NodeVisitor to customize traversal behavior for ClassDef, FunctionDef, and Call nodes. During traversal, it tracks the current function and class being visited, enabling accurate identification of callers and their contexts. It collects these call relationships into a list of RawCall objects which can later be used to generate call graphs.",
        "init_method": {
          "description": "Initializes the TreeVisitor with a module symbol and a project index. It sets up tracking variables for the current function and class being processed during AST traversal, and initializes an empty list to store detected calls.",
          "parameters": [
            {
              "name": "module",
              "type": "ModuleSymbol",
              "description": "Represents the module being analyzed."
            },
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "Provides access to the entire project's modules and symbols."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles the traversal of class definitions in the AST. It temporarily updates the current class being processed, visits the child nodes recursively, and then restores the previous class context after traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [
                {
                  "name": "None",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions.",
                "called_by": "This method is called by the generic AST visitor during traversal of ClassDef nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definitions in the AST. It determines whether the function belongs to a class or is a top-level function, updates the current function context accordingly, and then recursively visits child nodes before restoring the previous function context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "None",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions.",
                "called_by": "This method is called by the generic AST visitor during traversal of FunctionDef nodes."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes call expressions in the AST. It checks if there is a valid current function context and verifies that the called function is defined within the module or project. If so, it creates a RawCall object with contextual information and appends it to the internal calls list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Call",
                  "description": "The AST node representing a function call expression."
                }
              ],
              "returns": [
                {
                  "name": "None",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions.",
                "called_by": "This method is called by the generic AST visitor during traversal of Call nodes."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not depend on any external libraries or modules beyond those already imported.",
          "instantiated_by": "This class is not instantiated by any other code within the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.FunctionSymbol": {
      "identifier": "backend.diagram_generation.data_types.FunctionSymbol",
      "description": {
        "overall": "The FunctionSymbol class represents a symbolic representation of a function, capturing essential metadata such as its name, module, qualified name, input parameters, return type, and line number. It serves as a data container for function-related information used in diagram generation processes.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, relying instead on default initialization behavior for its attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies listed.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ClassSymbol": {
      "identifier": "backend.diagram_generation.data_types.ClassSymbol",
      "description": {
        "overall": "The ClassSymbol class represents a symbolic representation of a class within a diagram generation system. It encapsulates essential metadata about a class, including its name, module, and associated methods. This class serves as a data carrier for class information, facilitating the construction and visualization of class diagrams by storing relevant attributes and their relationships.",
        "init_method": {
          "description": "The constructor for ClassSymbol does not explicitly define any parameters beyond the default self. It relies on class-level attributes to store information about the class symbol.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries.",
          "instantiated_by": "This class is not instantiated by any other components."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ModuleSymbol": {
      "identifier": "backend.diagram_generation.data_types.ModuleSymbol",
      "description": {
        "overall": "The ModuleSymbol class represents a module in a Python codebase, encapsulating metadata about the module such as its name, the packages it belongs to, and the functions and classes it contains. It also tracks the module's imports. This class acts as a data container for organizing and representing module-level information in a diagram generation system.",
        "init_method": {
          "description": "The ModuleSymbol class does not define an explicit __init__ method. As a result, it relies on default initialization behavior, likely through dataclass decorators or similar mechanisms not visible in the provided source code.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on external modules such as ast.expr, dataclasses.dataclass, enum.Enum, and typing.Optional, which are used for type annotations and data handling.",
          "instantiated_by": "The class is not explicitly instantiated by any other component mentioned in the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallContext": {
      "identifier": "backend.diagram_generation.data_types.CallContext",
      "description": {
        "overall": "The CallContext class is a data structure designed to hold symbolic references to a module, function, and optionally a class. It serves as a container for contextual information related to a call site within a codebase, particularly useful in diagram generation or static analysis tasks where tracking the origin and scope of function calls is important.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, relying on default initialization behavior for dataclass-style attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on symbols such as ModuleSymbol, FunctionSymbol, and ClassSymbol, which are likely defined elsewhere in the codebase.",
          "instantiated_by": "This class is not explicitly instantiated by any known component based on the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.RawCall": {
      "identifier": "backend.diagram_generation.data_types.RawCall",
      "description": {
        "overall": "The RawCall class is a data structure designed to represent a call to a function within a program's abstract syntax tree (AST). It encapsulates essential information about the caller, the function node being called, the line number of the call, and the context in which the call occurs. This class serves as a lightweight container for storing and passing around details related to function calls during diagram generation processes.",
        "init_method": {
          "description": "The RawCall class does not define an explicit __init__ method, relying instead on the default initialization behavior of data classes. It initializes instance attributes based on the class variables declared in the class body.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond standard Python typing and dataclass features.",
          "instantiated_by": "This class is not instantiated by any other components as indicated by the context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallType": {
      "identifier": "backend.diagram_generation.data_types.CallType",
      "description": {
        "overall": "The CallType class is an enumeration that defines various types of function or method calls within a codebase. It provides a standardized way to categorize calls into distinct types such as direct calls, method calls, imported calls, dynamic calls, and unknown calls. This enum serves as a type-safe mechanism to represent different call patterns, aiding in code analysis and diagram generation tasks.",
        "init_method": {
          "description": "The CallType class is initialized as an Enum with predefined string values representing different call types. Each member of the enum corresponds to a specific type of call, providing a fixed set of options for categorizing call patterns in code analysis.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "DIRECT",
            "description": {
              "overall": "The DIRECT call type represents a direct function or method call within the code. This is typically a call made directly to a function or method defined in the same scope or accessible through standard scoping rules.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions."
              }
            },
            "error": null
          },
          {
            "identifier": "METHOD",
            "description": {
              "overall": "The METHOD call type represents a call to a method belonging to an object instance. This type of call involves invoking a method on an object, typically using dot notation like obj.method().",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions."
              }
            },
            "error": null
          },
          {
            "identifier": "IMPORTED",
            "description": {
              "overall": "The IMPORTED call type represents a call to a function or method that is imported from an external module or library. These calls reference functions that are not defined locally but are brought into scope through import statements.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions."
              }
            },
            "error": null
          },
          {
            "identifier": "DYNAMIC",
            "description": {
              "overall": "The DYNAMIC call type represents a call that is determined at runtime rather than compile time. This could include calls made through reflection, function pointers, or other mechanisms where the target of the call is not known until execution.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions."
              }
            },
            "error": null
          },
          {
            "identifier": "UNKNOWN",
            "description": {
              "overall": "The UNKNOWN call type represents a call whose type cannot be definitively categorized. This serves as a fallback option when the analysis system cannot determine the specific nature of a call pattern.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any other components."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ResolvedCall": {
      "identifier": "backend.diagram_generation.data_types.ResolvedCall",
      "description": {
        "overall": "The ResolvedCall class is a data structure designed to represent a resolved function call within a diagram generation system. It encapsulates information about the caller, the callee (if available), the type of call, and the line number where the call occurs. This class serves as a lightweight container for storing and passing around details related to function calls during the analysis and visualization process.",
        "init_method": {
          "description": "The ResolvedCall class does not define an explicit __init__ method. Instead, it relies on dataclass-style attribute definitions to initialize its fields. The constructor implicitly initializes the caller, callee, call_type, and lineno attributes based on the provided values during instantiation.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on FunctionSymbol, CallType, and Optional from typing module.",
          "instantiated_by": "This class is not explicitly instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ProjectIndex": {
      "identifier": "backend.diagram_generation.data_types.ProjectIndex",
      "description": {
        "overall": "The ProjectIndex class serves as a container for managing modules within a project, specifically storing them in a dictionary keyed by their identifiers. It provides a method to retrieve all classes across all modules, enabling traversal of the entire class hierarchy within the project.",
        "init_method": {
          "description": "Initializes the ProjectIndex with a dictionary of modules. The constructor does not take any explicit parameters beyond the implicit 'self', and relies on the 'modules' attribute being set externally or through other initialization mechanisms.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "all_classes",
            "description": {
              "overall": "Retrieves a flattened list of all ClassSymbol instances from all modules stored in the ProjectIndex. It iterates over each module in the modules dictionary and then over each class within each module's classes dictionary, collecting all classes into a single list.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectIndex",
                  "description": "The instance of the ProjectIndex class."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[ClassSymbol]",
                  "description": "A list containing all ClassSymbol instances from all modules."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were specified for this class.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidSequenceEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidSequenceEmitter",
      "description": {
        "overall": "The MermaidSequenceEmitter class is responsible for generating Mermaid.js sequence diagram representations from a list of resolved function calls. It collects participants involved in the calls, emits call interactions, and handles return values to produce a formatted Mermaid sequence diagram string.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, so it inherits the default initialization behavior from the base object class.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a complete Mermaid sequence diagram by collecting participants, sorting calls by line number, emitting each call and its potential response, and formatting the result into a Mermaid block.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved call objects representing function calls to be included in the diagram."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "A formatted string representing the Mermaid sequence diagram."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_participants",
            "description": {
              "overall": "The _collect_participants method gathers unique participant names from the resolved calls by extracting caller and callee names, ensuring they are properly formatted for use in the Mermaid diagram.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved call objects from which to extract participant names."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of participant names formatted for Mermaid diagram inclusion."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id utility function to format participant names.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_response",
            "description": {
              "overall": "The _emit_response method generates a Mermaid notation line for a return statement from a callee back to a caller, using their formatted names.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A resolved call object representing a function call with a return value."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "A formatted Mermaid line representing a return message from callee to caller."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id utility function to format the names of the callee and caller.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_call",
            "description": {
              "overall": "The _emit_call method formats a resolved call into a Mermaid notation line showing a call from a caller to a callee, including the input parameters if available.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A resolved call object representing a function call to be emitted."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "A formatted Mermaid line representing a function call."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id utility function to format the names of the caller and callee.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.diagram_generation.emitter.mermaid_id utility function.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidOverviewArchitectureEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidOverviewArchitectureEmitter",
      "description": {
        "overall": "The MermaidOverviewArchitectureEmitter class is responsible for generating a Mermaid diagram representation of the architectural overview of modules. It takes a dictionary of ModuleSymbol objects and produces a string formatted in Mermaid graph syntax, showing dependencies between modules based on their imports.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, so it inherits the default initialization behavior from the base object class.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a Mermaid graph representation of module dependencies. It iterates over the provided modules, extracts source and destination module names, and constructs dependency arrows in the Mermaid format. Each module's name is derived by splitting on '.' and taking the last part. Dependencies are only included if the target module exists in the provided modules dictionary.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary mapping module names to ModuleSymbol objects, which contain information about module imports."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "A string representing the Mermaid graph syntax for the module architecture overview."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports list.",
          "instantiated_by": "This class is not instantiated by any other classes or functions according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidClassDiagramEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidClassDiagramEmitter",
      "description": {
        "overall": "The MermaidClassDiagramEmitter class is responsible for generating Mermaid.js class diagram representations from a collection of module symbols. It iterates over modules and their classes, formatting class definitions and method signatures, and also includes relationships between modules based on import statements.",
        "init_method": {
          "description": "The class does not define an explicit constructor (__init__ method), so it relies on default initialization behavior.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method constructs a Mermaid class diagram by processing a dictionary of module symbols. It begins with a classDiagram header, then iterates through each module and its classes to generate class blocks with method signatures. It also adds import relationships between modules. Finally, it joins all generated lines with newlines to form the complete diagram string.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary mapping module names to ModuleSymbol objects, which contain information about classes and imports."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "str",
                  "description": "A string representing the complete Mermaid class diagram."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id function to convert identifiers into Mermaid-compatible format.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.diagram_generation.emitter.mermaid_id function for converting identifiers.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.SymbolCollector": {
      "identifier": "backend.diagram_generation.symbol_collector.SymbolCollector",
      "description": {
        "overall": "The SymbolCollector class is a visitor implementation that traverses an Abstract Syntax Tree (AST) to collect symbolic information about modules, including imports, classes, and functions. It builds a structured representation of the module's components using ModuleSymbol, ClassSymbol, and FunctionSymbol objects. The collector processes different AST node types such as imports, class definitions, and function definitions to extract metadata like names, parameters, return status, and asynchronous properties.",
        "init_method": {
          "description": "Initializes the SymbolCollector with a module name and a list of packages. It sets up a ModuleSymbol object which serves as the central data structure to store collected symbols for the module being processed.",
          "parameters": [
            {
              "name": "module_name",
              "type": "str",
              "description": "The name of the module being processed."
            },
            {
              "name": "packages",
              "type": "list[str]",
              "description": "A list of package names that the module belongs to."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_has_return",
            "description": {
              "overall": "Checks whether a given function definition AST node contains any return statements. It iterates through the body of the function and identifies if any statement is of type Return. This helps determine if the function has a return value.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "bool",
                  "description": "True if the function has at least one return statement, false otherwise."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_ClassDef method to check for return statements in class methods."
              }
            },
            "error": null
          },
          {
            "identifier": "_declare_input_parameters",
            "description": {
              "overall": "Extracts the names of input parameters from a function definition AST node. It iterates through the arguments of the function and collects the names of the parameters, returning them as a list of strings.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of parameter names extracted from the function definition."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_ClassDef and visit_AsyncFunctionDef methods to get input parameters for function symbols."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import nodes in the AST. For each imported name, it stores the mapping between the alias (or original name) and the full import path in the module's imports dictionary. It then continues visiting child nodes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import",
                  "description": "The AST node representing an import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No return value."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is invoked by the generic AST traversal mechanism when encountering an import node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles 'from ... import ...' statements in the AST. It resolves the base module name and maps each imported name to its qualified path. Relative imports are currently not handled and result in early return.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No return value."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is invoked by the generic AST traversal mechanism when encountering an import from node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes class definition nodes in the AST. It creates a ClassSymbol for the class and populates it with information about its methods. For each method within the class, it checks for return statements and extracts input parameters to create FunctionSymbol objects.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No return value."
                }
              ],
              "usage_context": {
                "calls": "This method calls _has_return and _declare_input_parameters to process class methods.",
                "called_by": "This method is invoked by the generic AST traversal mechanism when encountering a class definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles asynchronous function definitions in the AST. It checks if the function is defined within a class and skips processing if so. Otherwise, it creates a FunctionSymbol for the async function, capturing details like name, module, qualifiers, asynchronous nature, input parameters, and return status.",
              "parameters": [
                {
                  "name": "node",
                  "type": "AsyncFunctionDef",
                  "description": "The AST node representing an asynchronous function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No return value."
                }
              ],
              "usage_context": {
                "calls": "This method calls _has_return and _declare_input_parameters to process function details.",
                "called_by": "This method is invoked by the generic AST traversal mechanism when encountering an async function definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes regular function definitions in the AST. It delegates the actual processing to visit_AsyncFunctionDef, effectively treating all function definitions uniformly by converting them into async function processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a regular function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "No return value."
                }
              ],
              "usage_context": {
                "calls": "This method calls visit_AsyncFunctionDef to handle function definitions.",
                "called_by": "This method is invoked by the generic AST traversal mechanism when encountering a regular function definition node."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several AST-related modules and diagram generation data types including ModuleSymbol, FunctionSymbol, ClassSymbol, and NodeVisitor.",
          "instantiated_by": "This class is not directly instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as the blob object, content, and size to optimize resource usage. The class provides properties to access these lazily-loaded attributes and includes utility methods for word count analysis and serialization to a dictionary format.",
        "init_method": {
          "description": "Initializes a RepoFile object by storing the file path and commit tree. It also initializes internal attributes for caching the blob, content, and size of the file, which are loaded lazily upon first access.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "A property that lazily loads and returns the Git blob object associated with the file. If the blob has not yet been loaded, it attempts to retrieve it from the commit tree using the stored file path. If the file is not found in the tree, a FileNotFoundError is raised.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "A property that lazily loads and returns the decoded content of the file. It reads the raw data stream from the blob and decodes it into a UTF-8 string, ignoring encoding errors. The content is cached after the first access.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "A property that lazily loads and returns the size of the file in bytes. It retrieves the size from the blob object and caches it after the first access.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "An example analysis method that counts the number of words in the file's content. It splits the content by whitespace and returns the length of the resulting list.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The total number of words in the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Provides a useful string representation of the RepoFile object, displaying the file path for debugging and logging purposes.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr",
                  "type": "str",
                  "description": "A string representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Serializes the RepoFile object into a dictionary. It includes basic file information such as path, name, size, and type. Optionally, it can also include the full content of the file if requested.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "If True, includes the file's content in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "This method calls os.path.basename to extract the filename from the path.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the 'tempfile', 'git.Repo', 'git.GitCommandError', 'logging', and 'os' modules.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to its files through RepoFile objects. It supports listing all files, retrieving a hierarchical file tree, and cleaning up the temporary directory upon closing. The class implements context manager protocols (__enter__ and __exit__) to facilitate automatic resource cleanup.",
        "init_method": {
          "description": "Initializes a GitRepository instance by cloning the specified repository URL into a temporary directory. It sets up necessary attributes such as the repository URL, temporary directory path, and references to the cloned repository and its latest commit. If cloning fails, it raises a RuntimeError after attempting to clean up resources.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "Retrieves a list of all files in the repository and creates RepoFile objects for each file. It uses the git command-line interface to list files and constructs RepoFile instances based on their paths and the repository's commit tree.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing all files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile class to instantiate file objects.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "Deletes the temporary directory used for cloning the repository and cleans up associated resources. It prints a message indicating the deletion of the temporary directory.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "Enables the use of the GitRepository instance in a 'with' statement, returning the instance itself for use within the context block.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The GitRepository instance itself."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "Implements the context manager protocol's exit method, ensuring that the close() method is called when exiting a 'with' block, thereby cleaning up temporary resources.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "exc_type",
                  "type": "Any",
                  "description": "Exception type if an exception occurred in the with block."
                },
                {
                  "name": "exc_val",
                  "type": "Any",
                  "description": "Exception value if an exception occurred in the with block."
                },
                {
                  "name": "exc_tb",
                  "type": "Any",
                  "description": "Exception traceback if an exception occurred in the with block."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the close() method to clean up resources.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "Constructs a hierarchical representation of the repository's file structure. If no files have been previously retrieved, it calls get_all_files() to fetch them. Then, it builds a nested dictionary structure representing directories and files, optionally including file content.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Flag indicating whether to include file content in the returned tree structure."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A hierarchical dictionary structure representing the repository's file tree."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods directly.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.getRepo.RepoFile class for creating file representations.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is responsible for analyzing Python project structures to determine relationships between functions, classes, and methods. It traverses the project directory to find Python files, parses their Abstract Syntax Trees (ASTs) to collect definitions, and resolves call relationships between these definitions. The analyzer maintains internal state including definitions, a call graph, and file ASTs during the analysis process.",
        "init_method": {
          "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including a dictionary for storing definitions, a defaultdict for maintaining the call graph, and a dictionary for caching file ASTs. It also defines a set of directories to ignore during traversal.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory path of the Python project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "Performs the core analysis of the project by finding all Python files, collecting definitions from each file, and resolving call relationships. It clears the cached ASTs after processing and returns the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "defaultdict(list)",
                  "description": "A mapping of callee identifiers to lists of caller information."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "Transforms the internal call graph into a more accessible format by separating outgoing and incoming relationships for each identifier. It organizes these relationships into sorted sets for easier consumption.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing 'outgoing' and 'incoming' keys mapping identifiers to sorted lists of related identifiers."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "Recursively walks through the project root directory to find all Python (.py) files, excluding specified directories such as .git, venv, etc. It returns a list of absolute paths to these files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list[str]",
                  "description": "A list of absolute file paths ending with .py."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "Parses a given Python file's content into an AST and collects definitions of functions, methods, and classes. It maps these definitions to their respective module paths and stores metadata like file location and type. Errors during parsing are logged.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls backend.relationship_analyzer.path_to_module to convert file paths into module names.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "Traverses an AST to find the parent node of a given node. This is used to determine whether a function definition is part of a class or a standalone function.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The root of the AST being searched."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The node whose parent is to be found."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST or None",
                  "description": "The parent node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "Uses a CallResolverVisitor to traverse the AST of a file and resolve call relationships. It updates the internal call graph with the resolved calls. Errors during resolution are logged.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file to analyze for calls."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls backend.relationship_analyzer.CallResolverVisitor to resolve calls in the AST.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.relationship_analyzer.CallResolverVisitor and backend.relationship_analyzer.path_to_module.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is an AST (Abstract Syntax Tree) visitor designed to analyze Python code and resolve call relationships between functions and methods. It tracks the current execution context including class names, function names, and module paths to accurately map calls to their definitions. It also handles import resolution and assignment tracking for instance types. This class is primarily used during static analysis of Python code to understand inter-function dependencies.",
        "init_method": {
          "description": "Initializes the CallResolverVisitor with a file path, project root directory, and a dictionary of definitions. It sets up internal state variables such as scope, instance types, and call tracking structures.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The absolute path to the Python file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project being analyzed."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary mapping qualified names to their definitions or metadata."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles AST nodes representing class definitions. It updates the current class name context before visiting child nodes and restores the previous class name after traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing the class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor framework when encountering a class definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes AST nodes representing function definitions. It manages the caller name context by setting the fully qualified name of the function based on the current module and class context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing the function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor framework when encountering a function definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes AST nodes representing function calls. It resolves the qualified name of the called function, checks if it exists in the definitions, and records the call relationship along with caller information like file, line number, and caller type.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing the function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor framework when encountering a function call node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST nodes representing import statements. It adds imported names to the current scope mapping them to their original names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing the import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor framework when encountering an import node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes AST nodes representing 'from ... import ...' statements. It resolves the full module path for imports and maps aliases to their fully qualified names in the scope.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing the 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor framework when encountering an 'import from' node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Handles AST nodes representing assignment statements. Specifically, it identifies assignments to instances of classes by checking if the assigned value is a call to a known class and stores the mapping of variable names to qualified class names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node representing the assignment statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor framework when encountering an assignment node."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the qualified name of a function call node by looking up names in the current scope or constructing a local path. It handles both direct name lookups and attribute-based access (e.g., obj.method).",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.expr",
                  "description": "The AST node representing the function being called."
                }
              ],
              "returns": [
                {
                  "name": "callee_pathname",
                  "type": "str or None",
                  "description": "The fully qualified name of the called function or None if not resolvable."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the visit_Call method to resolve the qualified name of a function call."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.relationship_analyzer.path_to_module utility function to compute module paths.",
          "instantiated_by": "This class is not directly instantiated by any other code mentioned in the context."
        }
      },
      "error": null
    },
    "schemas.enums.AnalysisMode": {
      "identifier": "schemas.enums.AnalysisMode",
      "description": {
        "overall": "The AnalysisMode class is an enumeration that defines different levels of analysis detail. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumeration for type safety and clarity. The enum includes four predefined modes: OVERVIEW, STANDARD, DETAILED, and DEEP_DIVE, each associated with a specific string identifier.",
        "init_method": {
          "description": "The class is initialized as a string-based enumeration with predefined values. No explicit initialization parameters are required as the enum values are defined directly in the class body.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__new__",
            "description": {
              "overall": "The __new__ method is implicitly used by the Enum class to create new enum instances. It ensures that each enum member is properly instantiated with its associated string value. This method handles the internal creation process of enum members without requiring explicit implementation in the user-defined class.",
              "parameters": [
                {
                  "name": "cls",
                  "type": "Type[AnalysisMode]",
                  "description": "The class being instantiated."
                },
                {
                  "name": "value",
                  "type": "str",
                  "description": "The string value associated with the enum member."
                }
              ],
              "returns": [
                {
                  "name": "instance",
                  "type": "AnalysisMode",
                  "description": "A new instance of the AnalysisMode enum."
                }
              ],
              "usage_context": {
                "calls": "This method internally uses the Enum base class mechanisms to manage enum instantiation.",
                "called_by": "This method is called automatically by the Python Enum metaclass during enum member creation."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not explicitly instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramFocus": {
      "identifier": "schemas.enums.DiagramFocus",
      "description": {
        "overall": "The DiagramFocus class is an enumeration that defines different focus areas for diagram visualization. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumerated type. Each member represents a specific aspect of diagramming such as architecture, data flow, dependencies, and call graphs.",
        "init_method": {
          "description": "The class does not define a custom __init__ method, relying on the default initialization inherited from str and Enum.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramType": {
      "identifier": "schemas.enums.DiagramType",
      "description": {
        "overall": "The DiagramType class is an enumeration that defines various Mermaid diagram types as string values. It inherits from both str and Enum, allowing each diagram type to be used as a string while maintaining the benefits of an enumerated type for type safety and clarity. This class serves as a centralized and standardized way to represent different diagram types within the application.",
        "init_method": {
          "description": "The class does not define a custom __init__ method. It relies on the default initialization inherited from str and Enum, which sets up the enumeration values based on the class attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not instantiated by any other component as it is designed purely as an enumeration."
        }
      },
      "error": null
    },
    "schemas.enums.GraphType": {
      "identifier": "schemas.enums.GraphType",
      "description": {
        "overall": "The GraphType class is an enumeration that defines different types of input graphs used within the system. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumerated type. The class specifies three distinct graph types: CALLGRAPH, DEPENDENCY, and COMBINED, each associated with a corresponding string identifier.",
        "init_method": {
          "description": "The GraphType class does not define a custom __init__ method. It relies on the default initialization behavior inherited from the Enum base class, which sets up the enum members with their respective values.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__new__",
            "description": {
              "overall": "The __new__ method is responsible for creating new instances of the GraphType enum. It ensures that each enum member is properly initialized with its associated string value. This method is automatically invoked during enum member creation and handles the internal mechanics of assigning values to enum constants.",
              "parameters": [
                {
                  "name": "cls",
                  "type": "type",
                  "description": "The class being instantiated."
                },
                {
                  "name": "value",
                  "type": "str",
                  "description": "The string value associated with the enum member."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "GraphType",
                  "description": "A new instance of the GraphType enum with the specified value."
                }
              ],
              "usage_context": {
                "calls": "This method internally uses the standard Enum mechanism to assign values to enum members.",
                "called_by": "This method is called by the Python Enum metaclass during the instantiation of enum members."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not directly instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the description of a single parameter within a function. It encapsulates three essential attributes: the parameter's name, its type, and a textual description. This class ensures data integrity and provides a standardized structure for parameter metadata, making it suitable for use in API schemas, documentation systems, or any application requiring structured parameter information.",
        "init_method": {
          "description": "Initializes a ParameterDescription instance with required fields for a parameter's name, type, and description. As it inherits from BaseModel, it leverages Pydantic's validation capabilities to enforce type constraints on these fields.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not directly depend on any other external modules beyond its base class BaseModel and standard typing constructs.",
          "instantiated_by": "This class is not explicitly instantiated by any other component listed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model designed to represent and validate the description of a function's return value. It encapsulates three essential attributes: the name of the return value, its type, and a textual description. This class ensures data integrity and structure for return value metadata within the system.",
        "init_method": {
          "description": "Initializes a ReturnDescription instance with a name, type, and description. These fields are required and must be provided during instantiation.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the source file.",
          "instantiated_by": "This class is not directly instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model designed to represent and validate the calling context of a function. It captures two key pieces of information: the functions or methods that are called by the function in question, and the functions or methods that call the function in question. This class serves as a structured way to document and enforce the usage context of functions within a codebase.",
        "init_method": {
          "description": "Initializes a new instance of the UsageContext class with the specified 'calls' and 'called_by' attributes.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string describing the functions or methods called by the function."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string describing the functions or methods that call the function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on the pydantic.BaseModel for validation and serialization capabilities.",
          "instantiated_by": "This class is not explicitly instantiated by any other component listed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed information about a function's purpose, parameters, return values, and usage context. It serves as a structured representation for documenting function signatures and their associated metadata, making it suitable for use in automated documentation systems or API analysis tools.",
        "init_method": {
          "description": "The constructor initializes the FunctionDescription instance with required fields: overall description, a list of parameter descriptions, a list of return value descriptions, and a usage context object. It leverages Pydantic's BaseModel for data validation and serialization.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A textual description of the function's overall purpose and behavior."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the function."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects detailing each return value of the function."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "An object describing the usage context of the function, including dependencies and instantiation points."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not directly depend on any external modules beyond those imported in the file, which include standard typing utilities and Pydantic components.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class serves as the primary data model for representing the complete JSON schema of a function within the system. It encapsulates essential metadata about a function including its unique identifier, a detailed description of its behavior, and an optional error field that can indicate issues during processing.",
        "init_method": {
          "description": "Initializes a FunctionAnalysis instance with required fields for identifying the function, describing its behavior, and optionally capturing errors.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function being analyzed."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object containing detailed information about the function's purpose, parameters, and return values."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field that may contain error messages if the function analysis failed."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It encapsulates a textual description of the constructor's purpose and a list of parameters that the constructor accepts. This class serves as a structured representation for documenting constructor details, likely used in automated code analysis or documentation generation systems.",
        "init_method": {
          "description": "Initializes a ConstructorDescription instance with a description of the constructor and a list of parameter descriptions.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A string describing the purpose or behavior of the constructor."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter accepted by the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel for data validation and serialization, and uses schemas.enums.AnalysisMode, schemas.enums.DiagramFocus, and schemas.enums.DiagramType for potential extended functionality, although these are not directly used in this class.",
          "instantiated_by": "This class is not instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model designed to encapsulate information about a class's external dependencies and the entities that instantiate it. It serves as a structured representation of metadata related to class usage and integration within a system.",
        "init_method": {
          "description": "Initializes a ClassContext instance with two string fields: 'dependencies' and 'instantiated_by'. These fields store information about the class's external dependencies and the entities that create instances of the class, respectively.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string describing the entities or components that instantiate this class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to encapsulate a comprehensive analysis of a class. It holds information about the class's overall purpose, its constructor details, a list of its methods along with their descriptions, and contextual usage information. This structure serves as a standardized way to represent detailed class metadata and analysis results.",
        "init_method": {
          "description": "Initializes an instance of the ClassDescription class with fields for overall purpose, constructor description, a list of method analyses, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose and functionality of the class being analyzed."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object containing detailed information about the class's constructor, including its parameters and initialization logic."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects, each representing a method within the class and its associated metadata."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing contextual information about how the class is used, such as dependencies and instantiation points."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any external modules beyond those imported at the top level.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as the primary data structure for representing the complete schema of a class in a structured JSON format. It encapsulates essential metadata about the class, including its identifier, a detailed description, and an optional error field for capturing any issues during processing.",
        "init_method": {
          "description": "Initializes the ClassAnalysis instance with an identifier, a ClassDescription object, and an optional error message.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An object containing detailed information about the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store error messages related to the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on pydantic.BaseModel and schemas.enums modules for validation and enum definitions.",
          "instantiated_by": "This class is not instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It serves as a data structure for documenting call relationships in the system.",
        "init_method": {
          "description": "Initializes a CallInfo instance with fields for file path, function name, call mode, and line number.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file path where the call occurs."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function being called."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, such as 'method', 'function', or 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number in the file where the call occurs."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were specified.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to represent structured context for analyzing a function. It encapsulates two key pieces of information: a list of function names that the analyzed function calls, and a list of CallInfo objects indicating which functions call the analyzed function. This class serves as a data transfer object to convey contextual metadata about function relationships within a codebase.",
        "init_method": {
          "description": "The class is initialized with two fields: 'calls', which is a list of strings representing function names called by the analyzed function, and 'called_by', which is a list of CallInfo objects indicating the callers of the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the names of functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class serves as a structured input model for generating FunctionAnalysis objects. It encapsulates all necessary information including the analysis mode, identifier, source code, imports, and contextual data required for processing.",
        "init_method": {
          "description": "Initializes the FunctionAnalysisInput instance with the specified parameters, setting up the structure for function analysis input data.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal[\"function_analysis\"]",
              "description": "Specifies the analysis mode as 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements used in the function's source code."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "Additional contextual information required for the function analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on pydantic.BaseModel and schemas.enums.AnalysisMode for validation and enum definitions.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to structure contextual information about a method within a class. It encapsulates details such as the method's identifier, the methods it calls, the methods that call it, its arguments, and its docstring. This class serves as a standardized way to represent and exchange method-level metadata, particularly useful in tools that analyze or visualize code structures.",
        "init_method": {
          "description": "The class is initialized with a set of predefined fields that define the structure of method context information. It inherits from BaseModel, which provides serialization and validation capabilities.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__init__",
            "description": {
              "overall": "Initializes the MethodContextInput instance with the specified fields. As a Pydantic model, it leverages BaseModel's initialization mechanism to handle field assignment and validation.",
              "parameters": [
                {
                  "name": "kwargs",
                  "type": "dict",
                  "description": "Keyword arguments passed to the BaseModel constructor for initializing the fields."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the parent class BaseModel.__init__ to initialize the instance.",
                "called_by": "This method is typically called internally by the Python runtime when creating instances of MethodContextInput."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel for data validation and serialization features, and uses typing constructs like List and Optional for type hinting.",
          "instantiated_by": "This class is instantiated by code that needs to represent structured method context information, likely during static analysis or documentation generation processes."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to encapsulate structured context information for analyzing a class. It holds three main pieces of data: a list of dependencies, a list of call information for instances where the class is instantiated, and a list of method context inputs for each method within the class.",
        "init_method": {
          "description": "The constructor initializes the ClassContextInput instance with three attributes: dependencies, instantiated_by, and method_context. These attributes are expected to hold lists of strings, CallInfo objects, and MethodContextInput objects respectively.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of string identifiers representing the dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects detailing where and how the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects providing context for each method within the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any external modules beyond those imported at the top level.",
          "instantiated_by": "This class is not instantiated by any other component as indicated by the empty instantiated_by list in the context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput is a Pydantic model designed to encapsulate the input required for generating a ClassAnalysis object. It defines the structure and types of data needed to perform class analysis, including metadata about the class being analyzed, its source code, imports, and contextual information.",
        "init_method": {
          "description": "Initializes the ClassAnalysisInput model with fields defining the analysis mode, class identifier, source code, list of imports, and contextual information.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal[\"class_analysis\"]",
              "description": "A literal string value indicating the analysis mode is set to 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string representing the name of the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "A string containing the raw source code of the class definition."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of strings representing the import statements used in the source file."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "An object containing contextual information related to the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on Pydantic BaseModel for data validation and serialization, along with several enums and schemas from the 'schemas' module.",
          "instantiated_by": "This class is not instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.DiagramRequest": {
      "identifier": "schemas.types.DiagramRequest",
      "description": {
        "overall": "The DiagramRequest class is a Pydantic model designed to define the structure of input data required for requesting diagram generation. It specifies the necessary components such as nodes and edges, along with optional configuration parameters like mode and focus to control the diagram generation process.",
        "init_method": {
          "description": "Initializes the DiagramRequest model with required fields for nodes and edges, and optional fields for mode and focus with default values.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing the nodes in the diagram."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing the edges connecting nodes in the diagram."
            },
            {
              "name": "mode",
              "type": "AnalysisMode",
              "description": "An optional enumeration specifying the analysis mode for diagram generation, defaulting to STANDARD."
            },
            {
              "name": "focus",
              "type": "DiagramFocus",
              "description": "An optional enumeration specifying the focus area for diagram generation, defaulting to ARCHITECTURE."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed for this class.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.GraphInput": {
      "identifier": "schemas.types.GraphInput",
      "description": {
        "overall": "The GraphInput class represents a serializable form of a call graph, designed to encapsulate the structural elements of a graph including nodes, edges, graph type, and associated metadata. It inherits from pydantic.BaseModel, which provides automatic serialization, deserialization, and validation capabilities. This class serves as a standardized data structure for representing graph-based information in a way that is both human-readable and machine-processable.",
        "init_method": {
          "description": "Initializes a GraphInput instance with required fields for nodes, edges, and graph type, along with optional metadata. The metadata field defaults to an empty dictionary if not provided.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing the nodes in the graph."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing the edges connecting nodes in the graph."
            },
            {
              "name": "graph_type",
              "type": "str",
              "description": "A string indicating the type of graph being represented."
            },
            {
              "name": "metadata",
              "type": "dict",
              "description": "An optional dictionary containing additional metadata about the graph. Defaults to an empty dictionary."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any other classes or modules beyond those imported at the top level.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.DiagramOutput": {
      "identifier": "schemas.types.DiagramOutput",
      "description": {
        "overall": "The DiagramOutput class is a Pydantic BaseModel designed to represent the output schema for generated diagram information. It encapsulates three key pieces of data: the type of diagram, the Mermaid code representing the diagram, and an explanation of the diagram's content. This class serves as a structured data container for diagram-related outputs, ensuring consistent formatting and validation of diagram metadata.",
        "init_method": {
          "description": "The class is initialized with three required fields: diagramtype, mermaid_code, and explanation. These fields define the core attributes of a diagram output, including its type, the Mermaid code representation, and a textual explanation.",
          "parameters": [
            {
              "name": "diagramtype",
              "type": "DiagramType",
              "description": "The type of diagram being represented."
            },
            {
              "name": "mermaid_code",
              "type": "str",
              "description": "The Mermaid code that defines the diagram."
            },
            {
              "name": "explanation",
              "type": "str",
              "description": "A textual explanation of the diagram's content."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were explicitly listed in the context.",
          "instantiated_by": "No instantiation locations were explicitly listed in the context."
        }
      },
      "error": null
    }
  }
}