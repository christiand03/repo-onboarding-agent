{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "This function converts a file path into a Python module path. It takes a file path and a project root directory as input, and returns the corresponding module path. The function uses the `os` module for path manipulation.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The file path to be converted."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The converted module path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies within a repository. It takes a filename, an Abstract Syntax Tree (AST), and the repository root as inputs. The function utilizes a tree visitor to traverse the AST, identifying import dependencies and adding them to the graph. The graph is then returned as a networkx DiGraph object.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which the dependency graph is being constructed."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The Abstract Syntax Tree of the file being analyzed."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.FileDependencyGraph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies within a Git repository. It iterates over all Python files (and files containing 'backend' in their path) in the repository, builds a dependency graph for each file using the `build_file_dependency_graph` function, and merges these into a global graph. The function returns this global graph as a networkx DiGraph object.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository for which to build the dependency graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the dependencies within the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.build_file_dependency_graph.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves a list of all Python files within a specified directory and its subdirectories. It uses the `pathlib` module to handle file paths. The function takes a directory path as input, resolves it to an absolute path, and then uses the `rglob` method to find all files with the `.py` extension. The results are returned as a list of relative paths.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of relative paths to all Python files found in the directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "This function serves as a main orchestrator for testing the LLMHelper class. It defines pre-computed analyses for several methods, including 'add_item', 'check_stock', and 'generate_report'. These analyses are then used to generate documentation for the InventoryManager class.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "LLMHelper, ClassAnalysisInput, ClassContextInput",
          "called_by": ""
        }
      },
      "error": null
    },
    "backend.callgraph.build_callGraph": {
      "identifier": "backend.callgraph.build_callGraph",
      "description": {
        "overall": "This function constructs a directed call graph from an Abstract Syntax Tree (AST) of a given file. It utilizes a visitor pattern to traverse the AST, collecting function calls and their relationships. The function then processes these relationships to build a graph representing the call structure within the file's own functions.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The Abstract Syntax Tree of the file to analyze."
          },
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the call relationships between functions in the file."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.callgraph.CallGraph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "This function generates a DOT file from a directed graph, ensuring node names are safe for use in the DOT language. It creates a mapping of original node names to safe names, relabels the graph nodes, and then writes the graph to a file in DOT format.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input directed graph to be converted."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT file will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "This function constructs a filtered call graph from a given Git repository, focusing only on functions written by the user. It iterates through all Python files in the repository, parses their abstract syntax trees (ASTs), and identifies function definitions and calls. The function then builds a directed graph (DiGraph) using NetworkX, adding edges and nodes for functions that are part of the user's codebase.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "The Git repository object from which to construct the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the filtered call graph of user-written functions."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.callgraph.CallGraph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "This function takes a content string as input and wraps it in CDATA (Character Data) tags, which are used in XML to escape a block of text so that it is treated as character data, not as XML markup.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content string to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The `extract_output_content` function processes a list of output objects and extracts text or image data. It handles different output types, including display data, execution results, streams, and errors. For images, it decodes Base64 data and appends it to an image list. The function returns a list of extracted text strings or placeholders for images.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of output objects to be processed."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list to store image data."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of extracted text strings or placeholders for images."
          }
        ],
        "usage_context": {
          "calls": "This function calls the `process_image` helper function, and also references `backend.converter.process_image` though it appears not directly called within the provided source code.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The `process_image` function processes a given image MIME type by retrieving its base64 encoded string from a data storage, adding it to an image list, and returning an XML placeholder for the image. If the MIME type is not found in the data or an error occurs during processing, it returns an error message or `None`.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "xml_placeholder",
            "type": "str",
            "description": "An XML placeholder for the image if successful, or an error message if not."
          },
          {
            "name": "None",
            "type": "None",
            "description": "If the MIME type is not found in the data."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "This function converts a notebook file content to XML format. It reads the notebook using nbformat, processes each cell based on its type (markdown or code), and constructs XML parts accordingly. The function handles errors during JSON/Notebook parsing and returns the XML content along with any extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the notebook file to be converted."
          }
        ],
        "returns": [
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML representation of the notebook content."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of images extracted during the conversion process."
          }
        ],
        "usage_context": {
          "calls": "This function calls extract_output_content and wrap_cdata.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files, identifies Jupyter notebook files (.ipynb), converts their content to XML, and returns a dictionary with the conversion results. It logs information about the number of notebooks found and the processing of each notebook. The function utilizes an external converter function to perform the notebook-to-XML conversion.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of files in the repository, where each file is expected to have a 'path' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary where keys are the paths of the processed notebooks and values are dictionaries containing the XML output and a list of images."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.mermaid_id": {
      "identifier": "backend.diagram_generation.emitter.mermaid_id",
      "description": {
        "overall": "The function `mermaid_id` takes a string input `name` and returns a modified string where all periods (`.`) are replaced with underscores (`_`). This is done to ensure that the output string is a valid Mermaid identifier, as Mermaid identifiers do not allow periods in their names.",
        "parameters": [
          {
            "name": "name",
            "type": "str",
            "description": "The input string to be converted into a valid Mermaid identifier."
          }
        ],
        "returns": [
          {
            "name": "mermaid_id",
            "type": "str",
            "description": "The input string with all periods replaced by underscores."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.analyze_project": {
      "identifier": "backend.diagram_generation.generator.analyze_project",
      "description": {
        "overall": "The `analyze_project` function generates an index of a project's structure and resolves function calls across the project's Python files. It iterates through a list of repository files, parsing Python files to construct an abstract syntax tree (AST) for each. It collects symbols and function calls from these trees, then resolves these calls to produce a comprehensive project index and a mapping of resolved calls.",
        "parameters": [
          {
            "name": "all_files",
            "type": "list[RepoFile]",
            "description": "A list of repository files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index of the project's structure."
          },
          {
            "name": "resolved_calls",
            "type": "dict[str, list[ResolvedCall]]",
            "description": "A mapping of resolved function calls across the project."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.main_diagram_generation": {
      "identifier": "backend.diagram_generation.generator.main_diagram_generation",
      "description": {
        "overall": "This function generates a main diagram for a given list of Python files. It analyzes the project, resolves function calls, and generates Mermaid sequence diagrams for each function. The function takes a list of Python files as input and returns a dictionary of sequence diagrams.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[str]",
            "description": "A list of Python files to analyze."
          }
        ],
        "returns": [
          {
            "name": "seqs",
            "type": "dict[str, str]",
            "description": "A dictionary of Mermaid sequence diagrams for each function."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.diagram_generation.generator.analyze_project.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.enrich_report_with_diagrams": {
      "identifier": "backend.diagram_generation.generator.enrich_report_with_diagrams",
      "description": {
        "overall": "This function enriches a given report by embedding diagrams from a provided dictionary. It iterates through each line of the report, checks for specific function references, and appends the corresponding diagram to the report. The enriched report is then returned as a string.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "The final report to be enriched with diagrams."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary containing diagrams with function names as keys."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "The report enriched with embedded diagrams."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.analyze_project": {
      "identifier": "backend.diagram_generation.main.analyze_project",
      "description": {
        "overall": "The `analyze_project` function analyzes a list of Python files (`py_files`) and constructs a project index along with resolved function calls across the project. It iterates over each file, parsing its abstract syntax tree (AST), collecting symbols, and then resolving calls between them. The function returns a `ProjectIndex` object and a dictionary of resolved calls.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[RepoFile]",
            "description": "A list of `RepoFile` objects representing the Python files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "A `ProjectIndex` object containing the collected project data."
          },
          {
            "name": "resolved_calls",
            "type": "dict",
            "description": "A dictionary of resolved function calls across the project."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.construct_overview_diagram": {
      "identifier": "backend.diagram_generation.main.construct_overview_diagram",
      "description": {
        "overall": "This function constructs an overview diagram for a given project by aggregating package information from its modules. It iterates over the project's modules, collects overlying packages, and returns a list of packages. The function's primary purpose is to gather and process package data for diagram generation.",
        "parameters": [
          {
            "name": "project",
            "type": "data_types.ProjectIndex",
            "description": "The project index object containing module information."
          }
        ],
        "returns": [
          {
            "name": "packages",
            "type": "list[list[str]]",
            "description": "A list of packages, where each package is a list of strings."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.main_diagram_generation": {
      "identifier": "backend.diagram_generation.main.main_diagram_generation",
      "description": {
        "overall": "This function generates a main diagram for a given Git repository. It retrieves all Python files from the repository, analyzes the project, and constructs sequence diagrams for function calls within the same function. The sequence diagrams are then written to a markdown file.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls analyze_project.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.attach_with_parents": {
      "identifier": "backend.diagram_generation.symbol_collector.attach_with_parents",
      "description": {
        "overall": "This function, `attach_with_parents`, is designed to traverse an Abstract Syntax Tree (AST) and establish parent-child relationships between nodes. It iterates over each node in the tree, and for each node, it sets the `parent` attribute of its child nodes to the current node. This process effectively builds a hierarchical structure by linking each child node to its parent within the AST. The function takes an AST as input and does not return any value. It appears to be part of a larger system for analyzing or processing the structure of source code.",
        "parameters": [
          {
            "name": "tree",
            "type": "AST",
            "description": "The Abstract Syntax Tree to be processed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "This function generates a bar chart comparing JSON and TOON tokens, highlighting the savings percentage, and saves it to a specified output path. It uses matplotlib for chart creation and customization. The chart displays the number of tokens for each type, with values annotated above the bars. The function takes four parameters: json_tokens, toon_tokens, savings_percent, and output_path.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage of savings."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function 'calculate_net_time' calculates the net time duration between a start and end time, subtracting sleep times incurred due to rate limits. It takes into account the total number of items processed, the batch size, and the model name. If the model name does not start with 'gemini-', it simply returns the total duration. For 'gemini-' models, it calculates the number of batches, the number of sleep periods, and then subtracts the total sleep time from the total duration.",
        "parameters": [
          {
            "name": "start_time",
            "type": "datetime",
            "description": "The start time of the operation."
          },
          {
            "name": "end_time",
            "type": "datetime",
            "description": "The end time of the operation."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items processed."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The batch size for processing items."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model used, which affects rate limiting."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "int",
            "description": "The net time duration after subtracting sleep times."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is the primary entry point for the analysis process. It takes in user input, API keys, and model names, and orchestrates the entire workflow, including repository cloning, file extraction, relationship analysis, and report generation.",
        "parameters": [
          {
            "name": "user_input",
            "type": "str",
            "description": "The user's input, which may contain a repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary of API keys for various services."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary of model names for the helper and main LLMs."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "An optional callback function to update the status."
          },
          {
            "name": "check_stop",
            "type": "function",
            "description": "An optional function to check if the workflow should be stopped."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated by the main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary of metrics, including processing times and token savings."
          }
        ],
        "usage_context": {
          "calls": "This function calls the following functions: backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.diagram_generation.generator.main_diagram_generation, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.enrich_report_with_diagrams, backend.main.get_key_and_url, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The `update_status` function updates the status by logging an input message and optionally calling a status callback function. It first checks if an interrupt signal has been received and raises an `InterruptedError` if so. The function appears to be part of a larger workflow management system, possibly in a Jupyter notebook environment.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be logged and optionally passed to the status callback."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.get_key_and_url": {
      "identifier": "backend.main.get_key_and_url",
      "description": {
        "overall": "The function get_key_and_url determines the correct API key and base URL for a given model name. It checks the model name against specific prefixes and returns the corresponding key and URL. If the model name does not match any specific prefix, it checks for user-provided Open Source keys and URLs, and falls back to system-defined ScadsLLM keys and URLs if not provided.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model for which to determine the API key and base URL."
          }
        ],
        "returns": [
          {
            "name": "api_key",
            "type": "str",
            "description": "The API key for the given model."
          },
          {
            "name": "base_url",
            "type": "str",
            "description": "The base URL for the given model."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.enrich_report_with_diagrams": {
      "identifier": "backend.main.enrich_report_with_diagrams",
      "description": {
        "overall": "This function enriches a final report by embedding diagrams from a provided dictionary. It iterates through each line of the report, checks for a specific marker ('#### Function:'), and inserts the corresponding diagram when a match is found. The enriched report is then returned as a string.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "The final report to be enriched with diagrams."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary containing diagrams to be inserted into the report."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "The report with embedded diagrams."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function is designed to analyze Jupyter notebooks from a specified GitHub repository. It takes input parameters such as the repository URL, API keys for various models, and a model name. The function clones the repository, extracts basic information, processes the notebooks, and then uses a specified LLM (Large Language Model) to generate reports for each notebook. It handles exceptions, logs messages, and returns a final report along with metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input string containing a GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary of API keys for different models (e.g., Gemini, OpenAI, ScadsLLM)."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the model to use for analysis (e.g., 'gpt-', 'gemini-', 'llama3')."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "An optional callback function to update the status."
          },
          {
            "name": "check_stop",
            "type": "function",
            "description": "An optional function to check if the workflow should be stopped."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated from analyzing the notebooks."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics about the workflow execution (e.g., total time, main model used)."
          }
        ],
        "usage_context": {
          "calls": "This function calls the following functions: backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The function `gemini_payload` constructs a payload for Gemini, a multimodal model, by combining context information, notebook XML structure, and image data. It takes in basic information, a file path, XML content, and a list of images. The function processes the XML to replace image placeholders with base64-encoded image data and returns a list of payload items, which can include both text and image URL components.",
        "parameters": [
          {
            "name": "info",
            "type": "object",
            "description": "Basic information about the context."
          },
          {
            "name": "path",
            "type": "string",
            "description": "The current notebook path."
          },
          {
            "name": "xml",
            "type": "string",
            "description": "The XML structure of the notebook."
          },
          {
            "name": "imgs",
            "type": "array",
            "description": "A list of image data."
          }
        ],
        "returns": [
          {
            "name": "payload",
            "type": "array",
            "description": "A list of payload items, which can include text and image URL components."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "This function converts a file path into a Python module path. It takes a file path and a project root directory as input, calculates the relative path, and then transforms it into a module path by replacing directory separators with dots. The function handles cases where the file path is not within the project root and also adjusts for Python file extensions and __init__.py files.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute file path to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The absolute path of the project root directory."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The module path corresponding to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "This function encrypts a given text using a cipher suite. If the input text is empty or the cipher suite is not available, it returns the original text. The function appears to be part of a database module and is designed to handle text encryption.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text if encryption is successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The `decrypt_text` function attempts to decrypt a given text using a cipher suite. If the text is empty or the cipher suite is not available, it returns the original text. The function is designed to handle exceptions during the decryption process, returning the original text if decryption fails.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text if successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The `insert_user` function creates a new user document in the database with the provided username, name, and password. The password is hashed using `stauth.Hasher.hash` before being stored. The function then inserts this user document into the database and returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password for the user, which will be hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the user document inserted into the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all users from a database collection named 'dbusers' and returns them as a list. It appears to be part of a larger database interaction system, likely using MongoDB given the 'dbusers.find()' method. The function does not take any parameters and does not include any error handling or data processing beyond the query itself.",
        "parameters": [],
        "returns": [
          {
            "name": "list_of_users",
            "type": "list",
            "description": "A list of user documents retrieved from the 'dbusers' collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "This function retrieves a user's data from the database based on their username. It uses the pymongo library to interact with the MongoDB database. The function takes a username as input and returns the corresponding user document from the database. If no user is found, it returns None. The function's logic is straightforward and does not involve any complex operations.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be fetched from the database."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict",
            "description": "The user document retrieved from the database, or None if no user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name of a user in the database. It takes a username and a new name as input, and modifies the 'name' field of the corresponding user document in the database. The function returns the number of documents modified by the operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The current username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates a user's Gemini API key in the database. It takes a username and a Gemini API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is being updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be stored for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "This function updates a user's GPT API key in the database. It takes a username and a GPT API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose GPT API key is being updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the 'ollama_base_url' field for a specified user in the database. It takes a username and a URL as input, strips any leading/trailing whitespace from the URL, and then updates the corresponding document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose 'ollama_base_url' is to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new 'ollama_base_url' to be set for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the Open Source API key for a given user in the database. It takes a username and an Open Source API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The new Open Source API key to be encrypted and stored in the database."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open-source base URL for a given user in the database. It takes a username and an open-source base URL as input, strips any leading/trailing whitespace from the URL, and then updates the corresponding document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose open-source base URL is to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open-source base URL to be set for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "This function retrieves a Gemini API key for a given username from a MongoDB database. It queries the 'dbusers' collection with the provided username and projects only the 'gemini_api_key' field. If a matching user is found, it returns the Gemini API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The Gemini API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "This function retrieves the 'ollama_base_url' for a given username from the database. It uses a MongoDB query to find the user document with the matching '_id' and projects only the 'ollama_base_url' field. If the user is found, it returns the 'ollama_base_url'; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier of the user."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The base URL for ollama associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "This function retrieves a GPT API key for a given username from a MongoDB database. It queries the 'dbusers' collection with the provided username and projects only the 'gpt_api_key' field. If a matching user is found, it returns the GPT API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The GPT API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the Open Source API key for a given username from the database. It queries the 'dbusers' collection with the provided username and projects the 'opensrc_api_key' field. If a matching user is found, it returns the API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The Open Source API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function retrieves the open-source base URL for a given username from the database. It queries the 'dbusers' collection for a document matching the provided username and returns the 'opensrc_base_url' field if found. If no matching document exists, it returns None. The function takes a username as input and returns the corresponding open-source URL or None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The open-source base URL associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "This function deletes a user from the database based on their username. It utilizes the pymongo library to interact with the MongoDB database. The function takes a username as input, uses it to identify the user document in the database, and then deletes that document. The function returns the number of documents deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted (1 if the user existed, 0 if not)."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys for a given username from a database. It searches for a user by their username, then decrypts and returns several API keys and URLs associated with that user. If the user is not found, it returns None for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to retrieve API keys."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The OLLAMA base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSRC base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "This function creates a new chat entry in the database. It generates a unique ID for the chat, records the username and chat name, and timestamps the creation. The function then inserts this new chat entry into the database and returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user creating the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted chat document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "This function retrieves all chats defined for a given user from the database. It uses the pymongo library to query the database and sorts the results by creation date in ascending order. The function takes a username as input and returns a list of chats associated with that user.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chats associated with the given username."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks if a chat with a given name exists for a specific username in the database. It uses a MongoDB collection to perform the query. The function takes two parameters, a username and a chat name, and returns a boolean value indicating whether the chat exists.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to check for chat existence."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "bool",
            "description": "True if the chat exists, False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and all associated exchanges in the database. It takes the username, old chat name, and new chat name as input, updates the chat entry, and then updates all messages (exchanges) accordingly. The function returns the number of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the chat owner."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name for the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "This function inserts a new exchange into the database with the provided details. It generates a unique ID for the exchange and attempts to insert it into the database. If successful, it returns the new ID; otherwise, it prints an error message and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "The feedback given."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main used, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "The total time, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "The helper time, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "The main time, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The JSON tokens, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The toon tokens, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The savings percent, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The ID of the newly inserted exchange, or None if insertion fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves a list of exchanges associated with a given username from a database, sorted by a timestamp field named 'created_at' in ascending order. The function takes a username as input and returns a list of exchanges. It appears to be part of a larger system using MongoDB for data storage. The purpose of this function is to fetch and return user-specific exchange data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch exchanges."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the given username, sorted by the 'created_at' timestamp."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a list of exchanges for a specific chat given a username and chat name. It queries a database collection named 'exchanges' with a filter on 'username' and 'chat_name', sorts the results by 'created_at' in ascending order, and returns the exchanges as a list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchanges by."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The chat name to filter exchanges by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges matching the filter criteria."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "This function updates the feedback for a specific exchange in the database. It takes an exchange ID and a feedback value as input, and returns the number of documents modified by the update operation. The function uses the PyMongo library to interact with the MongoDB database. It targets a specific document in the 'dbexchanges' collection based on the provided exchange ID and sets the 'feedback' field to the given value.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The new feedback value to be set."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates a feedback message for a specific exchange in the database. It takes an exchange ID and a feedback message as input, and returns the number of documents modified by the update operation. The function uses the PyMongo library to interact with the MongoDB database. It targets a specific document in the 'dbexchanges' collection based on the provided exchange ID and updates the 'feedback_message' field with the new message.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "objectId",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be stored."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes an exchange record from the database by its ID. It utilizes the `dbexchanges.delete_one` method from the PyMongo library to achieve this. The function takes an exchange ID as input, attempts to delete the corresponding record, and returns the number of documents deleted.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The unique identifier of the exchange record to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "This function deletes a full chat and all associated exchanges for a given username and chat name. It ensures consistency between the frontend and backend by removing all related data. The function first deletes all messages in the chat, then removes the chat itself from the chat list. It returns the number of chats deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the chat owner."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of chats deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The `clean_names` function takes a list of strings representing model names, splits each string by the '/' character, and returns a new list containing the last part of each split string. This effectively extracts the final part of a path or a filename from a list of paths or filenames. The function uses list comprehension to achieve this in a concise manner. It does not perform any error checking or handling on the input list or its elements.",
        "parameters": [
          {
            "name": "model_list",
            "type": "List[str]",
            "description": "A list of strings, where each string is expected to contain '/' characters."
          }
        ],
        "returns": [
          {
            "name": "cleaned_names",
            "type": "List[str]",
            "description": "A list of strings, where each string is the last part of the corresponding input string split by '/'."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "This function filters a given list of models based on a selected category. It checks if specific keywords are present in the model names and returns a filtered list accordingly. If no matches are found, it returns the original list.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The original list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered_list",
            "type": "list",
            "description": "The filtered list of models based on the category."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_abort": {
      "identifier": "frontend.frontend.handle_abort",
      "description": {
        "overall": "This function handles an abort request by setting a session state flag and displaying a toast notification.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function saves a Gemini key to the database. It retrieves the key from the session state, updates the database with the new key for the current user, and then clears the session state. If successful, it displays a toast notification.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function saves a new Ollama URL to the database. It retrieves the URL from the session state, updates the database with the new URL for the current user, and displays a toast notification upon success. The function appears to be part of a Streamlit application, utilizing session state and database interactions.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.get_last_activity": {
      "identifier": "frontend.frontend.get_last_activity",
      "description": {
        "overall": "The function `get_last_activity` retrieves the timestamp of the last message in a specified chat. It accesses the chat's exchanges from the session state, and if the chat or exchanges do not exist, it returns the minimum datetime value. The function handles the 'datetime' field of the last exchange, converting it to a datetime object if necessary.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat for which to retrieve the last activity timestamp."
          }
        ],
        "returns": [
          {
            "name": "last_activity",
            "type": "datetime",
            "description": "The timestamp of the last message in the chat, or `datetime.min` if the chat has no exchanges or the 'datetime' field is invalid."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "This function loads data from a database for a specified user. It initializes or updates the user's chat data in the session state, including chats and exchanges. If the user's data is not loaded, it fetches chats and exchanges from the database, organizes them, and updates the session state accordingly. It also handles the case where no chats exist for the user by creating an initial chat. The function ensures that the session state is updated with the user's data and that an active chat is set.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to load data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value associated with an exchange in the database and reruns the Streamlit application. It takes two parameters, updates the feedback in the database, and then triggers a rerun of the Streamlit application. The function appears to be part of a larger Streamlit application that handles user feedback.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing exchange information, including an '_id' field used for database operations."
          },
          {
            "name": "val",
            "type": "str",
            "description": "The new feedback value to be associated with the exchange."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "This function handles the deletion of an exchange from a chat session. It removes the exchange from the database and updates the chat session state accordingly. The function then triggers a rerun of the Streamlit application to reflect the changes.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session from which the exchange is being deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "The exchange to be deleted, containing an '_id' field for database reference."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The `handle_delete_chat` function handles the deletion of a chat for a given user. It calls the database function to delete the chat, cleans up the session state by removing the chat and updating the active chat if necessary. If all chats are deleted, it creates a new empty chat. Finally, it reruns the Streamlit app to update the UI.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who owns the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls `database.db.delete_full_chat` and `database.db.insert_chat`.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The `extract_repo_name` function takes a string input `text` and attempts to extract a repository name from it by searching for a URL pattern. If a URL is found, it parses the URL to extract the path, and from the path, it derives the repository name by taking the last part of the path, removing any trailing '.git' if present, and returns this name. If no URL or repository name can be extracted, the function returns `None`.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input string from which the repository name will be extracted."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name or `None` if extraction fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "This function generates a stream of text by splitting the input text into words and yielding each word followed by a space. It introduces a delay of 10 milliseconds between each word.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be streamed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "This function renders markdown text with mermaid code blocks using Streamlit. It splits the markdown text into parts, rendering non-mermaid parts as markdown and mermaid parts as interactive diagrams. If streaming is enabled, it streams the text; otherwise, it renders it directly.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The markdown text to be rendered, which may contain mermaid code blocks."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the text or render it directly. Defaults to False."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "This function renders an exchange in a chat interface. It displays a user's question and an assistant's answer in a structured format. The function handles error messages differently than regular answers and provides various interactive elements such as feedback buttons, a note-taking popover, and a download button.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the question, answer, and other metadata."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.get_provider": {
      "identifier": "frontend.frontend.get_provider",
      "description": {
        "overall": "The `get_provider` function takes a `model_name` as input and returns a string representing the provider name associated with that model. It uses a series of conditional checks to determine the provider based on the model name prefix or exact match. The function handles specific model names like 'gemini', 'llama3', and 'gpt-5', and defaults to 'Open Source LLM' for any other model name.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model for which to determine the provider."
          }
        ],
        "returns": [
          {
            "name": "provider",
            "type": "str",
            "description": "The provider name associated with the given model name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.config_provider": {
      "identifier": "frontend.frontend.config_provider",
      "description": {
        "overall": "The `config_provider` function is responsible for rendering configuration settings for different models (Gemini, Llama3, GPT-5, and Open Source LLM) in a Streamlit application. It displays the current status of each model's configuration, allows users to update the configurations, and saves the changes to the database. The function uses various Streamlit components, such as text inputs and form submit buttons, to interact with the user.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model for which the configuration is being rendered."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls the following database update functions: database.db.update_gemini_key, database.db.update_ollama_url, database.db.update_gpt_key, database.db.update_opensrc_key, and database.db.update_opensrc_url.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.check_stop_callback": {
      "identifier": "frontend.frontend.check_stop_callback",
      "description": {
        "overall": "This function checks if the user has requested to stop the current operation. It is called by the backend to determine if an abort request has been made. The function retrieves the status of the abort request from the session state and returns it. This allows the backend to respond accordingly based on the user's action.",
        "parameters": [],
        "returns": [
          {
            "name": "abort_requested",
            "type": "bool",
            "description": "A boolean indicating whether an abort has been requested by the user."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python source code and extract relevant information about its structure, including imports, functions, and classes.",
        "init_method": {
          "description": "The constructor of ASTVisitor initializes the object with source code, file path, and project root. It sets up the basic structure for the schema that will be populated during the AST traversal.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code to be analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method handles Import nodes in the AST. It extracts the names of imported modules and adds them to the schema's imports list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing the import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method handles ImportFrom nodes in the AST. It extracts the module name and the names of imported entities, then adds them to the schema's imports list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing the import from statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method handles ClassDef nodes in the AST. It extracts class information, including its identifier, name, docstring, and source code segment, and adds it to the schema's classes list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing the class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method handles FunctionDef nodes in the AST. It extracts function or method information, including its identifier, name, arguments, docstring, and source code segment, and adds it to either the schema's functions or the current class's methods list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing the function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method handles AsyncFunctionDef nodes in the AST by delegating to the visit_FunctionDef method, as the logic for handling asynchronous functions is similar to that of regular functions.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AST node representing the asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the path_to_module function from the backend.AST_Schema module.",
          "instantiated_by": "The class is instantiated by users of the AST analysis system, likely in the context of processing Python source code files."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is designed to analyze Abstract Syntax Tree (AST) schema data. It provides methods to merge relationship data into a full schema and to analyze a repository of files.",
        "init_method": {
          "description": "The constructor of the ASTAnalyzer class does not initialize any instance attributes.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method merges relationship data into a full schema. It updates the 'context' of each function and class in the schema with their respective calls and called_by relationships.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema to be updated."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "The raw relationship data to be merged."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated full schema."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method analyzes a repository of files and returns a schema of the AST nodes found in the files.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects to be analyzed."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "The Git repository containing the files."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The schema of the AST nodes found in the files."
                }
              ],
              "usage_context": {
                "calls": "This method calls the ASTVisitor class.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ASTAnalyzer class depends on the ASTVisitor class.",
          "instantiated_by": "The ASTAnalyzer class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve file dependencies in a repository. It utilizes the NodeVisitor pattern to traverse import statements and construct a dependency graph.",
        "init_method": {
          "description": "The constructor initializes the FileDependencyGraph with a filename and a repository root. It sets up the basic attributes for tracking dependencies.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file for which dependencies are being analyzed."
            },
            {
              "name": "repo_root",
              "type": "object",
              "description": "The root directory of the repository."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "This method resolves relative imports of the form `from .. import name1, name2`. It returns a list of actual module/symbol names that exist, throwing an ImportError if resolution fails.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import node to resolve."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls get_all_temp_files, init_exports_symbol, and module_file_exists to resolve module names.",
                "called_by": "This method is not explicitly called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method handles import statements, adding the imported module names to the import dependencies dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "The import node to process."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "The base name of the module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method handles import from statements, resolving the module name and adding it to the import dependencies.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import from node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls _resolve_module_name to resolve relative imports.",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "module_file_exists",
            "description": {
              "overall": "This method checks if a module file exists at a given relative base path.",
              "parameters": [
                {
                  "name": "rel_base",
                  "type": "Path",
                  "description": "The relative base path."
                },
                {
                  "name": "name",
                  "type": "str",
                  "description": "The name of the module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "init_exports_symbol",
            "description": {
              "overall": "This method checks if a symbol is exported in the __init__.py file of a module.",
              "parameters": [
                {
                  "name": "rel_base",
                  "type": "Path",
                  "description": "The relative base path."
                },
                {
                  "name": "symbol",
                  "type": "str",
                  "description": "The symbol to check."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on get_all_temp_files, init_exports_symbol, and module_file_exists for its operations.",
          "instantiated_by": "The class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class is designed to interact with Google Gemini for generating code snippet documentation. It centralizes API interaction, error handling, and validates I/O using Pydantic. The class provides methods to generate documentation for functions and classes in batches, handling rate limits and errors.",
        "init_method": {
          "description": "The constructor initializes the LLMHelper instance with an API key, paths to function and class prompts, and model settings. It sets up the base LLM model based on the model name and configures batch settings.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The Gemini API key."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "The path to the function system prompt file."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "The path to the class system prompt file."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use (default: 'gemini-2.0-flash-lite')."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the model (default: None)."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures batch settings based on the model name. It sets the batch size for the LLMHelper instance.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "The name of the model."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Generates and validates documentation for a batch of functions. It creates JSON payloads from function inputs, batches them, and calls the LLM API for documentation generation.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function inputs for documentation generation."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_functions",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analyses."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Generates and validates documentation for a batch of classes. It creates JSON payloads from class inputs, batches them, and calls the LLM API for documentation generation.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class inputs for documentation generation."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_classes",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analyses."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on various external models and APIs, including Google Gemini, langchain, and Pydantic.",
          "instantiated_by": "The class is instantiated by providing an API key, function and class prompt paths, and model settings."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the primary interface for interacting with a Large Language Model (LLM). It initializes the LLM based on the provided model name and API key, and offers methods for calling the LLM with a user's input, either in a blocking or streaming manner.",
        "init_method": {
          "description": "The constructor of the MainLLM class initializes the LLM with the given API key, prompt file path, model name, and base URL. It validates the API key, reads the system prompt from the specified file, and sets up the LLM instance based on the model name, which can be a Google Gemini model, an OpenAI GPT model, or a custom model.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for accessing the LLM."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the LLM model to use. Defaults to 'gemini-2.5-pro'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the LLM API. Defaults to None."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "The call_llm method sends a request to the LLM with the user's input and returns the response. It constructs a message with the system prompt and the user's input, calls the LLM, and logs the outcome.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input provided by the user."
                }
              ],
              "returns": [
                {
                  "name": "response",
                  "type": "str",
                  "description": "The content of the LLM's response."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "The stream_llm method streams the response from the LLM with the user's input. It constructs a message with the system prompt and the user's input, streams the LLM's response, and yields the content of each chunk.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input provided by the user."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the following external dependencies: langchain_google_genai, langchain_ollama, langchain_openai, langchain_core.",
          "instantiated_by": "The class is instantiated by unknown components."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README, pyproject.toml, and requirements.txt. It initializes a structured information object and populates it by parsing the contents of these files.",
        "init_method": {
          "description": "The constructor initializes the class with a predefined structure for project information, including placeholders for project overview and installation details.",
          "parameters": [
            {
              "name": "self",
              "type": "reference",
              "description": "Reference to the instance of the class."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from a given content string, which can occur due to encoding errors when reading files.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The content to be cleaned."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches case-insensitively for a file that matches one of the given patterns within a list of files.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file patterns to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to search within."
                }
              ],
              "returns": [
                {
                  "name": "file",
                  "type": "Optional[Any]",
                  "description": "The first matching file or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text under a Markdown heading (##) based on given keywords.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The Markdown content to search in."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "Keywords to identify the section."
                }
              ],
              "returns": [
                {
                  "name": "section_text",
                  "type": "Optional[str]",
                  "description": "The extracted section text or None if not found."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file and extracts relevant project information.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file and extracts project information.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file and extracts dependencies.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the extraction of project information from various files.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to extract information from."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository."
                }
              ],
              "returns": [
                {
                  "name": "project_info",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the 'tomli' library for parsing pyproject.toml files.",
          "instantiated_by": "The class can be instantiated by any part of the system that needs to extract project information."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze the call structure of a given Python file. It utilizes the abstract syntax tree (AST) to traverse and understand the code's structure, identifying function definitions, calls, imports, and class definitions.",
        "init_method": {
          "description": "The constructor of the CallGraph class initializes the object with a given filename. It sets up several instance variables to keep track of the current function, class, local definitions, a graph of function calls, import mappings, a set of functions, and edges in the call graph.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "This method recursively processes a node in the AST to extract a list of name components as a dotted string, representing a call's callee.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call | ast.Name | ast.Attribute",
                  "description": "The node in the AST to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "This method resolves a list of callee nodes into their full names based on local definitions and import mappings.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists of name components."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved callee names."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "This method constructs a full name for a given basename and optional class name, prefixing them with the filename.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name."
                },
                {
                  "name": "class_name",
                  "type": "str | None",
                  "description": "The class name."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The full name."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "This method returns the current caller's name, either the current function or a representation of the global scope.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The current caller's name."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method handles Import nodes in the AST, updating the import mapping.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method handles ImportFrom nodes in the AST, updating the import mapping.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method handles ClassDef nodes in the AST, temporarily updating the current class.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method handles FunctionDef nodes in the AST, adding the function to the graph and updating local definitions.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method handles AsyncFunctionDef nodes in the AST by delegating to visit_FunctionDef.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method handles Call nodes in the AST, adding edges to the call graph.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The Call node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "This method handles If nodes in the AST, specially handling __name__ == '__main__' blocks.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The If node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the 'ast' and 'networkx' modules for its operation.",
          "instantiated_by": "The class is instantiated with a filename to analyze the call graph of that file."
        }
      },
      "error": null
    },
    "backend.diagram_generation.call_resolver.CallResolver": {
      "identifier": "backend.diagram_generation.call_resolver.CallResolver",
      "description": {
        "overall": "The CallResolver class is designed to resolve function calls within a project by analyzing the call structure and determining the callee functions. It takes a project index as input during initialization and provides methods to resolve calls and their types.",
        "init_method": {
          "description": "The class is initialized with a project index, which is stored as an instance attribute. This project index is crucial for resolving function calls within the project.",
          "parameters": [
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "The project index used for resolving function calls."
            }
          ]
        },
        "methods": [
          {
            "identifier": "resolve_all",
            "description": {
              "overall": "This method takes a dictionary of calls and resolves each call to determine the callee functions. It iterates over each call, resolves it using the 'resolved' method, and returns a dictionary of resolved calls.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "dict[str, list[RawCall]]",
                  "description": "A dictionary of calls to be resolved."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "dict[str, list[ResolvedCall]]",
                  "description": "A dictionary of resolved calls."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "resolved",
            "description": {
              "overall": "This method takes a raw call and resolves it to determine the callee function. It checks the type of the call's function node and delegates the resolution to '_resolve_name' or '_resolve_attribute' accordingly.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call to be resolved."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved calls."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_name",
            "description": {
              "overall": "This method resolves a call when the function node is a name. It checks if the name corresponds to a function or import in the project and returns the resolved call.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call to be resolved."
                },
                {
                  "name": "node",
                  "type": "ast.Name",
                  "description": "The name node of the call."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved calls."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_attribute",
            "description": {
              "overall": "This method resolves a call when the function node is an attribute. It checks if the attribute corresponds to a method or function in the project and returns the resolved call.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call to be resolved."
                },
                {
                  "name": "node",
                  "type": "ast.Attribute",
                  "description": "The attribute node of the call."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved calls."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.diagram_generation.callgraph.TreeVisitor": {
      "identifier": "backend.diagram_generation.callgraph.TreeVisitor",
      "description": {
        "overall": "The TreeVisitor class is designed to traverse an Abstract Syntax Tree (AST) of a module, collecting information about function calls and their contexts. It initializes with a module and a project index, and uses visitor methods to analyze class and function definitions, as well as function calls.",
        "init_method": {
          "description": "The constructor initializes the TreeVisitor with a module symbol and a project index. It sets up instance variables to track the current function and class being visited, as well as a list to store raw call information.",
          "parameters": [
            {
              "name": "module",
              "type": "ModuleSymbol",
              "description": "The module symbol being analyzed."
            },
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "The project index providing context for the analysis."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method visits a class definition node in the AST. It updates the current class context, performs a generic visit of the node, and then restores the previous class context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The class definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method visits a function definition node in the AST. It updates the current function context based on whether it's a class method or a standalone function, performs a generic visit, and then restores the previous function context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The function definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method visits a function call node in the AST. It checks if the call is within a function context and if the called function is known. If so, it records the call with its context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "",
                  "description": "The call node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.FunctionSymbol": {
      "identifier": "backend.diagram_generation.data_types.FunctionSymbol",
      "description": {
        "overall": "The FunctionSymbol class represents a symbol for a function, capturing its name, module, qualified name, and other relevant details such as whether it's asynchronous, its input parameters, return type, and line number.",
        "init_method": {
          "description": "The class is initialized with parameters that define a function symbol, including its name, module, qualified name, asynchronicity, input parameters, return type, and line number.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the function."
            },
            {
              "name": "module",
              "type": "str",
              "description": "The module where the function is defined."
            },
            {
              "name": "qualname",
              "type": "str",
              "description": "The qualified name of the function."
            },
            {
              "name": "asynchron",
              "type": "bool",
              "description": "Whether the function is asynchronous."
            },
            {
              "name": "input_params",
              "type": "list[str]",
              "description": "A list of input parameter names."
            },
            {
              "name": "return_symb",
              "type": "bool",
              "description": "Indicates if the function returns a symbol."
            },
            {
              "name": "lineno",
              "type": "int",
              "description": "The line number where the function is defined."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any known components."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ClassSymbol": {
      "identifier": "backend.diagram_generation.data_types.ClassSymbol",
      "description": {
        "overall": "The ClassSymbol class represents a class symbol in a diagram generation context. It has attributes for the class name, module, and methods. The class seems to be a data type used for storing information about classes in a structured way.",
        "init_method": {
          "description": "The class does not have an explicitly defined constructor (__init__ method). Therefore, it relies on the default constructor or attributes are set directly on the class instance.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": "The provided source code does not contain a complete class definition, specifically the __init__ method or other methods, making a detailed analysis challenging."
    },
    "backend.diagram_generation.data_types.ModuleSymbol": {
      "identifier": "backend.diagram_generation.data_types.ModuleSymbol",
      "description": {
        "overall": "The ModuleSymbol class represents a module in a diagram generation context. It encapsulates key information about the module, including its name, overlying packages, and collections of functions, classes, and imports.",
        "init_method": {
          "description": "The class is initialized with parameters that set up its core attributes. These include the module's name, overlying packages, and dictionaries for functions, classes, and imports.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the module."
            },
            {
              "name": "overlying_packages",
              "type": "list[str]",
              "description": "A list of overlying packages for the module."
            },
            {
              "name": "functions",
              "type": "dict[str, FunctionSymbol]",
              "description": "A dictionary of functions in the module, keyed by function name."
            },
            {
              "name": "classes",
              "type": "dict[str, ClassSymbol]",
              "description": "A dictionary of classes in the module, keyed by class name."
            },
            {
              "name": "imports",
              "type": "dict[str, str]",
              "description": "A dictionary of imports in the module, keyed by import name."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any known components."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallContext": {
      "identifier": "backend.diagram_generation.data_types.CallContext",
      "description": {
        "overall": "The CallContext class represents the context in which a function or method is called, encapsulating information about the module, function, and optionally, classes involved in the call.",
        "init_method": {
          "description": "The class is initialized with a module, a function, and optionally, classes.",
          "parameters": [
            {
              "name": "module",
              "type": "ModuleSymbol",
              "description": "The module in which the function is called."
            },
            {
              "name": "function",
              "type": "FunctionSymbol",
              "description": "The function being called."
            },
            {
              "name": "classes",
              "type": "Optional[ClassSymbol]",
              "description": "Optional classes involved in the function call."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.RawCall": {
      "identifier": "backend.diagram_generation.data_types.RawCall",
      "description": {
        "overall": "The RawCall class represents a raw function call with its associated metadata.",
        "init_method": {
          "description": "The class is initialized with a function symbol, an expression node, a line number, and a call context.",
          "parameters": [
            {
              "name": "caller",
              "type": "FunctionSymbol",
              "description": "The function symbol of the caller."
            },
            {
              "name": "func_node",
              "type": "expr",
              "description": "The expression node of the function."
            },
            {
              "name": "lineno",
              "type": "int",
              "description": "The line number of the function call."
            },
            {
              "name": "context",
              "type": "CallContext",
              "description": "The context of the function call."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallType": {
      "identifier": "backend.diagram_generation.data_types.CallType",
      "description": {
        "overall": "The CallType class is an enumeration that categorizes different types of calls in a system. It provides a set of predefined call types, including direct, method, imported, dynamic, and unknown.",
        "init_method": {
          "description": "The class does not have an __init__ method as it is an enumeration. The enumeration values are defined directly within the class.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ResolvedCall": {
      "identifier": "backend.diagram_generation.data_types.ResolvedCall",
      "description": {
        "overall": "The ResolvedCall class represents a resolved function call with its caller, callee, call type, and line number.",
        "init_method": {
          "description": "The class is initialized with a caller, callee, call type, and line number.",
          "parameters": [
            {
              "name": "caller",
              "type": "FunctionSymbol",
              "description": "The caller function symbol."
            },
            {
              "name": "callee",
              "type": "Optional[FunctionSymbol]",
              "description": "The callee function symbol, which is optional."
            },
            {
              "name": "call_type",
              "type": "CallType",
              "description": "The type of the call."
            },
            {
              "name": "lineno",
              "type": "int",
              "description": "The line number of the call."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any known components."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ProjectIndex": {
      "identifier": "backend.diagram_generation.data_types.ProjectIndex",
      "description": {
        "overall": "The ProjectIndex class serves as a container for managing modules and their respective classes. It provides a method to retrieve all classes across all modules.",
        "init_method": {
          "description": "The class is initialized with a 'modules' attribute, which is a dictionary of ModuleSymbol objects indexed by string.",
          "parameters": [
            {
              "name": "self",
              "type": "ProjectIndex",
              "description": "Reference to the instance of the class."
            },
            {
              "name": "modules",
              "type": "dict[str, ModuleSymbol]",
              "description": "A dictionary of ModuleSymbol objects."
            }
          ]
        },
        "methods": [
          {
            "identifier": "all_classes",
            "description": {
              "overall": "The all_classes method retrieves and returns a list of all ClassSymbol objects across all modules in the ProjectIndex.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectIndex",
                  "description": "Reference to the instance of the class."
                }
              ],
              "returns": [
                {
                  "name": "list[ClassSymbol]",
                  "type": "list[ClassSymbol]",
                  "description": "A list of ClassSymbol objects."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods or functions.",
                "called_by": "This method is not called by any other methods or functions."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other classes or functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidSequenceEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidSequenceEmitter",
      "description": {
        "overall": "The MermaidSequenceEmitter class is designed to generate Mermaid sequence diagrams from a list of resolved calls. It provides methods to collect participants, emit calls, and emit responses, ultimately returning a string representing the Mermaid sequence diagram.",
        "init_method": {
          "description": "The class does not have an explicitly defined constructor (__init__). Therefore, it relies on the default constructor provided by Python, which does not initialize any instance attributes.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a Mermaid sequence diagram from a list of resolved calls. It initializes the diagram with a mermaid code block, adds participants, and then appends call and response lines.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects representing the calls to be included in the sequence diagram."
                }
              ],
              "returns": [
                {
                  "name": "diagram",
                  "type": "str",
                  "description": "A string representing the Mermaid sequence diagram."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods internally.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_participants",
            "description": {
              "overall": "The _collect_participants method collects unique participants from a list of resolved calls. It iterates over each call, adding the caller and callee (if applicable) to the list of participants.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects from which to collect participants."
                }
              ],
              "returns": [
                {
                  "name": "participants",
                  "type": "list[str]",
                  "description": "A list of participant names for the sequence diagram."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id function from the backend.diagram_generation.emitter module.",
                "called_by": "This method is called by the emit method."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_response",
            "description": {
              "overall": "The _emit_response method generates a Mermaid response line for a given resolved call. It formats the response line with the callee and caller participant names.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A ResolvedCall object representing the call for which to emit a response."
                }
              ],
              "returns": [
                {
                  "name": "response_line",
                  "type": "str",
                  "description": "A string representing the Mermaid response line."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id function from the backend.diagram_generation.emitter module.",
                "called_by": "This method is called by the emit method."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_call",
            "description": {
              "overall": "The _emit_call method generates a Mermaid call line for a given resolved call. It formats the call line with the caller, callee, and label.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A ResolvedCall object representing the call for which to emit a call line."
                }
              ],
              "returns": [
                {
                  "name": "call_line",
                  "type": "str",
                  "description": "A string representing the Mermaid call line."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id function from the backend.diagram_generation.emitter module.",
                "called_by": "This method is called by the emit method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on external functions and types, including mermaid_id from backend.diagram_generation.emitter, and ResolvedCall from diagram_generation.data_types.",
          "instantiated_by": "The class is not instantiated by any methods in the provided context."
        }
      },
      "error": null
    },
    "MermaidOverviewArchitectureEmitter": {
      "identifier": "MermaidOverviewArchitectureEmitter",
      "description": {
        "overall": "The MermaidOverviewArchitectureEmitter class is designed to generate Mermaid syntax for visualizing the architecture of modules and their imports. It takes a dictionary of ModuleSymbol objects and produces a string representing a graph that illustrates the dependencies between these modules.",
        "init_method": {
          "description": "The class does not have an explicitly defined constructor (__init__ method). Therefore, it relies on the default constructor provided by Python, which does not initialize any instance attributes.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates Mermaid syntax for visualizing the architecture of modules and their imports. It iterates over a dictionary of ModuleSymbol objects, constructs a graph that represents the dependencies between these modules, and returns this graph as a string.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary of ModuleSymbol objects where each key is a module name and each value represents a module's symbol."
                }
              ],
              "returns": [
                {
                  "name": "mermaid_syntax",
                  "type": "str",
                  "description": "A string representing the Mermaid syntax for the graph of module dependencies."
                }
              ],
              "usage_context": {
                "calls": "The emit method does not call any other methods or functions internally.",
                "called_by": "The emit method is not called by any other methods or functions within the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class does not have any external dependencies listed in the provided context.",
          "instantiated_by": "The class is not instantiated by any other methods or functions within the provided context."
        }
      },
      "error": null
    },
    "MermaidClassDiagramEmitter": {
      "identifier": "MermaidClassDiagramEmitter",
      "description": {
        "overall": "The MermaidClassDiagramEmitter class is designed to generate Mermaid syntax for representing class diagrams from a given set of modules and their symbols. It iterates through the modules, classes, and methods to construct a detailed class diagram. The class primarily focuses on emitting Mermaid syntax for class structures and import relationships.",
        "init_method": {
          "description": "The class does not have an explicitly defined constructor (__init__). Therefore, it relies on the default constructor provided by Python, which does not initialize any specific attributes.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates Mermaid syntax for a class diagram based on the provided modules. It iterates through each module, its classes, and methods to construct the diagram. The method also handles import relationships between modules.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary of modules where each module contains symbols (classes and their methods)."
                }
              ],
              "returns": [
                {
                  "name": "diagram",
                  "type": "str",
                  "description": "The Mermaid syntax representing the class diagram."
                }
              ],
              "usage_context": {
                "calls": "The emit method calls the mermaid_id function to generate unique identifiers for classes and modules.",
                "called_by": "There are no specified callers for the emit method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the mermaid_id function for generating Mermaid-compatible identifiers for classes and modules.",
          "instantiated_by": "There are no specified locations where this class is instantiated in the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.SymbolCollector": {
      "identifier": "backend.diagram_generation.symbol_collector.SymbolCollector",
      "description": {
        "overall": "The SymbolCollector class is designed to collect and organize symbols from a given module, including functions, classes, and imports. It utilizes the NodeVisitor pattern to traverse the abstract syntax tree (AST) of the module and extract relevant information. The collected symbols are stored in a ModuleSymbol object, which contains details about the module's functions, classes, and imports.",
        "init_method": {
          "description": "The constructor initializes the SymbolCollector with a module name and a list of packages. It sets up a ModuleSymbol object with the given module name, overlying packages, and empty dictionaries for functions, classes, and imports.",
          "parameters": [
            {
              "name": "module_name",
              "type": "str",
              "description": "The name of the module being analyzed."
            },
            {
              "name": "packages",
              "type": "list[str]",
              "description": "A list of packages related to the module."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_has_return",
            "description": {
              "overall": "This method checks if a given FunctionDef node in the AST has a return statement. It iterates through the node's body and checks for Return statements.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The FunctionDef node to check for return statements."
                }
              ],
              "returns": [
                {
                  "name": "has_return",
                  "type": "bool",
                  "description": "True if the function has a return statement, False otherwise."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by visit_ClassDef, visit_AsyncFunctionDef, and visit_FunctionDef methods."
              }
            },
            "error": null
          },
          {
            "identifier": "_declare_input_parameters",
            "description": {
              "overall": "This method extracts the input parameters from a FunctionDef node in the AST. It iterates through the node's arguments and collects the parameter names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The FunctionDef node to extract input parameters from."
                }
              ],
              "returns": [
                {
                  "name": "input_parameters",
                  "type": "list[str]",
                  "description": "A list of input parameter names."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by visit_ClassDef, visit_AsyncFunctionDef, and visit_FunctionDef methods."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method handles Import nodes in the AST. It extracts the imported names and aliases, and adds them to the module's imports dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import",
                  "description": "The Import node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method.",
                "called_by": "This method is called when an Import node is encountered in the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method handles ImportFrom nodes in the AST. It extracts the imported names and aliases, and adds them to the module's imports dictionary. It also handles relative imports.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The ImportFrom node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method.",
                "called_by": "This method is called when an ImportFrom node is encountered in the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method handles ClassDef nodes in the AST. It extracts the class name, methods, and adds the class to the module's classes dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The ClassDef node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _has_return and _declare_input_parameters methods.",
                "called_by": "This method is called when a ClassDef node is encountered in the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method handles AsyncFunctionDef nodes in the AST. It extracts the function name, parameters, and return information, and adds the function to the module's functions dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _has_return and _declare_input_parameters methods.",
                "called_by": "This method is called when an AsyncFunctionDef node is encountered in the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method handles FunctionDef nodes in the AST. It simply calls the visit_AsyncFunctionDef method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The FunctionDef node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the visit_AsyncFunctionDef method.",
                "called_by": "This method is called when a FunctionDef node is encountered in the AST."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on various modules including ast, diagram_generation.data_types, and diagram_generation.callgraph.",
          "instantiated_by": "The class is instantiated by other parts of the diagram generation system."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents an individual file within a Git repository. It provides lazy loading of the file content, allowing for efficient handling of large files. The class offers various methods for accessing file properties, such as its path, size, and content.",
        "init_method": {
          "description": "The constructor initializes a RepoFile object with a given file path and commit tree. It sets up the object's state by storing the file path and commit tree, and initializes internal variables for lazy loading of the file's blob, content, and size.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The Tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "This property lazy-loads the Git blob object associated with the file. If the blob is not already loaded, it attempts to retrieve it from the commit tree. If the file is not found, it raises a FileNotFoundError.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "This property lazy-loads and returns the decoded content of the file. If the content is not already loaded, it reads the content from the blob's data stream and decodes it using UTF-8.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "This property lazy-loads and returns the size of the file in bytes. If the size is not already loaded, it retrieves it from the blob's size attribute.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "This method analyzes the file content and returns the word count. It splits the content into words using whitespace as a delimiter and returns the number of words.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The number of words in the file content."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "This method converts the RepoFile object to a dictionary representation. It includes the file's path, name, size, and type. Optionally, it can include the file content if the include_content parameter is set to True.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "A flag indicating whether to include the file content in the dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the git module for interacting with Git repositories.",
          "instantiated_by": "This class is instantiated by code that needs to represent and interact with individual files within a Git repository."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository, including cloning it into a temporary directory and providing RepoFile objects. It allows for retrieving all files in the repository and provides a file tree structure.",
        "init_method": {
          "description": "The constructor initializes a GitRepository object by cloning a Git repository into a temporary directory. It sets up the repository object, latest commit, and commit tree. If cloning fails, it raises a RuntimeError.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "This method returns a list of all files in the repository as RepoFile objects. It retrieves file paths from the Git repository and creates RepoFile instances for each path.",
              "parameters": [],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing all files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile class to create RepoFile objects.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "This method deletes the temporary directory and its contents.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": "This method is called by the __exit__ method and can be called directly to clean up resources."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "This method returns the GitRepository object itself, allowing it to be used as a context manager.",
              "parameters": [],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The GitRepository object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": "This method is used implicitly when the GitRepository object is used as a context manager."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "This method is called when exiting a context managed by the GitRepository object. It calls the close method to clean up resources.",
              "parameters": [
                {
                  "name": "exc_type",
                  "type": "Exception Type",
                  "description": "The type of exception, or None if no exception occurred."
                },
                {
                  "name": "exc_val",
                  "type": "Exception Value",
                  "description": "The value of the exception, or None if no exception occurred."
                },
                {
                  "name": "exc_tb",
                  "type": "Exception Traceback",
                  "description": "The traceback of the exception, or None if no exception occurred."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the close method to clean up resources.",
                "called_by": "This method is called automatically when exiting a context managed by the GitRepository object."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "This method returns a tree structure representing the files in the repository. If include_content is True, it includes the content of the files in the tree structure.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include the content of the files in the tree structure."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the tree structure of the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the get_all_files method to retrieve the list of files in the repository.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The GitRepository class depends on the RepoFile class.",
          "instantiated_by": "The GitRepository class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze a project by traversing its directory structure, identifying Python files, and resolving function and method calls within those files. It constructs a call graph that represents the relationships between different parts of the project.",
        "init_method": {
          "description": "The constructor initializes the ProjectAnalyzer with a project root directory. It sets up instance attributes such as the project root path, an empty dictionary for definitions, a call graph, a dictionary for file abstract syntax trees (ASTs), and a set of directories to ignore during analysis.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "This method orchestrates the analysis of the project. It finds all Python files within the project directory, collects definitions of functions and classes, resolves calls between them, and returns the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "dict",
                  "description": "A dictionary representing the call graph of the project."
                }
              ],
              "usage_context": {
                "calls": "This method calls _find_py_files, _collect_definitions, and _resolve_calls to perform the analysis.",
                "called_by": "This method can be called by external components to analyze a project."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "This method processes the call graph to extract raw relationships between callers and callees. It returns a dictionary with outgoing and incoming relationships.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing outgoing and incoming call relationships."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": "This method can be used by other components to obtain the raw call relationships."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "This method traverses the project directory and its subdirectories to find all Python files. It filters out directories that are specified to be ignored.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list",
                  "description": "A list of paths to Python files in the project."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": "This method is called by the analyze method to find Python files."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "This method reads Python files, parses their ASTs, and collects definitions of functions, methods, and classes. It stores these definitions in the instance's definitions dictionary.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls path_to_module to convert a file path to a module path.",
                "called_by": "This method is called by the analyze method to collect definitions."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "This method traverses the AST of a Python file to find the parent node of a given node. It is used to determine if a function is a method of a class.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The AST of the Python file."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The node whose parent is to be found."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST",
                  "description": "The parent node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": "This method is called by _collect_definitions to find the parent of a node."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "This method uses the CallResolverVisitor to resolve calls within a Python file and updates the call graph with the resolved calls.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls CallResolverVisitor to resolve calls.",
                "called_by": "This method is called by the analyze method to resolve calls."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ProjectAnalyzer depends on CallResolverVisitor and path_to_module for its operations.",
          "instantiated_by": "The ProjectAnalyzer can be instantiated by components that need to analyze projects."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python code and resolve function calls, tracking the call relationships and context.",
        "init_method": {
          "description": "The constructor initializes the visitor with a filepath, project root, and definitions. It sets up the module path, scope, instance types, and other contextual information.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The file path of the code being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary of definitions used to resolve function calls."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Visits a class definition node in the AST, updating the current class name and performing a generic visit of the node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The class definition node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Visits a function definition node in the AST, updating the current caller name and performing a generic visit of the node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The function definition node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Visits a call node in the AST, resolving the callee pathname and updating the calls dictionary if the callee is defined.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The call node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Visits an import node in the AST, updating the scope with the imported names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The import node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Visits an import from node in the AST, updating the scope with the imported names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The import from node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Visits an assign node in the AST, updating the instance types if the assigned value is a class instantiation.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The assign node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the qualified name of a call node.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.Name or ast.Attribute",
                  "description": "The function node."
                }
              ],
              "returns": [
                {
                  "name": "qname",
                  "type": "str",
                  "description": "The qualified name of the function."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the path_to_module function from backend.relationship_analyzer.",
          "instantiated_by": "The class is not instantiated in the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.AnalysisMode": {
      "identifier": "schemas.enums.AnalysisMode",
      "description": {
        "overall": "The AnalysisMode class is an enumeration that defines different levels of analysis. It inherits from str and Enum, allowing it to be used as a string-based enum. The class provides four distinct analysis modes: OVERVIEW, STANDARD, DETAILED, and DEEP_DIVE.",
        "init_method": {
          "description": "The class does not have an explicit __init__ method. It is initialized as an Enum, with its members defined directly within the class body.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramFocus": {
      "identifier": "schemas.enums.DiagramFocus",
      "description": {
        "overall": "The DiagramFocus class is an enumeration that defines the focus of visualization in a diagram. It provides four possible focuses: architecture, data flow, dependencies, and call graph.",
        "init_method": {
          "description": "The class is initialized as an enumeration with four possible values.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramType": {
      "identifier": "schemas.enums.DiagramType",
      "description": {
        "overall": "The DiagramType class is an enumeration that represents different types of Mermaid diagrams. It provides a set of predefined values for various diagram types, including class diagrams, sequence diagrams, flowcharts, state diagrams, graphs, call graphs, and file dependency graphs.",
        "init_method": {
          "description": "The class does not have an explicit __init__ method as it is an enumeration. The enumeration values are defined directly within the class definition.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.enums.GraphType": {
      "identifier": "schemas.enums.GraphType",
      "description": {
        "overall": "The GraphType class is an enumeration that represents different types of input graphs. It provides three specific graph types: CALLGRAPH, DEPENDENCY, and COMBINED. This class is used to define the type of graph being processed or analyzed.",
        "init_method": {
          "description": "The class does not have an explicit __init__ method. It is initialized as an enumeration class with predefined values.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic model designed to describe a single parameter of a function. It encapsulates the name, type, and description of a parameter, providing a structured way to represent parameter information.",
        "init_method": {
          "description": "The class is initialized with parameters name, type, and description, which are used to create an instance of ParameterDescription.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "The description of the parameter."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model designed to describe the return value of a function. It encapsulates three key attributes: name, type, and description of the return value.",
        "init_method": {
          "description": "The class is initialized with parameters for name, type, and description, which are used to create an instance of ReturnDescription.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model that describes the calling context of a function. It captures information about the functions or methods that a particular function calls and is called by. This class seems to be part of a larger system for analyzing or documenting code, providing essential context for understanding the interactions between different parts of the codebase.",
        "init_method": {
          "description": "The class is initialized with two string attributes: 'calls' and 'called_by'. These attributes are defined directly in the class body, indicating they are expected to be provided during instantiation.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string describing the functions or methods called by the function being analyzed."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string describing the functions or methods that call the function being analyzed."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not list any external dependencies.",
          "instantiated_by": "There is no information provided about where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to hold a detailed analysis of a function's purpose and signature. It includes fields for an overall description, parameters, return values, and usage context. This class serves as a structured data container for documenting and analyzing functions.",
        "init_method": {
          "description": "The class is initialized with an overall description of the function, a list of parameter descriptions, a list of return descriptions, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string providing a high-level description of the function's purpose."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the function."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects describing the return values of the function."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "An object providing context about where and how the function is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information provided about where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class is a Pydantic model designed to represent the JSON schema for a function. It encapsulates key information about a function, including its identifier, description, and any potential errors. This model serves as a foundational structure for analyzing and documenting functions within a system.",
        "init_method": {
          "description": "The class is initialized with an identifier, description, and an optional error field. The identifier is a string representing the name or unique identifier of the function. The description is an object of type FunctionDescription, which provides a detailed description of the function. The error field is optional and defaults to None, indicating that the function analysis is error-free.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string representing the name or unique identifier of the function."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object providing a detailed description of the function."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional field to store any error messages related to the function analysis. Defaults to None."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model that describes the __init__ method of a class. It contains two main fields: description and parameters. The description field provides a textual description of the constructor, while the parameters field is a list of ParameterDescription objects that detail the parameters accepted by the constructor.",
        "init_method": {
          "description": "The class is initialized with two parameters: description and parameters. The description parameter is a string that provides a summary of the constructor's purpose. The parameters field is a list of ParameterDescription objects that describe each parameter of the constructor.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the constructor's purpose."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing the parameters of the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model that describes the external dependencies and primary points of instantiation for a given class. It has two main attributes: dependencies and instantiated_by, both of which are strings. This class seems to be part of a larger system for analyzing and documenting class structures, providing a simple way to track where a class is used and what it depends on.",
        "init_method": {
          "description": "The class is initialized with two string parameters: dependencies and instantiated_by. These parameters are used to set up the instance attributes of the class.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string describing where the class is instantiated."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class does not have any external dependencies.",
          "instantiated_by": "The class is not instantiated by any other class or function."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to hold a comprehensive analysis of a class, including its purpose, constructor details, and method descriptions.",
        "init_method": {
          "description": "The constructor of ClassDescription initializes an instance with an overall description of the class, details about its constructor, a list of its methods, and its usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose of the class."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object containing details about the class's constructor."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of objects, each describing a method of the class."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing context about where and how the class is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as the main model for the entire JSON schema for a class, encapsulating essential information such as an identifier, description, and optional error details.",
        "init_method": {
          "description": "The constructor initializes the ClassAnalysis object with an identifier, description, and an optional error message.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique identifier for the class analysis."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "A detailed description of the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional field to store any error messages."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer. It is used in 'called_by' and 'instantiated_by' lists to provide detailed information about the call, including the file, function, mode, and line number.",
        "init_method": {
          "description": "The constructor of the CallInfo class initializes the object with parameters for file, function, mode, and line. It sets up the instance attributes for these parameters.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file where the call event occurs."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function making the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, e.g., 'method', 'function', 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number where the call event occurs."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to hold structured context for analyzing a function. It captures information about the functions called by the analyzed function and the functions or methods that call it.",
        "init_method": {
          "description": "The class is initialized with two parameters: calls and called_by. The calls parameter is a list of strings representing the functions called by the analyzed function. The called_by parameter is a list of CallInfo objects representing the functions or methods that call the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions or methods that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information provided about where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class is a Pydantic model designed to serve as input for generating a FunctionAnalysis object. It encapsulates necessary details such as analysis mode, identifier, source code, imports, and context for comprehensive function analysis.",
        "init_method": {
          "description": "The class is initialized with parameters defining the analysis input, including mode, identifier, source code, imports, and context.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "Specifies the mode of analysis, which must be 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the function's analysis."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "Contextual information about the function, including dependencies and usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to hold structured context information for methods in a class. It encapsulates details such as the method identifier, calls made by the method, the methods or functions that call it, argument names, and an optional docstring.",
        "init_method": {
          "description": "The class is initialized with parameters for identifier, calls, called_by, args, and docstring. These parameters are used to set up the instance attributes.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The name of the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of methods or functions called by this method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of methods or functions that call this method."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of argument names for the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "An optional docstring for the method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to hold structured context for analyzing a class. It encapsulates dependencies, instantiation information, and method context, providing a comprehensive view of the class's usage and behavior within the system.",
        "init_method": {
          "description": "The constructor initializes a ClassContextInput object with dependencies, instantiated_by, and method_context. It sets up the object's attributes based on the provided parameters.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of dependencies for the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of information about where the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of method context inputs for the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class depends on external types such as List, Optional, Literal, BaseModel, and ValidationError from the typing and pydantic modules.",
          "instantiated_by": "There is no information provided about where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class is a Pydantic model designed to serve as input for generating a ClassAnalysis object. It encapsulates necessary details for class analysis, including mode, identifier, source code, imports, and context.",
        "init_method": {
          "description": "The constructor of ClassAnalysisInput initializes the object with mode, identifier, source_code, imports, and context. It sets up the required fields for class analysis input.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "Specifies the mode of analysis, which must be 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The name or identifier of the class to be analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class definition."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "Additional context for the class analysis, including dependencies, instantiation details, and method context."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.DiagramRequest": {
      "identifier": "schemas.types.DiagramRequest",
      "description": {
        "overall": "The DiagramRequest class is a Pydantic model designed to represent input data for requesting diagram generation. It encapsulates properties for nodes, edges, analysis mode, and diagram focus, providing a structured way to specify diagram generation requests.",
        "init_method": {
          "description": "The class is initialized with parameters for nodes, edges, mode, and focus. The mode and focus have default values if not provided.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing nodes in the diagram."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing edges in the diagram."
            },
            {
              "name": "mode",
              "type": "AnalysisMode",
              "description": "The analysis mode for the diagram, defaults to AnalysisMode.STANDARD."
            },
            {
              "name": "focus",
              "type": "DiagramFocus",
              "description": "The focus of the diagram, defaults to DiagramFocus.ARCHITECTURE."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any known components."
        }
      },
      "error": null
    },
    "schemas.types.GraphInput": {
      "identifier": "schemas.types.GraphInput",
      "description": {
        "overall": "The GraphInput class represents a serializable form of a call graph, comprising nodes, edges, graph type, and optional metadata.",
        "init_method": {
          "description": "The class is initialized with parameters for nodes, edges, graph_type, and optional metadata. It sets up the instance attributes for these parameters.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing the nodes in the graph."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing the edges in the graph."
            },
            {
              "name": "graph_type",
              "type": "str",
              "description": "A string indicating the type of the graph."
            },
            {
              "name": "metadata",
              "type": "dict",
              "description": "An optional dictionary for additional metadata, defaulting to an empty dictionary."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.DiagramOutput": {
      "identifier": "schemas.types.DiagramOutput",
      "description": {
        "overall": "The DiagramOutput class is a Pydantic model designed to hold information about generated diagrams. It serves as an output schema for diagram-related data, encapsulating the diagram type, Mermaid code, and an explanation. This class provides a structured way to represent diagram output, ensuring data consistency and facilitating easy access to diagram information.",
        "init_method": {
          "description": "The class is initialized with parameters for diagram type, Mermaid code, and an explanation. These parameters are used to set up the instance attributes of the class.",
          "parameters": [
            {
              "name": "diagramtype",
              "type": "DiagramType",
              "description": "The type of the diagram."
            },
            {
              "name": "mermaid_code",
              "type": "str",
              "description": "The Mermaid code for the diagram."
            },
            {
              "name": "explanation",
              "type": "str",
              "description": "An explanation of the diagram."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    }
  }
}