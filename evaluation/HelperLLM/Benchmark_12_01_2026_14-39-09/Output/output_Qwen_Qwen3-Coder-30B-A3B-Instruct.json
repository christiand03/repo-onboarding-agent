{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The function 'path_to_module' converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies within a codebase. It takes a filename, an abstract syntax tree (AST), and a repository root path as inputs. Using a custom visitor class, it traverses the AST to identify import dependencies between files. The resulting graph captures these relationships as nodes and edges, where nodes represent files and edges indicate dependency relationships.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed for dependencies."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree representation of the file's source code."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory path of the repository containing the file."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph where nodes represent files and edges represent dependency relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.FileDependencyGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between Python files within a Git repository. It iterates through all files in the repository, filters for Python files, parses their content into ASTs, and builds a dependency graph for each file. These individual graphs are then merged into a single global graph that captures all inter-file dependencies. The resulting graph is returned as a NetworkX DiGraph.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository object containing the files to analyze for dependencies."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the dependency relationships between Python files in the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.build_file_dependency_graph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories. It resolves the given directory path to an absolute path, then uses recursive globbing to find all .py files. Each file path is normalized relative to the root directory. The function returns a list of Path objects representing these files.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The directory path from which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of Path objects representing all Python files found in the directory and its subdirectories, relative to the root directory."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analyses for example functions like 'add_item', 'check_stock', and 'generate_report', and simulates the process of generating documentation for these functions using an LLMHelper instance. It also handles the instantiation of a ClassAnalysisInput for an 'InventoryManager' class and processes the resulting documentation.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput",
          "called_by": "This function calls no other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a copy of the graph and generates a safe node naming scheme by prefixing each original node name with 'n' followed by its index. The function then relabels the nodes in the graph according to this safe naming scheme and assigns the original node labels as attributes to the new nodes. Finally, it writes the modified graph to a DOT file at the specified output path.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph to be processed and saved as a DOT file."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The function builds a filtered call graph from a Git repository by parsing Python files and extracting function call relationships. It identifies functions defined within the repository and constructs a directed graph containing only those functions and their interdependencies. The function processes each Python file in the repository, uses an AST visitor to extract function calls, and filters the resulting graph to include only user-defined functions. The final graph represents the call relationships between internally defined functions. This function serves as a utility for analyzing internal code dependencies.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "A GitRepository object containing the files to analyze for building the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the filtered call graph of user-defined functions."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The function 'wrap_cdata' takes a string input named 'content' and wraps it with CDATA tags, which are commonly used in XML to preserve the literal value of text. It returns a formatted string that includes the original content enclosed within the CDATA section markers. This function does not perform any complex operations or checks on the input; it simply applies a fixed formatting pattern.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The string content that needs to be wrapped inside CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "A string that contains the input 'content' wrapped with CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The function extracts content from notebook outputs, handling both text and image data. It processes outputs of different types such as display data, execute results, streams, and errors. For image data, it decodes Base64 strings and stores them in a provided list while returning placeholder XML tags. Text-based outputs are directly appended to the result list. The function uses helper logic to prioritize PNG over JPEG images when both are present.",
        "parameters": [
          {
            "name": "outputs",
            "type": "Any",
            "description": "A collection of output objects from a notebook execution."
          },
          {
            "name": "image_list",
            "type": "List[Dict[str, Any]]",
            "description": "A mutable list to store decoded image data along with metadata."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "List[str]",
            "description": "A list of text strings or XML placeholders representing the extracted content."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The function processes an image by checking if a given MIME type exists in a data dictionary. If found, it decodes the base64 string, appends the image data to a global list, and returns an XML placeholder tag with metadata. If an exception occurs during processing, it returns an error message. If the MIME type is not found, it returns None.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str or None",
            "description": "Returns an XML placeholder string with image metadata if successful, an error message if decoding fails, or None if the MIME type is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The function converts a Jupyter notebook's content into an XML representation. It reads the notebook from a string, processes each cell based on its type (markdown or code), and generates corresponding XML elements. For code cells, it also extracts and includes output content if present. The function handles parsing errors gracefully by returning an error message and an empty list.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "A string containing the raw content of a Jupyter notebook in JSON format."
          }
        ],
        "returns": [
          {
            "name": "xml_output",
            "type": "str",
            "description": "A string containing the XML representation of the notebook, with each cell wrapped in appropriate XML tags."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted image data from the notebook cells, if any."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.extract_output_content, backend.converter.wrap_cdata",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files to identify and convert Jupyter notebook files (.ipynb) into XML format. It iterates through the notebook files, converts each one using an external conversion function, and stores the resulting XML output and associated images in a dictionary keyed by the notebook file paths. The function logs the number of notebooks found and the processing of each individual notebook.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "List[File]",
            "description": "A list of file objects representing files in a repository, each with a 'path' attribute and a 'content' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "Dict[str, Dict[str, Any]]",
            "description": "A dictionary mapping notebook file paths to their converted XML output and associated images."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.convert_notebook_to_xml",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The function creates a bar chart comparing token counts between two formats, JSON and TOON, and saves the resulting plot to a specified file path. It uses matplotlib to generate the visualization, including customized labels, colors, and annotations for the bar values. The chart title dynamically includes the savings percentage. The function does not return any value.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of tokens used by the JSON format."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of tokens used by the TOON format."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage savings achieved by using the TOON format compared to JSON."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the generated chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function calculates the net duration of an operation by subtracting sleep times caused by rate limits from the total elapsed time. It specifically handles operations involving models prefixed with 'gemini-', applying adjustments based on batch processing. For non-gemini models, it returns the total duration directly. If there are no items to process, it returns zero. The calculation accounts for the number of batches and applies a fixed sleep interval per batch to determine the net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float or datetime",
            "description": "The starting timestamp of the operation."
          },
          {
            "name": "end_time",
            "type": "float or datetime",
            "description": "The ending timestamp of the operation."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items processed during the operation."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The number of items processed in each batch."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used, which determines whether rate limit adjustments are applied."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float or int",
            "description": "The calculated net duration after subtracting sleep times due to rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The `main_workflow` function orchestrates a comprehensive code analysis and documentation generation process for a given repository. It begins by extracting API keys and model configurations, then clones the repository and analyzes its structure. The function performs static analysis on the codebase to extract information, build a file tree, and identify relationships between components. It prepares inputs for a Helper LLM to analyze functions and classes, then uses both Helper and Main LLMs to generate detailed documentation and a final report. Finally, it saves the results and metrics to disk.",
        "parameters": [
          {
            "name": "input",
            "type": "Any",
            "description": "The input data, typically a string containing a repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services such as Gemini, OpenAI, and SCADsLLM."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary specifying the names of models to be used for helper and main LLMs."
          },
          {
            "name": "status_callback",
            "type": "Callable[[str], None]",
            "description": "An optional callback function to report progress updates."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final markdown report generated by the Main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and token usage metrics."
          }
        ],
        "usage_context": {
          "calls": "backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, schemas.types.MethodContextInput",
          "called_by": "This function calls no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The function 'update_status' takes a message as input and logs it using the logging module. It also optionally invokes a callback function named 'status_callback' if it is defined. This function serves as a centralized logging and status reporting mechanism.",
        "parameters": [
          {
            "name": "msg",
            "type": "Any",
            "description": "The message to be logged and optionally passed to the status callback."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function orchestrates the analysis of Jupyter notebooks from a GitHub repository using a language model. It begins by extracting a repository URL from input, clones the repository, processes its files into XML format, and extracts basic project information. For each notebook, it constructs a payload for the LLM, sends it, and collects the responses. Finally, it compiles all reports into a markdown file and returns the combined report along with performance metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "A string containing the input, expected to include a GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary mapping API key identifiers to their respective keys for different models."
          },
          {
            "name": "model",
            "type": "str",
            "description": "A string specifying the model to use for processing, determining which API key and base URL to select."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to report progress updates during execution."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "A compiled markdown report containing the results of analyzing each notebook."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and model-related metrics for the workflow execution."
          }
        ],
        "usage_context": {
          "calls": "backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The function `gemini_payload` constructs a structured payload for use with a Gemini API by combining basic information, notebook path, XML content, and image data. It processes XML content to identify image placeholders and substitutes them with base64-encoded image data. The resulting payload is a list of content segments, each either text or image URL objects, suitable for multimodal input.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "Any",
            "description": "Contains basic metadata or information about the context, likely related to the notebook or project."
          },
          {
            "name": "nb_path",
            "type": "Any",
            "description": "Represents the path to the current notebook file."
          },
          {
            "name": "xml_content",
            "type": "str",
            "description": "A string containing the XML structure of the notebook, which includes placeholders for images."
          },
          {
            "name": "images",
            "type": "list",
            "description": "A list of dictionaries, each representing an image with at least a 'data' key containing base64-encoded image data."
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "list",
            "description": "A list of dictionaries representing the constructed payload content. Each dictionary has a 'type' key indicating whether it is 'text' or 'image_url', and associated content."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles edge cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to ensure proper module naming.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The function encrypts a given text string using a Fernet cipher suite. It first checks if the input text is empty or if the cipher suite is not initialized, returning the text as-is in such cases. If both conditions are met, it strips whitespace from the input text, encodes it to bytes, encrypts it, and then decodes the result back to a string.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text string to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted version of the input text, or the original text if encryption was skipped due to invalid inputs."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The function decrypt_text is designed to decrypt a given encrypted text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available, returning the original text in such cases. If both conditions are met, it attempts to decrypt the text by encoding it, decrypting it with the cipher suite, and then decoding it back to a string. In case of any exception during decryption, it gracefully returns the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The encrypted text that needs to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str",
            "description": "The decrypted text if successful, otherwise the original input text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. It hashes the password using a hasher utility before storing the user information. The function also initializes additional fields such as API keys with empty strings. It returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user, used as the '_id' field in the database."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The plain text password of the user, which gets hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The unique identifier of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It performs a database query using the find() method and returns the results as a list. The function does not take any parameters and directly accesses the global 'dbusers' collection object.",
        "parameters": [],
        "returns": [
          {
            "name": "result",
            "type": "list",
            "description": "A list containing all user documents retrieved from the 'dbusers' collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The function fetch_user retrieves a user document from a MongoDB collection based on the provided username. It uses the find_one method to query the database with a filter matching the '_id' field to the given username. The function assumes the existence of a global variable 'dbusers' that represents a MongoDB collection. No explicit validation or error handling is present in the function body.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to locate the specific user document in the database."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "Any",
            "description": "The user document retrieved from the database if found; otherwise, None if no matching document exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name field of a user document in a MongoDB collection identified by the username. It uses the MongoDB update_one method to modify only the name field, leaving other fields unchanged. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier of the user whose name needs to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name value to set for the specified user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "The function updates a user's Gemini API key in the database by first encrypting the provided key and then performing an update operation on the 'dbusers' collection. It takes a username and a raw API key as inputs, ensures the key is stripped of whitespace, encrypts it, and stores the encrypted version in the database under the user's document. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key needs to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The raw Gemini API key provided by the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified in the database. This should typically be 1 if the update was successful."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "This function updates the GPT API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and performs an update operation on the user document. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL needs to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new Ollama base URL to be set for the specified user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. Typically 1 if the user exists and the update was applied."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the OpenSource API key for a given username in the database. It first encrypts the provided API key using an encryption function, then performs a MongoDB update operation to store the encrypted key under the user's document. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose OpenSource API key needs to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The OpenSource API key to be updated, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. Typically 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open source base URL for a user in the database. It takes a username and a new open source base URL as inputs, strips any leading or trailing whitespace from the URL, and attempts to update the corresponding document in the 'dbusers' collection. The function returns the count of modified documents, which should be 1 if the update was successful or 0 if no matching document was found.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL needs to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open source base URL to be set for the user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This will typically be 1 if a matching document was found and updated, or 0 if no matching document was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str or None",
            "description": "The Gemini API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The function retrieves a GPT API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gpt_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the OpenSource API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'opensrc_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose OpenSource API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The OpenSource API key if a matching user is found; otherwise, None."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function retrieves the open source base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'opensrc_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to look up the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "Optional[str]",
            "description": "The open source base URL associated with the user, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The function deletes a user from the database by their username. It performs a MongoDB delete operation on the 'dbusers' collection, targeting the document with the matching '_id' field equal to the provided username. The function returns the count of deleted documents, which should be 1 if the user was successfully deleted or 0 if no such user existed.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, typically 1 if the user was found and deleted, or 0 if no matching user was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys associated with a given username from a database. It fetches user data, decrypts sensitive information like Gemini and GPT API keys, and returns both decrypted keys and related URLs. The function handles cases where the user may not exist by returning None for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key for the user, or an empty string if not found."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL for the user, or an empty string if not found."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSRC base URL for the user, or an empty string if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The function 'insert_chat' creates a new chat entry in a database collection. It generates a unique identifier using UUID, captures the username and chat name, records the creation timestamp, and inserts the chat document into the database. The function then returns the ID of the newly inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "result.inserted_id",
            "type": "str",
            "description": "The unique identifier of the newly inserted chat document."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet den Benutzernamen als Filterkriterium und sortiert die Ergebnisse nach dem Erstellungsdatum in aufsteigender Reihenfolge. Das Ergebnis ist eine Liste der gefundenen Chat-Dokumente.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "Der Benutzername des Benutzers, dessen Chats abgerufen werden sollen."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "Eine Liste von Chat-Dokumenten, die dem angegebenen Benutzernamen entsprechen und nach Erstellungsdatum sortiert sind."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a query using MongoDB's find_one method to locate a matching document. If a match is found, the function returns True; otherwise, it returns False. The function does not modify any data but only retrieves and evaluates the existence of a record.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if a chat with the specified username and chat_name exists in the database, False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and updates all associated exchanges in the database. It first updates the chat entry in the chats collection, then updates all related exchange entries in the exchanges collection. The function returns the number of modified chat documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to assign to the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of chat documents that were successfully modified during the renaming operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The function inserts a new exchange record into a MongoDB collection. It generates a unique ID for the exchange, constructs a dictionary with all the provided details including optional fields with default values, and attempts to insert this document into the database. If the insertion fails, it catches the exception, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in response to the question."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback associated with the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used in the exchange, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main component used in the exchange, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Total time taken for the exchange, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Time taken by the helper component, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Time taken by the main component, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Number of JSON tokens used, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Number of Toon tokens used, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Percentage saved during the exchange, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique ID of the inserted exchange if successful, otherwise None."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves all exchange records from a MongoDB collection for a given username, sorted by creation timestamp in ascending order. It queries the 'dbexchanges' collection using the provided username as a filter and sorts the results by the 'created_at' field. The function returns the list of matching exchange records.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchange records by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange records matching the provided username, sorted by creation timestamp in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with specific criteria and orders the results by creation date in ascending order. The function returns the fetched exchanges as a list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the exchanges to be retrieved."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat associated with the exchanges to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange documents matching the provided username and chat name, sorted by creation date in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "The function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document with the new feedback value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The feedback value to be set in the document."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified as a result of the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message associated with a specific exchange ID in a MongoDB collection. It uses the 'update_one' method to modify a document where the '_id' field matches the provided exchange ID, setting the 'feedback_message' field to the new value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be set for the specified exchange."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified as a result of the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes a single document from the 'dbexchanges' collection in a MongoDB database based on the provided exchange ID. It uses the 'delete_one' method to remove the matching document and returns the count of deleted documents. The function takes a string identifier as input and performs a direct database operation without any additional processing or validation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "A string identifier used to locate and delete a specific document in the 'dbexchanges' collection."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the collection, typically 0 or 1 depending on whether a matching document was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The function deletes all exchanges and the chat entry associated with a given username and chat name from the database. It first removes all exchange records matching the criteria, then deletes the corresponding chat record. Finally, it returns the count of deleted chat entries. This ensures data consistency between the frontend and backend by removing all related chat data in one operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "del_chat.deleted_count",
            "type": "int",
            "description": "The number of chat entries that were deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The function 'clean_names' takes a list of strings representing model paths and extracts the final component of each path by splitting on the '/' character. It returns a new list containing only these final components. This is useful for simplifying model identifiers that include full directory paths.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list[str]",
            "description": "A list of strings where each string represents a path to a model, typically including directory separators."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "list[str]",
            "description": "A list of strings containing the final component of each path in the input list, obtained by splitting on '/' and taking the last element."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The function filters a given list of models based on a specified category name. It retrieves keywords associated with the category and applies filtering logic depending on whether 'STANDARD' is included in those keywords. If 'STANDARD' is present, it returns only models that exist in a predefined standard list. Otherwise, it filters models whose names contain any of the retrieved keywords. If no models match the criteria, the original list is returned.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "A list of model names to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category used to determine filtering criteria."
          }
        ],
        "returns": [
          {
            "name": "filtered_models",
            "type": "list",
            "description": "A list of model names that match the filtering criteria. If no matches are found, the original source_list is returned."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function handles the saving of a Gemini API key entered by the user in the frontend interface. It retrieves the key from the session state, updates the database with the new key associated with the user's username, clears the input field, and displays a success message to the user.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function retrieves an Ollama URL from the Streamlit session state and updates the database with the new URL for the current user. It also displays a success toast message upon completion. The function is designed to handle user input related to Ollama configuration.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_ollama_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The function loads chat and exchange data from a database for a given user, ensuring that data is only fetched when necessary based on session state. It initializes session state variables for chats and active chat, handles legacy support for exchanges, and ensures a default chat exists if none are present. The function interacts with database functions to retrieve and organize chat and exchange information.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which chat and exchange data should be loaded from the database."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value for a given exchange object in the database and triggers a rerun of the Streamlit application. It modifies the 'feedback' key in the exchange dictionary and calls a database update function to persist the change. Finally, it instructs Streamlit to re-execute the app to reflect the updated feedback.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing an exchange object, expected to contain keys such as 'feedback' and '_id'."
          },
          {
            "name": "val",
            "type": "Any",
            "description": "The new feedback value to be assigned to the exchange object."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "This function handles the deletion of an exchange from the database and updates the session state to reflect the removal of the exchange from the specified chat. It first deletes the exchange from the database using its ID, then checks if the exchange exists in the session state for the given chat and removes it if found. Finally, it triggers a rerun of the Streamlit app to update the UI.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is to be removed."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_exchange_by_id",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The function handle_delete_chat is responsible for deleting a specified chat for a given user. It first removes the chat from the database using delete_full_chat, then cleans up the session state by removing the chat from st.session_state.chats. If there are remaining chats, it sets the first one as the active chat; otherwise, it creates a new default chat named 'Chat 1' and sets it as active. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_full_chat, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from any URL present in the text. It uses regular expressions to find a URL, parses it using urllib.parse.urlparse, extracts the path component, and then derives the repository name from the last segment of the path. If the repository name ends with '.git', it removes the extension. If no URL is found or the path is empty, the function returns None.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string that may contain a URL from which the repository name is to be extracted."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name from the URL, with '.git' suffix removed if present."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when no URL is found in the input text or when the URL path is empty."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The function 'stream_text_generator' takes a string of text as input and yields each word from the text followed by a space, with a small delay between each yield. This creates a streaming effect where words are produced one at a time. It uses the 'time.sleep' function to introduce a 0.01 second pause between yielding each word.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string containing the text to be streamed word by word."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text by Mermaid code blocks, rendering regular markdown content normally and Mermaid diagrams using a dedicated Mermaid component. If rendering fails, it falls back to displaying the Mermaid code as a code block. The function supports streaming of regular text content based on a flag.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "A string containing markdown text that may include Mermaid diagram code blocks enclosed in triple backticks with 'mermaid' language identifier."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A boolean flag indicating whether regular markdown text should be streamed to the frontend using a stream generator."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "frontend.frontend.stream_text_generator",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The function `render_exchange` renders a chat message exchange in a Streamlit application, displaying a user question and an assistant's response. It includes interactive elements such as feedback buttons (like/dislike), a comment popover for notes, a download button for the response, and a delete button. The rendering logic varies based on whether the response contains an error. It also integrates with database operations for updating feedback messages and handles deletion of exchanges.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data including the question, answer, feedback, and other metadata."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat session, used for handling exchange deletions."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, frontend.frontend.render_text_with_mermaid",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse Python Abstract Syntax Tree (AST) nodes and collect structural information about modules, including imports, classes, and functions. It extends the standard `ast.NodeVisitor` to customize traversal behavior for extracting schema-like metadata from Python source code. The visitor maintains internal state such as the current module path and tracks class and function definitions along with their contextual details like line numbers, docstrings, and source segments.",
        "init_method": {
          "description": "Initializes the ASTVisitor with source code content, file path, and project root. It computes the module path based on these inputs and initializes an empty schema dictionary to store collected information about imports, functions, and classes.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The full text of the source code being analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The file path of the source code being processed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project containing the source file."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import statements in the AST by appending the names of imported modules to the schema's imports list. It iterates over all aliases in the import node and adds them to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called during AST traversal when an import node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes 'from ... import ...' statements by appending qualified import names (module.name) to the schema's imports list. It handles multiple aliases per import statement.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called during AST traversal when an 'import from' node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Captures class definitions in the AST and stores detailed metadata about them in the schema. It constructs a class info dictionary including identifiers, docstrings, source segments, and line numbers. It also sets the current class context for subsequent method processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called during AST traversal when a class definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definitions in the AST. If a class context is active, it records the function as a method within that class. Otherwise, it treats the function as a top-level function and appends it to the schema's functions list. It captures arguments, docstrings, and source code segments.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called during AST traversal when a function definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles asynchronous function definitions by delegating to the regular function visitor method. This ensures that async functions are treated similarly to regular functions in terms of schema collection.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an async function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method delegates to visit_FunctionDef.",
                "called_by": "This method is called during AST traversal when an async function definition node is encountered."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.AST_Schema.path_to_module for computing module paths.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Trees (ASTs) and building a structured schema that includes information about imports, functions, classes, and their relationships. It merges relationship data such as outgoing calls, incoming calls, dependencies, and instantiation contexts into the schema. The class also handles error cases during parsing and ensures that only valid Python files are processed.",
        "init_method": {
          "description": "The constructor for ASTAnalyzer does not take any parameters and simply passes, indicating that no initialization logic is required.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method takes a full schema and raw relationship data to enrich the schema with contextual information such as outgoing and incoming calls for functions and classes, as well as dependencies for classes. It iterates through the AST nodes in the schema to update function and class metadata with call relationships and computes class dependencies based on method calls.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary representing the full schema of the repository including file structures and AST nodes."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "A dictionary containing raw relationship data with keys 'outgoing' and 'incoming', mapping identifiers to lists of called/calling identifiers."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated schema with enriched relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method analyzes a list of files from a Git repository by parsing each Python file's content into an AST, visiting it with an ASTVisitor to extract schema nodes, and building a comprehensive schema of the repository structure. It filters out non-Python files and skips empty files, handling syntax errors gracefully by printing warnings.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects containing path and content information."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "An object representing the Git repository being analyzed."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary representing the structured schema of the repository including parsed AST nodes for each file."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.AST_Schema.ASTVisitor class to parse and visit the AST of each file.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.AST_Schema.ASTVisitor class for parsing and extracting schema nodes from Python files.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve Python import dependencies within a repository. It extends NodeVisitor to traverse AST nodes representing imports and builds a dependency graph by tracking which files depend on which modules or symbols. The class handles both absolute and relative imports, resolving relative paths based on the repository structure and checking for module existence or symbol exports in __init__.py files.",
        "init_method": {
          "description": "Initializes the FileDependencyGraph with a filename and repository root path. It sets up the instance variables to track the current file being analyzed and the root directory of the repository.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file for which dependencies are being analyzed."
            },
            {
              "name": "repo_root",
              "type": "Any",
              "description": "The root directory path of the repository being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "Resolves relative imports by analyzing the import node and determining the actual module or symbol names that can be imported. It checks for matching files or symbols in the repository structure, handling cases where imports use relative paths like '..'. The method raises an ImportError if no valid resolution can be found.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST nodes representing import statements. It adds the imported module names to the import_dependencies dictionary under the current filename, allowing the class to track what modules each file imports.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "An AST node representing an import statement."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "Optional base name of the module being imported."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes AST nodes representing 'from ... import ...' statements. It extracts the module name and resolves it appropriately, either by using the last part of the module path or by resolving relative imports through the _resolve_module_name method. If resolution fails, it prints an error message.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
          "instantiated_by": "This class is not instantiated by any other classes or functions according to the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class serves as a centralized interface for interacting with various language models, including Google Gemini, OpenAI, custom APIs, and Ollama, to generate and validate code documentation for functions and classes. It handles API configuration, batching, rate limiting, and structured output parsing using Pydantic models. The class supports multiple model types by dynamically selecting appropriate LLM clients and configuring batch processing based on model capabilities.",
        "init_method": {
          "description": "Initializes the LLMHelper with API credentials, prompt files, and model configuration. It reads system prompts from specified files, configures batch settings based on the model name, and sets up appropriate LLM clients for function and class documentation generation.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "API key for accessing the language model service."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "File path to the system prompt for function documentation generation."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "File path to the system prompt for class documentation generation."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "Name of the language model to use, defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Base URL for custom API endpoints, optional."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures batch processing settings for the language model based on its name. It assigns appropriate batch sizes for different models to optimize performance and avoid rate limiting issues.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "Name of the language model for which batch settings need to be configured."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the __init__ method."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Generates and validates documentation for a batch of functions using the configured language model. It processes inputs in batches, respects rate limits, and handles errors gracefully by returning None for failed items while maintaining order.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function input models containing information needed for documentation generation."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analysis results or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the backend.HelperLLM.LLMHelper class itself."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Generates and validates documentation for a batch of classes using the configured language model. Similar to generate_for_functions, it processes inputs in batches, respects rate limits, and handles errors gracefully by returning None for failed items while maintaining order.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class input models containing information needed for documentation generation."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analysis results or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the backend.HelperLLM.LLMHelper class itself."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several external libraries including langchain components for LLM integration, pydantic models for data validation, and standard library modules like json, logging, and time.",
          "instantiated_by": "This class is instantiated by the backend.HelperLLM module."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs), including Google's Gemini, OpenAI's GPT models, custom APIs, and local Ollama instances. It initializes with an API key, a path to a system prompt file, and a model identifier, configuring the appropriate LLM client based on the model type. The class supports two primary interaction modes: synchronous calls via `call_llm` and streaming responses via `stream_llm`, both utilizing the configured system prompt and user input.",
        "init_method": {
          "description": "Initializes the MainLLM instance by validating the API key, loading the system prompt from a specified file, and setting up the appropriate LLM client based on the model name. It supports multiple LLM backends including Google Generative AI, OpenAI-compatible APIs, and Ollama.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key used for authenticating with the LLM service."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt that will be loaded and used for LLM interactions."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use. Determines which backend (Google, OpenAI, Ollama) will be initialized."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Optional base URL for connecting to a custom LLM endpoint. Defaults to None."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "Synchronously invokes the configured LLM with a user input message, prepending the system prompt. It constructs the necessary message history and attempts to get a full response from the LLM. In case of errors, it logs the issue and returns None.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The content of the LLM's response if successful, otherwise None."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods internally.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "Initiates a streaming interaction with the configured LLM using the user input and system prompt. It yields content chunks from the LLM one at a time, allowing for real-time processing of responses. Errors during streaming are logged and yielded as error messages.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be streamed to the LLM."
                }
              ],
              "returns": [
                {
                  "name": "chunk_content",
                  "type": "str",
                  "description": "Yields content chunks from the LLM response or an error message if an exception occurs."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods internally.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were explicitly listed in the context.",
          "instantiated_by": "This class is not instantiated by any other classes or functions according to the provided context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It initializes with a structured dictionary to hold extracted information and provides methods to parse and extract data from these files. The class prioritizes information extraction from pyproject.toml, followed by requirements.txt, and finally README files. It also handles fallback mechanisms for missing data and formats dependencies for consistent display.",
        "init_method": {
          "description": "Initializes the ProjektInfoExtractor with a predefined structure for storing project information. It sets up placeholders for various project details like title, description, features, and dependencies, which will be populated during the parsing process.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from the input string, which can occur due to encoding issues when reading files in UTF-8 format that were actually encoded in UTF-16. It ensures clean content before further processing.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The input string that may contain null bytes to be removed."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "The cleaned string with null bytes removed."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by other parsing methods within the class to sanitize input content before processing."
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches through a list of files to find one that matches any of the given patterns, ignoring case. It returns the first matching file or None if no match is found.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file extension patterns to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[Any]",
                  "description": "The first matching file object or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the main extraction method to locate relevant project files like README, pyproject.toml, and requirements.txt."
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text from a markdown document that appears under a specified heading (marked by ##). It uses regular expressions to match headings and capture the subsequent content until the next heading or end of the document.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The markdown content to extract sections from."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords to look for as section headers."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[str]",
                  "description": "The extracted content under the matched heading or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the README parser to extract specific sections like Features, Tech Stack, and Status."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file to extract key project information such as title, description, features, tech stack, status, and installation instructions. It uses regex and helper methods to locate and extract relevant sections.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize input and _extrahiere_sektion_aus_markdown to extract specific sections.",
                "called_by": "This method is called by the main extraction method to parse README content."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file to extract project metadata such as name, description, and dependencies. It handles potential TOML decoding errors and updates the internal info structure accordingly.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize input and handles exceptions related to TOML parsing.",
                "called_by": "This method is called by the main extraction method to parse pyproject.toml content."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file to extract dependency information. It filters out comments and empty lines, and only populates dependencies if they haven't already been set from a pyproject.toml file.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the main extraction method to parse requirements.txt content."
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This is the main orchestration method that coordinates the extraction of project information. It finds relevant files, parses them in priority order (toml, requirements, readme), and performs final formatting of dependencies. It also derives a default project title from the repository URL if needed.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through for project information."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository, used to derive a default project title if none is found."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information organized into sections like 'projekt_uebersicht' and 'installation'."
                }
              ],
              "usage_context": {
                "calls": "Calls _finde_datei to locate relevant files, and _parse_toml, _parse_requirements, and _parse_readme to process them.",
                "called_by": "This method is intended to be called externally to initiate the information extraction process."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed in the context.",
          "instantiated_by": "No instantiation context is provided in the input."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze Python source code using the Abstract Syntax Tree (AST) to construct a call graph representation. It tracks function definitions, imports, and function calls to build a directed graph that maps relationships between different functions and modules. The class maintains internal state to manage current function and class contexts, local definitions, and import mappings to resolve names correctly. It leverages the networkx library to represent the call graph as a directed graph and stores edges representing function call relationships.",
        "init_method": {
          "description": "Initializes the CallGraph with a filename and sets up internal data structures including tracking for current function and class, local definitions, a networkx DiGraph for the call graph, import mappings, a set of function names, and a dictionary to store edges.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for call graph construction."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "Recursively traverses an AST node to extract the dotted name components of a function or attribute reference. It handles different types of AST nodes such as Call, Name, and Attribute to build a list of name components that can be joined to form a dotted string representation.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node to traverse for extracting name components."
                }
              ],
              "returns": [
                {
                  "name": "parts",
                  "type": "list[str]",
                  "description": "A list of strings representing the dotted name components."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the _resolve_all_callee_names method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "Resolves a list of dotted name components into fully qualified names by checking against local definitions, import mappings, and constructing appropriate names based on the current class context. It processes each set of name components and applies resolution rules to determine the final fully qualified name.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists containing name components for potential callees."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of fully qualified names for the callees."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _recursive_call method to process callee nodes.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "Constructs a fully qualified name for a function or method by combining the filename with the base name and optionally a class name. It formats the name according to a specific convention to uniquely identify functions within the context of a file and class.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name of the function or method."
                },
                {
                  "name": "class_name",
                  "type": "Optional[str]",
                  "description": "The optional class name to include in the fully qualified name."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The fully qualified name constructed from the filename, class name (if provided), and base name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_FunctionDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "Determines the current caller's name based on whether there is an active function context. If a function is currently being visited, it returns the function's name; otherwise, it returns a placeholder indicating global scope or the filename.",
              "parameters": [
                {
                  "name": "self",
                  "type": "CallGraph",
                  "description": "The instance of the CallGraph class."
                }
              ],
              "returns": [
                {
                  "name": "caller_name",
                  "type": "str",
                  "description": "The name of the current caller or a placeholder if no function is active."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST Import nodes by mapping imported module aliases to their actual module names. It updates the import_mapping dictionary to allow resolution of imported names during call graph construction.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST Import node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method to continue processing child nodes.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles AST ImportFrom nodes by mapping imported names to their originating modules. It extracts the module name and updates the import_mapping dictionary accordingly.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST ImportFrom node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes AST ClassDef nodes by temporarily setting the current class context while visiting the class's body. It ensures that function definitions within the class are properly associated with the class name when constructing fully qualified names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST ClassDef node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method to continue processing child nodes.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes AST FunctionDef nodes by tracking the function's full name, updating local definitions, adding the function to the call graph, and managing the current function context. It also records the function in a set of known functions for later use.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST FunctionDef node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _make_full_name and generic_visit methods.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles AST AsyncFunctionDef nodes by delegating to the visit_FunctionDef method, ensuring that asynchronous functions are treated similarly to regular functions in terms of call graph construction.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AST AsyncFunctionDef node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the visit_FunctionDef method.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Processes AST Call nodes by identifying the caller and resolving the callee names. It adds edges to the call graph representing the function call relationship between the caller and each resolved callee.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST Call node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _current_caller, _recursive_call, and _resolve_all_callee_names methods.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "Handles AST If nodes by checking if they represent a main block check (__name__ == '__main__'). If so, it temporarily changes the current function context to '<main_block>' before visiting the node's body. Otherwise, it proceeds with normal processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The AST If node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method to continue processing child nodes.",
                "called_by": "This method is called by the AST visitor mechanism."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the ast module for parsing Python code, networkx for graph representation, and other modules like getRepo.GitRepository and basic_info.ProjektInfoExtractor which may be used externally but are not directly part of the core functionality.",
          "instantiated_by": "This class is instantiated by code that needs to analyze Python source files for call graph construction, likely as part of a larger static analysis tool or dependency tracking system."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as the blob, content, and size to optimize performance by only loading data when accessed. The class provides properties to access these lazily-loaded attributes and includes utility methods for word count analysis and serialization to a dictionary format.",
        "init_method": {
          "description": "Initializes a RepoFile object with a file path and a Git tree object. It sets up internal attributes to store the file path, the Git tree, and placeholders for the blob, content, and size which are loaded on-demand.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The Git tree object representing the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "A property that lazily loads and returns the Git blob object associated with the file. If the blob hasn't been loaded yet, it attempts to retrieve it from the commit tree using the stored file path. If the file is not found in the tree, a FileNotFoundError is raised.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "A property that lazily loads and returns the decoded content of the file. It reads the data stream from the blob and decodes it as UTF-8 text, ignoring encoding errors. The content is cached after the first access.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "A property that lazily loads and returns the size of the file in bytes. It retrieves the size directly from the blob object and caches it after the first access.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "An example analysis method that counts the number of words in the file's content. It splits the content by whitespace and returns the length of the resulting list.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The total number of words in the file's content."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Provides a string representation of the RepoFile object, useful for debugging and logging purposes. It displays the file path of the RepoFile.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr",
                  "type": "str",
                  "description": "A string representation of the RepoFile object including its path."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Serializes the RepoFile object into a dictionary format. It includes basic file information such as path, name, size, and type. Optionally, it can also include the file's content if specified by the include_content flag.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "If True, the file's content will be included in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary containing file metadata and optionally the content."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on standard library modules like 'os' and external libraries such as 'git' for Git operations.",
          "instantiated_by": "The class is not instantiated anywhere explicitly mentioned in the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to its files through RepoFile objects. It supports listing all files, retrieving a hierarchical file tree, and cleaning up the temporary directory upon closing. The class implements context manager protocols (__enter__ and __exit__) to ensure proper resource management.",
        "init_method": {
          "description": "Initializes a GitRepository instance by cloning the specified repository URL into a temporary directory. It sets up necessary attributes such as the repository URL, temporary directory path, and references to the cloned repository and its latest commit. If cloning fails, it raises a RuntimeError after cleaning up resources.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "Retrieves a list of all files in the repository and creates RepoFile objects for each file. These objects are stored in the instance's 'files' attribute and returned as a list. The method uses git ls-files to obtain the file paths.",
              "parameters": [],
              "returns": [
                {
                  "name": "list[RepoFile]",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile class to instantiate file objects.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "Deletes the temporary directory used for storing the cloned repository. It prints a message indicating the deletion and resets the temp_dir attribute to None.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "Enables the use of the GitRepository instance as a context manager. It simply returns the instance itself, allowing it to be used in a 'with' statement.",
              "parameters": [],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The GitRepository instance."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "Implements the context manager's exit protocol. It calls the close() method to clean up the temporary directory when exiting a 'with' block.",
              "parameters": [
                {
                  "name": "exc_type",
                  "type": "Any",
                  "description": "Exception type if an exception occurred in the with block."
                },
                {
                  "name": "exc_val",
                  "type": "Any",
                  "description": "Exception value if an exception occurred in the with block."
                },
                {
                  "name": "exc_tb",
                  "type": "Any",
                  "description": "Exception traceback if an exception occurred in the with block."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the close() method to clean up resources.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "Constructs a hierarchical tree representation of the repository's file structure. If no files have been loaded yet, it first retrieves all files using get_all_files(). Then, it iterates over the files and builds nested dictionaries representing directories and files, including optional content if requested.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include file content in the returned dictionary representation."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the hierarchical file tree structure."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods directly.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.getRepo.RepoFile class for creating file representations.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze Python project structures by parsing Python files, identifying definitions (functions, classes, methods), and resolving call relationships between these definitions. It uses AST parsing to traverse files, collects metadata about definitions, and builds a call graph that maps which definitions call others. The analyzer supports ignoring common directories like .git and venv, and provides functionality to retrieve raw relationship data in terms of outgoing and incoming call relationships.",
        "init_method": {
          "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including a dictionary for storing definitions, a call graph represented as a defaultdict of lists, and a dictionary for storing parsed ASTs. Also defines a set of directories to ignore during file traversal.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory path of the project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "The analyze method orchestrates the full analysis process. It first identifies all Python files in the project root, excluding ignored directories. Then, for each file, it collects definitions and resolves calls. Finally, it clears the stored ASTs to free memory and returns the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "defaultdict(list)",
                  "description": "A mapping of callee identifiers to a list of caller information dictionaries."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "The get_raw_relationships method processes the internal call graph to extract outgoing and incoming call relationships. It iterates over the call graph entries and constructs two separate mappings: one for outgoing relationships (which callers call which callees) and one for incoming relationships (which callees are called by which callers). These are returned as sorted lists for deterministic output.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing 'outgoing' and 'incoming' keys mapping identifiers to sorted lists of related identifiers."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "The _find_py_files method recursively walks through the project root directory and identifies all Python (.py) files, excluding those located in predefined ignore directories such as .git, venv, etc. It returns a list of absolute paths to these Python files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list[str]",
                  "description": "A list of absolute file paths to Python files in the project."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "The _collect_definitions method parses a given Python file using the AST module and extracts information about function, class, and method definitions. It associates each definition with its file location and type, storing this information in the definitions dictionary. It also handles errors during parsing by logging them and marking the file's AST as None.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file to parse and collect definitions from."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the path_to_module utility function to compute the module path.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "The _get_parent method traverses an AST to find the parent node of a given AST node. It walks the tree and checks for parent-child relationships, returning the parent node if found, otherwise returning None.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The AST tree to search within."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node whose parent is to be found."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST or None",
                  "description": "The parent AST node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is called by the _collect_definitions method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "The _resolve_calls method uses a CallResolverVisitor to analyze a Python file's AST and resolve call relationships. It extends the internal call graph with the resolved calls from the visitor. Errors during call resolution are logged but do not halt execution.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file to resolve calls in."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the CallResolverVisitor class to perform call resolution.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.relationship_analyzer.CallResolverVisitor and backend.relationship_analyzer.path_to_module.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is an AST (Abstract Syntax Tree) visitor designed to traverse Python source code and resolve call relationships between functions, methods, and modules. It tracks the current execution context including class names, function names, and module paths to accurately associate calls with their respective callers. It also maintains mappings of variable scopes and instance types to resolve qualified names of function calls and imports. The class collects information about which functions call which other functions and stores this relationship data in a structured format.",
        "init_method": {
          "description": "Initializes the CallResolverVisitor with the file path, project root, and definitions dictionary. It sets up internal state variables such as scope tracking, instance type mapping, and call collection structures.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The path to the Python file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project being analyzed."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary containing known definitions (functions, classes, etc.) mapped by their qualified names."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles the traversal of class definitions in the AST. It updates the current class name context before visiting child nodes and restores the previous class name after traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor during traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definitions in the AST. It updates the current caller name to reflect the fully qualified name of the function, including module and class context, before traversing child nodes and then restores the previous caller name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor during traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes function calls in the AST. It resolves the qualified name of the called function and records the call relationship if the callee is defined in the provided definitions dictionary. It determines the caller type based on context and stores the call metadata.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing a function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor during traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import statements in the AST. It maps imported names to their actual module paths in the scope dictionary, allowing for resolution of qualified names later during call analysis.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor during traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes 'from ... import ...' statements in the AST. It resolves relative imports and maps imported names to their fully qualified paths in the scope dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor during traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Handles assignment statements in the AST. Specifically, it identifies assignments of function calls to variables and records the type of the assigned object if it corresponds to a known class definition.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node representing an assignment statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor during traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the qualified name of a function call based on the AST node representing the function. It handles both direct function names and attribute access expressions, checking against the scope and instance types to determine the fully qualified name.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.expr",
                  "description": "The AST node representing the function being called."
                }
              ],
              "returns": [
                {
                  "name": "qualified_name",
                  "type": "str or None",
                  "description": "The fully qualified name of the function if resolved, otherwise None."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.relationship_analyzer.path_to_module function to compute module paths.",
          "instantiated_by": "This class is not instantiated by any other code listed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the metadata of a single function parameter. It encapsulates three essential attributes: the parameter's name, its type, and a descriptive explanation. This class ensures that parameter descriptions adhere to a consistent structure, making it suitable for use in API documentation, function introspection, or any scenario requiring standardized parameter metadata.",
        "init_method": {
          "description": "The constructor initializes a ParameterDescription instance with three required fields: name, type, and description. These fields are defined as string types and are used to store information about a function parameter.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the function parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The data type of the function parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the function parameter's purpose or usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not directly instantiated by any other code listed in the context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic BaseModel designed to describe the return value of a function. It encapsulates three key pieces of information about a function's return: the name of the return value, its type, and a descriptive explanation. This class serves as a structured way to document and validate function return values, ensuring consistency in API or function signatures.",
        "init_method": {
          "description": "The class is initialized with three required fields: name, type, and description. These fields represent the essential metadata needed to describe a function's return value.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model designed to represent and validate the calling context of a function, specifically capturing information about what functions are called and by whom. It serves as a structured data container for metadata related to function invocation relationships.",
        "init_method": {
          "description": "Initializes the UsageContext instance with two string fields: 'calls', describing the functions called, and 'called_by', describing the caller of the function.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string describing the functions or methods that are called within the context."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string describing the function or method that invokes the current function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not explicitly instantiated by any other component listed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed metadata about a function, including its overall purpose, parameter descriptions, return value details, and usage context. It serves as a structured representation for documenting function signatures and behaviors in a standardized way.",
        "init_method": {
          "description": "The constructor initializes the FunctionDescription instance with required fields: overall (a string describing the function's purpose), parameters (a list of ParameterDescription objects), returns (a list of ReturnDescription objects), and usage_context (a UsageContext object).",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose of the function."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the function."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects detailing the return values of the function."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "An object providing contextual information about how the function is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class serves as the primary data model for representing the complete JSON schema of a function. It encapsulates essential information about a function including its unique identifier, a detailed description, and an optional error field for capturing validation issues. This class leverages Pydantic's BaseModel to enforce data integrity and type safety.",
        "init_method": {
          "description": "Initializes a FunctionAnalysis instance with an identifier, a function description, and an optional error message. The constructor sets up the core attributes required to represent a function's metadata and potential errors.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object containing detailed information about the function's behavior, parameters, and return values."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store error messages related to function validation or execution."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It encapsulates a textual description of the constructor's purpose and a list of parameter descriptions that define its inputs.",
        "init_method": {
          "description": "Initializes a ConstructorDescription instance with a description of the constructor and a list of parameter descriptions.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the constructor's purpose."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other component as indicated by the context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model designed to encapsulate information about a class's external dependencies and the entities that instantiate it. It serves as a structured representation of metadata related to class usage and integration within a system.",
        "init_method": {
          "description": "Initializes a ClassContext instance with two string fields: 'dependencies' and 'instantiated_by'. These fields store information about the class's external dependencies and the entities that create instances of the class, respectively.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string describing the entities or components that instantiate the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class serves as a structured representation for encapsulating detailed information about a Python class, including its overall purpose, constructor details, individual method analyses, and usage context. It is designed to provide a comprehensive overview of a class's functionality and structure, making it suitable for documentation or analysis systems.",
        "init_method": {
          "description": "Initializes an instance of the ClassDescription class with specified attributes for overall purpose, constructor description, list of method analyses, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose of the class."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object detailing the constructor of the class."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects representing each method in the class."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing context on how the class is used or instantiated."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were identified for this class.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as the primary data model for representing the complete JSON schema of a class. It encapsulates essential information about a class including its identifier, a detailed description, and an optional error message. This class is designed to provide a standardized structure for documenting class metadata and associated descriptions, making it suitable for use in documentation generation systems.",
        "init_method": {
          "description": "Initializes a new instance of the ClassAnalysis class with the required identifier and description fields, and an optional error field.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An instance of ClassDescription containing detailed information about the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store any error messages related to the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond standard typing and pydantic imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It serves as a data structure to encapsulate details of a call event within a codebase analysis system.",
        "init_method": {
          "description": "Initializes a CallInfo instance with file, function name, call mode, and line number attributes.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file path where the call event occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that made the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, such as 'method', 'function', or 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number in the file where the call occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were identified for this class.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to represent structured context for analyzing a function. It encapsulates two key pieces of information: a list of function names that the analyzed function calls, and a list of CallInfo objects indicating which functions call the analyzed function. This model serves as a data structure for organizing and transmitting metadata about function call relationships within a codebase.",
        "init_method": {
          "description": "Initializes the FunctionContextInput model with two fields: 'calls', a list of strings representing function names called by the analyzed function, and 'called_by', a list of CallInfo objects representing functions that call the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the names of functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class serves as a structured input model for generating FunctionAnalysis objects. It encapsulates all necessary information required for function analysis, including the mode of operation, function identifier, source code, import statements, and contextual data. This class ensures that the input to the function analysis process is standardized and validated using Pydantic's type checking capabilities.",
        "init_method": {
          "description": "Initializes the FunctionAnalysisInput instance with the required fields for function analysis. The constructor sets up the mode, identifier, source code, imports, and context attributes needed for processing.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal[\"function_analysis\"]",
              "description": "Specifies the mode of operation as 'function_analysis' to indicate the purpose of this input."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements used in the function's source code."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "Additional contextual information required for the function analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on pydantic.BaseModel for data validation and typing modules for type hints.",
          "instantiated_by": "This class is instantiated by components responsible for preparing function analysis inputs, likely within a larger documentation or code analysis pipeline."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to represent structured context information for a class's methods. It encapsulates details such as the method's identifier, the list of methods it calls, the list of callers, its arguments, and its docstring. This class serves as a data transfer object to convey metadata about method usage and dependencies within a class.",
        "init_method": {
          "description": "The constructor initializes the MethodContextInput instance with fields for identifier, calls, called_by, args, and docstring. These fields are used to store contextual information about a method's behavior and relationships.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the identifiers of methods called by this method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects indicating which methods call this method."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of strings representing the argument names of the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "An optional string containing the docstring of the method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond standard typing and pydantic.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to encapsulate structured context information for analyzing a class. It holds three main pieces of information: a list of dependencies, a list of call information for instances where the class is instantiated, and a list of method context inputs detailing the methods within the class. This model serves as a data structure to represent and validate the contextual metadata associated with a class during analysis.",
        "init_method": {
          "description": "The constructor for ClassContextInput initializes the instance with three attributes: dependencies, instantiated_by, and method_context. These attributes are expected to be lists of specific types, namely List[str], List[CallInfo], and List[MethodContextInput] respectively.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of strings representing the dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects indicating where and how the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects describing the context of methods within the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput is a Pydantic model designed to encapsulate the necessary input data required for generating a ClassAnalysis object. It serves as a structured data container that defines the expected fields and types for class analysis operations, including the mode of operation, class identifier, source code, import statements, and contextual information.",
        "init_method": {
          "description": "Initializes the ClassAnalysisInput model with the specified fields: mode, identifier, source_code, imports, and context. The mode is constrained to the literal value 'class_analysis', ensuring that only class analysis operations can instantiate this model.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "A literal string value that specifies the mode of operation as 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class being analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements associated with the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "An object containing contextual information related to the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel for data validation and serialization, along with typing modules for type hints.",
          "instantiated_by": "This class is not instantiated by any other class based on the provided context."
        }
      },
      "error": null
    }
  }
}