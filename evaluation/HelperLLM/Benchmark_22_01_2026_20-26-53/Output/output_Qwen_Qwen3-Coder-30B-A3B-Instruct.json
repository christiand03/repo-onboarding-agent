{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The function 'path_to_module' converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to ensure proper module naming.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies by traversing an Abstract Syntax Tree (AST) of a given Python file. It uses a custom visitor class to extract import dependencies and builds a NetworkX DiGraph where nodes represent files and edges represent dependency relationships. The function takes a filename, an AST tree, and a repository root path as inputs.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which the dependency graph is being built."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree representation of the Python file."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory path of the repository containing the file."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing file dependencies, where nodes are files and edges indicate import relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.FileDependencyGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between Python files within a given Git repository. It iterates through all files in the repository, filters for Python files, parses their content into ASTs, and builds individual dependency graphs for each file. These individual graphs are then merged into a single global dependency graph. The function uses networkx to manage the graph structure and ensures that all nodes and edges from the individual file graphs are properly added to the global graph.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The GitRepository object containing the files to analyze for dependencies."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the overall dependency structure of all Python files in the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.build_file_dependency_graph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories. It resolves the given directory path to an absolute path, then uses recursive globbing to find all .py files. Each found file is converted to a relative path with respect to the root directory. The function returns a list of these relative paths as pathlib.Path objects.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory from which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of pathlib.Path objects representing the relative paths of all .py files found in the directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analysis for various methods such as 'add_item', 'check_stock', and 'generate_report'. These analyses are then used to simulate how the LLMHelper would process function and class inputs to generate documentation. The function also initializes an LLMHelper instance and processes the defined inputs to produce a final documentation structure.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a copy of the graph and generates a mapping from original node names to safe identifiers prefixed with 'n'. The original graph nodes are relabeled using this mapping, and the original node labels are stored in the new graph's node attributes. Finally, the modified graph is written to a file in DOT format.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph to be processed and saved."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The function builds a filtered call graph from a Git repository by parsing Python files and extracting function call relationships. It first identifies all Python files in the repository and parses their content using the AST module. Then, it uses a custom CallGraph visitor to extract function definitions and call edges. Finally, it constructs a NetworkX directed graph containing only those function calls that involve user-defined functions.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "A GitRepository object representing the repository to analyze for building the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the filtered call graph containing only user-defined functions and their interdependencies."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The function 'wrap_cdata' takes a string input named 'content' and wraps it with CDATA (Character Data) tags. This is commonly used in XML documents to escape text content that might otherwise be interpreted as markup. The function returns a formatted string that includes the original content enclosed within '<![CDATA[' and ']]>' delimiters, along with newline characters before and after the content for readability.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The string content that needs to be wrapped with CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "A string that contains the input 'content' wrapped in CDATA tags with surrounding newlines."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The function extracts content from notebook outputs, handling both text and image data. It processes outputs of different types such as display_data, execute_result, stream, and error, returning a list of text snippets or image placeholders. For images, it decodes Base64-encoded data and stores it in an external list while generating XML placeholders. The function prioritizes PNG over JPEG when both are present.",
        "parameters": [
          {
            "name": "outputs",
            "type": "Any",
            "description": "A collection of notebook output objects to be processed."
          },
          {
            "name": "image_list",
            "type": "List[Dict[str, Any]]",
            "description": "A mutable list to store decoded image data along with metadata."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "List[str]",
            "description": "A list of text strings or XML placeholders representing the extracted content."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The function processes an image by checking if a given MIME type exists in a data dictionary. If found, it decodes the base64 string, appends the image data to a global list, and returns an XML placeholder string with the image index and MIME type. If an exception occurs during processing, it returns an error message. If the MIME type is not found in the data, the function returns None.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str or None",
            "description": "Returns an XML placeholder string with image details if successful, otherwise returns an error message or None if the MIME type is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "This function converts a Jupyter notebook, represented as a string of JSON content, into an XML format. It parses the notebook using nbformat, iterates through each cell, and transforms markdown and code cells into XML elements. For code cells, it also extracts and includes output content if present. The function handles parsing errors gracefully by returning an error message and an empty list.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "A string containing the raw JSON content of a Jupyter notebook."
          }
        ],
        "returns": [
          {
            "name": "xml_output",
            "type": "str",
            "description": "A string containing the XML representation of the notebook, with each cell wrapped in <CELL> tags."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted image data from the notebook's outputs."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.extract_output_content, backend.converter.wrap_cdata",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files to identify and convert Jupyter notebook files (.ipynb) into XML format along with associated images. It iterates through the notebook files, logs the processing status, and returns a dictionary mapping each notebook file path to its converted XML content and image data.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "List[File]",
            "description": "A list of file objects representing repository files, each expected to have a 'path' attribute and a 'content' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "Dict[str, Dict[str, Any]]",
            "description": "A dictionary where keys are notebook file paths and values are dictionaries containing 'xml' (converted XML content) and 'images' (associated image data)."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.convert_notebook_to_xml",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The function creates a bar chart comparing token counts between two formats, JSON and TOON, and saves the resulting image to a specified file path. It uses matplotlib to generate the visualization, including labels, colors, and annotations for the bar values. The chart title dynamically includes the savings percentage. The function does not return any value.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of tokens in the JSON format."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of tokens in the TOON format."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage savings achieved by using the TOON format compared to JSON."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the generated chart image will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function calculates the net duration of an operation by subtracting sleep times caused by rate limits from the total elapsed time. It specifically handles cases where the model name starts with 'gemini-' and adjusts the calculation based on the number of items processed and the batch size. If the model is not a Gemini model, it returns the total duration directly. For zero items, it returns zero. Otherwise, it computes the number of batches, determines the number of sleep periods, and subtracts the total sleep time from the overall duration.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float or datetime",
            "description": "The starting timestamp of the operation."
          },
          {
            "name": "end_time",
            "type": "float or datetime",
            "description": "The ending timestamp of the operation."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items processed during the operation."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The number of items processed per batch."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used, which determines whether rate limit adjustments apply."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float or int",
            "description": "The net duration of the operation after subtracting sleep times due to rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The `main_workflow` function orchestrates a comprehensive code analysis and documentation generation process for a given repository. It begins by extracting API keys and model configurations, then clones the repository and analyzes its structure. The function proceeds to extract basic project information, construct a file tree, and perform relationship analysis on the codebase. It generates an Abstract Syntax Tree (AST) schema and enriches it with relationship data. Subsequently, it prepares inputs for a Helper LLM to analyze functions and classes, and then calls the Helper LLM to generate documentation for these elements. Finally, it prepares inputs for a Main LLM to generate a final report, saves the report along with performance metrics and token usage statistics, and returns the generated report and associated metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "Any",
            "description": "The input data, typically a string containing a repository URL, used to initiate the workflow."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services such as Gemini, OpenAI, and SCADSLMM."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary specifying the names of models to be used for the Helper LLM and Main LLM."
          },
          {
            "name": "status_callback",
            "type": "Callable[[str], None]",
            "description": "An optional callback function to report progress updates during the workflow execution."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final markdown report generated by the Main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing performance metrics such as execution times, model names, and token usage statistics."
          }
        ],
        "usage_context": {
          "calls": "backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, schemas.types.MethodContextInput",
          "called_by": "This function calls no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The function 'update_status' takes a message as input and logs it using the logging module. It also optionally invokes a callback function named 'status_callback' if it is defined. This function serves as a utility for reporting status messages throughout the application.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "A message string to be logged and optionally passed to a status callback."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function orchestrates the processing of Jupyter notebooks from a GitHub repository using an LLM. It begins by extracting a repository URL from the input, clones the repository, processes the notebooks into XML format, and extracts basic project information. It then iterates through each notebook, constructs a payload for the LLM based on the notebook's content and associated images, and generates a report for each. Finally, it aggregates all reports into a single markdown file and returns both the report and performance metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "Any",
            "description": "The input string which should contain a GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "Dict[str, str]",
            "description": "A dictionary mapping API key identifiers to their respective keys for different models."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the language model to use for processing."
          },
          {
            "name": "status_callback",
            "type": "Optional[Callable[[str], None]]",
            "description": "An optional callback function to report processing status updates."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "A concatenated markdown report of all processed notebooks."
          },
          {
            "name": "metrics",
            "type": "Dict[str, Any]",
            "description": "Performance metrics including execution time and model information."
          }
        ],
        "usage_context": {
          "calls": "backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The function `gemini_payload` constructs a structured payload for use with a Gemini-based API by combining basic information, notebook path, XML content, and embedded images. It processes XML content to identify image placeholders and replaces them with base64-encoded image data. The resulting payload is a list of dictionaries, each representing either text or image content.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "Any",
            "description": "A dictionary or object containing basic information about the context."
          },
          {
            "name": "nb_path",
            "type": "Any",
            "description": "The path to the current notebook file."
          },
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML content of the notebook, which may contain image placeholders."
          },
          {
            "name": "images",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries, each containing image metadata including base64-encoded data."
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries representing the constructed payload, where each element is either a text segment or an image URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The function encrypts a given text string using a cipher suite, returning the encrypted result as a string. It first checks if the input text is empty or if the cipher suite is not available, in which case it returns the input text unchanged. If both conditions are satisfied, it encodes the stripped text to bytes, encrypts it using the cipher suite, and then decodes the result back to a string.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text string to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted version of the input text, returned as a string."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The function decrypt_text is designed to decrypt a given encrypted text using a cipher suite. It first checks if the input text is empty or if the cipher_suite is not available, returning the original text in such cases. If both conditions are met, it attempts to decrypt the text by encoding it, decrypting it with the cipher suite, and then decoding it back to a string. In case of any exception during decryption, it gracefully returns the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The encrypted text that needs to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str",
            "description": "The decrypted text if the decryption process is successful; otherwise, the original input text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. It hashes the password using a hasher utility before storing the user data. The function also initializes additional fields such as API keys with empty strings. Finally, it returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user, used as the '_id' field in the database."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The plain text password of the user, which gets hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The unique identifier of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It performs a database query using the 'find()' method and returns the results as a list. The function does not take any parameters and directly accesses a global or module-level variable 'dbusers' which is expected to be a MongoDB collection object.",
        "parameters": [],
        "returns": [
          {
            "name": "result",
            "type": "list",
            "description": "A list containing all user documents retrieved from the 'dbusers' MongoDB collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The function fetch_user retrieves a user document from a MongoDB collection based on the provided username. It uses the find_one method to search for a document where the '_id' field matches the given username. The function assumes the existence of a global variable 'dbusers' that represents a MongoDB collection. This function serves as a simple lookup mechanism for fetching user data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to locate the specific user document in the database."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "Any",
            "description": "The user document retrieved from the database if found; otherwise, None if no matching document exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name field of a user document in a MongoDB collection identified by the user's username. It uses the MongoDB update_one method to modify only the name field, leaving other fields unchanged. The function returns the count of modified documents, which should be 1 if the update was successful or 0 if no matching document was found.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user whose name needs to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name value to set for the specified user."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation. This will typically be 1 if the user exists and 0 if no matching user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates the Gemini API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key needs to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be stored for the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This indicates whether the user's API key was updated."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "The function updates the GPT API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs a MongoDB update operation to store the encrypted key under the user's ID. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The GPT API key to be updated for the specified user. This key is stripped of leading/trailing whitespace before encryption."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were modified as a result of the update operation. Typically 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and then performs an update operation on the user document in the database. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL needs to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new Ollama base URL to be set for the specified user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This should typically be 1 if the user exists and the update was successful."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the OpenSource API key for a given user in the database. It first encrypts the provided API key using an encryption function, then performs a MongoDB update operation to store the encrypted key under the user's document. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose OpenSource API key needs to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The OpenSource API key to be updated for the specified user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open source base URL for a user in the database. It takes a username and a new open source base URL as inputs, strips any leading or trailing whitespace from the URL, and then performs an update operation on the user document in the database. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL needs to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open source base URL to be set for the user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This should typically be 1 if the user exists and the update was successful."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "Optional[str]",
            "description": "The Gemini API key associated with the user, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The function retrieves a GPT API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gpt_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the OpenSource API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'opensrc_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to look up the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The OpenSource API key if a matching user is found; otherwise, None."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function retrieves the open source base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'opensrc_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to look up the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str or None",
            "description": "The open source base URL retrieved from the database for the given username, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The function 'delete_user' removes a user document from a MongoDB collection based on the provided username. It uses the 'delete_one' method to target a specific user identified by the '_id' field. The function returns the count of deleted documents, which should be 1 if the user was successfully deleted or 0 if no matching user was found.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, typically 1 if the user existed and was deleted, or 0 if no such user was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys for a given username from a database. It fetches user data, decrypts sensitive API keys using a decryption function, and returns both decrypted keys and associated base URLs. The function handles cases where the user may not exist by returning None for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key for the user."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL for the user."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key for the user."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key for the user."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSRC base URL for the user."
          }
        ],
        "usage_context": {
          "calls": "database.db.decrypt_text",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The function 'insert_chat' creates a new chat entry in a database collection. It generates a unique identifier using UUID, assigns the provided username and chat name, and records the creation timestamp. The function then inserts this chat document into the database and returns the ID of the newly inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "result.inserted_id",
            "type": "str",
            "description": "The unique identifier of the newly inserted chat document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet den Benutzernamen als Filterkriterium und sortiert die Ergebnisse nach dem Erstellungsdatum in aufsteigender Reihenfolge. Das Ergebnis ist eine Liste der gefundenen Chat-Dokumente.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "Der Benutzername des Benutzers, dessen Chats abgerufen werden sollen."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "Eine Liste aller Chat-Dokumente, die dem angegebenen Benutzernamen entsprechen, sortiert nach Erstellungsdatum."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a lookup in the 'dbchats' collection using a MongoDB query that matches both the username and chat name. The function returns a boolean value indicating the presence or absence of the chat entry.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if a chat with the specified username and chat_name exists in the database; False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and updates all associated exchanges in the database. It first updates the chat entry in the chats collection, then updates all related exchange records in the exchanges collection. The function returns the number of modified chat entries.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to assign to the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of chat entries that were successfully modified."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The function `insert_exchange` is designed to insert a new exchange record into a MongoDB collection. It takes various parameters related to a user's interaction, such as question, answer, feedback, and usage statistics, and stores them in a structured dictionary format. The function generates a unique ID for each exchange and attempts to insert the data into the database. In case of an exception during insertion, it prints an error message and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question posed by the user."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in response to the question."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback provided by the user regarding the answer."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who initiated the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session associated with the exchange."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper tool used in the exchange (optional)."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main tool used in the exchange (optional)."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Total time taken for the exchange (optional)."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Time taken by the helper tool (optional)."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Time taken by the main tool (optional)."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Number of JSON tokens used (optional)."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Number of Toon tokens used (optional)."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Percentage of savings achieved (optional)."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique identifier generated for the inserted exchange record."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when an exception occurs during the database insertion process."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves all exchange records from a MongoDB collection for a given username, sorted by creation timestamp in ascending order. It queries the 'dbexchanges' collection using the provided username as a filter and sorts the results by the 'created_at' field. The function returns the list of matching exchange records.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchange records by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange records matching the provided username, sorted by creation timestamp in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with filtering criteria and orders the results by creation date in ascending order. The function returns the complete list of matching exchange records.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the exchanges to be fetched."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat associated with the exchanges to be fetched."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange records matching the provided username and chat name, sorted by creation date in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "This function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document with the new feedback value. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The feedback value to be set in the document."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message associated with a specific exchange ID in a MongoDB collection. It uses the 'update_one' method to modify a document where the '_id' field matches the provided exchange ID, setting the 'feedback_message' field to the new value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be set for the specified exchange."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation. This value is typically 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes a document from the 'dbexchanges' collection in a MongoDB database based on a provided exchange ID. It uses the 'delete_one' method to remove the matching document and returns the count of deleted documents. The function assumes that 'dbexchanges' is a valid MongoDB collection object and that 'exchange_id' is a valid string identifier.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "A unique identifier for the exchange document to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted, typically 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The function deletes all exchanges and the chat entry associated with a given username and chat name from the database. It first removes all exchange records matching the criteria, then deletes the corresponding chat record. The function returns the count of deleted chat entries, which should be 1 if the operation was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "del_chat.deleted_count",
            "type": "int",
            "description": "The number of chat documents deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The function 'clean_names' takes a list of model names, which are expected to be strings containing forward slashes, and extracts the last part of each string after splitting by the slash character. This effectively strips away any directory or path components, leaving only the base name of each model. It uses a list comprehension for efficient processing.",
        "parameters": [
          {
            "name": "model_list",
            "type": "List[str]",
            "description": "A list of strings representing model names, potentially including path components separated by forward slashes."
          }
        ],
        "returns": [
          {
            "name": "cleaned_names",
            "type": "List[str]",
            "description": "A list of strings containing only the base names of the models, with path components removed."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The function filters a given list of models based on a specified category name. It retrieves keywords associated with the category and applies filtering logic depending on whether 'STANDARD' is included in those keywords. If 'STANDARD' is present, it returns only models that exist in a predefined standard list. Otherwise, it filters models whose names contain any of the retrieved keywords. If no models match the criteria, the original list is returned.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "A list of model names to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category used to determine filtering criteria."
          }
        ],
        "returns": [
          {
            "name": "filtered_models",
            "type": "list",
            "description": "A list of models that match the filtering criteria based on the category name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function handles the saving of a Gemini API key entered by the user in a Streamlit application. It retrieves the key from the session state, updates the database with the new key for the current user, clears the input field, and displays a success message to the user.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function retrieves an Ollama URL from the Streamlit session state and updates the database with the new URL for the current user. It also displays a success toast message upon completion. The function does not perform any validation on the URL format or existence.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_ollama_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The function loads chat and exchange data from a database for a given user, ensuring that data is only fetched when necessary based on session state. It initializes session state variables for chats and active chat, handles legacy support for exchanges, and ensures a default chat exists if none are present. The function interacts with database functions to retrieve chats and exchanges, and inserts a new chat if needed.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load chat and exchange data from the database."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value for a given exchange object in the database and triggers a Streamlit rerun to refresh the UI. It takes an exchange dictionary and a new feedback value, assigns the new value to the 'feedback' key of the exchange, updates the corresponding record in the database using the exchange's ID, and then calls st.rerun() to update the frontend display.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing an exchange object, expected to contain keys such as '_id' and 'feedback'."
          },
          {
            "name": "val",
            "type": "Any",
            "description": "The new feedback value to be assigned to the exchange's 'feedback' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "The function handles the deletion of an exchange from the database and updates the session state accordingly. It first deletes the exchange from the database using its ID, then checks if the exchange exists in the session state for a given chat and removes it if found. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is to be deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_exchange_by_id",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The function handles the deletion of a chat by first removing the chat data from the database using a database function, then cleaning up the session state by removing the deleted chat. If no chats remain after deletion, it creates a new default chat and sets it as the active one. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_full_chat, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from any URL present in that text. It uses regular expressions to find a URL, parses it using urllib.parse.urlparse, and then extracts the last segment of the URL path, which typically represents the repository name. If the extracted name ends with '.git', it removes the extension. If no URL is found or the path is empty, the function returns None.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string that may contain a URL from which to extract the repository name."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name from the URL, with '.git' extension removed if present."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when no URL is found in the input text or when the URL path is empty."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The function 'stream_text_generator' takes a string of text as input and yields each word from the text followed by a space, with a small delay between each yield. This creates a streaming effect where words are produced one at a time. The function uses 'time.sleep(0.01)' to introduce a brief pause between yielding each word.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string of text to be processed and streamed word by word."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text based on Mermaid code block delimiters and handles regular markdown content versus Mermaid diagram content differently. For non-Mermaid content, it either streams or displays the text using Streamlit's markdown functionality. For Mermaid content, it attempts to render the diagram using a dedicated Mermaid component, falling back to displaying the raw code if rendering fails.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "A string containing markdown-formatted text that may include Mermaid code blocks enclosed in triple backticks with 'mermaid' as the language identifier."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A boolean flag indicating whether the regular markdown text should be streamed to the UI instead of being rendered all at once."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "frontend.frontend.stream_text_generator",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function renders a chat exchange in a Streamlit interface, displaying a user question and an assistant response. It handles both regular responses and error cases, providing interactive feedback mechanisms such as like/dislike buttons, comment popovers, download options, and delete functionality. The function uses Streamlit components to build the UI and integrates with backend services for feedback handling and data updates.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the question, answer, feedback information, and unique identifier."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat session, used for deleting exchanges."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, frontend.frontend.render_text_with_mermaid",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse an Abstract Syntax Tree (AST) generated from Python source code. It collects information about imports, classes, and functions, organizing them into a structured schema. The visitor tracks the current class context to associate methods with their respective classes and maintains metadata such as line numbers and docstrings.",
        "init_method": {
          "description": "Initializes the ASTVisitor with source code, file path, and project root. It computes the module path using a helper function and sets up an empty schema structure to store collected information including imports, functions, and classes. It also initializes a variable to track the currently visited class.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The full source code of the file being analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The file path of the source code being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import nodes in the AST by extracting the names of imported modules and appending them to the schema's imports list. It then continues visiting child nodes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the AST traversal mechanism when an import node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles import-from nodes in the AST by extracting the full module paths of imported items and appending them to the schema's imports list. It then continues visiting child nodes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing an import-from statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the AST traversal mechanism when an import-from node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes class definition nodes in the AST by creating a structured representation of the class, including its identifier, name, docstring, source code segment, and line numbers. It appends this information to the schema's classes list and sets the current class context. After processing, it resets the current class context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when a class definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definition nodes in the AST. If a class context is active, it associates the function with the current class by creating a method context entry. Otherwise, it treats the function as a top-level function and adds it to the schema's functions list. It extracts function metadata such as arguments, docstring, and source code segment.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when a function definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles asynchronous function definition nodes in the AST by delegating the processing to the standard function definition handler. This ensures that async functions are treated similarly to regular functions in terms of schema collection.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method delegates to visit_FunctionDef.",
                "called_by": "This method is called by the AST traversal mechanism when an async function definition node is encountered."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.AST_Schema.path_to_module for computing module paths.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Trees (AST) and merging relationship data such as function calls, method dependencies, and class instantiations. It constructs a schema representation of the codebase that includes information about imports, functions, classes, and their contextual relationships. The class uses an ASTVisitor to traverse and extract structural elements from each file.",
        "init_method": {
          "description": "Initializes an instance of the ASTAnalyzer class. The constructor currently does not perform any initialization actions.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "Merges relationship data (such as outgoing calls and incoming references) into a full schema by updating function and class contexts with call information. It processes both functions and classes to enrich their metadata with caller/callee details and computes class dependencies based on method calls.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary representing the full schema of the repository, including file structures and AST nodes."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "A dictionary containing raw relationship data categorized under 'outgoing' and 'incoming' keys."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "dict",
                  "description": "The updated full_schema with merged relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "Analyzes a list of repository files by parsing their content into ASTs and extracting structural information using an ASTVisitor. It builds a comprehensive schema of the repository, filtering out non-Python files and handling parsing errors gracefully by logging warnings.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects containing path and content information."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "An instance of GitRepository representing the repository being analyzed."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "dict",
                  "description": "A dictionary representing the full schema of the repository, including parsed AST nodes for each file."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.AST_Schema.ASTVisitor class during the processing of each file.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.AST_Schema.ASTVisitor class for AST traversal and node extraction.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve Python import dependencies within a repository. It extends NodeVisitor to traverse AST nodes representing import statements and builds a mapping of file dependencies. The class handles both absolute and relative imports, resolving relative imports by examining module files and package __init__.py files to determine valid module or symbol names. It maintains a dictionary of import dependencies for each file, enabling tracking of which modules or symbols each file imports.",
        "init_method": {
          "description": "Initializes the FileDependencyGraph with a filename and repository root path. Sets up the instance variables to track the current file being analyzed and the root directory of the repository.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for dependencies."
            },
            {
              "name": "repo_root",
              "type": "Any",
              "description": "The root directory path of the repository being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "Resolves relative import statements by determining the actual module or symbol names that can be imported. It analyzes the import level, finds candidate files matching the current file, resolves the relative path based on the import depth, and checks whether the specified module or symbol exists either as a standalone .py file or exported via __init__.py. The method raises ImportError if no valid resolution is found.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles Import AST nodes by adding the imported module names to the import_dependencies dictionary. It ensures that the current file's dependencies are tracked and adds the base name if provided, otherwise uses the full alias name from the import statement.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "An AST node representing an import statement."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "Optional base name of the imported module to use for dependency tracking."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions according to the provided context.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes ImportFrom AST nodes, handling both absolute and relative imports. For absolute imports, it extracts the module base name and delegates to visit_Import. For relative imports, it attempts to resolve the module names using _resolve_module_name and then delegates to visit_Import for each resolved name. If resolution fails, it prints an error message.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative or absolute import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions according to the provided context.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
          "instantiated_by": "This class is not instantiated by any other class or function according to the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class serves as a centralized interface for interacting with various language models, including Google Gemini, OpenAI, custom APIs, and Ollama, to generate validated documentation for functions and classes. It manages API configuration, prompt loading, batching logic, and error handling for batched LLM interactions. The class supports multiple model types by dynamically selecting appropriate LLM clients based on the model name and handles rate limiting between batches.",
        "init_method": {
          "description": "Initializes the LLMHelper with API credentials, prompt file paths, and model configuration. It loads system prompts from specified files, configures batch settings based on the model name, and sets up appropriate LLM clients for function and class documentation generation using structured output validation.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "API key for accessing the language model service."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for function documentation generation."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for class documentation generation."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "Name of the language model to use, defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Base URL for custom API endpoints, optional."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures the batch size for processing requests based on the specified model name. It assigns different batch sizes depending on the model type, defaulting to a conservative value for unknown models.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "Name of the language model being used."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the __init__ method."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Processes a batch of function inputs to generate and validate documentation using the configured LLM. It divides the input into manageable chunks based on the configured batch size, sends them to the LLM in batches, and handles errors by filling failed items with None while preserving order.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function input models to document."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analysis results, with None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods directly.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Processes a batch of class inputs to generate and validate documentation using the configured LLM. Similar to generate_for_functions, it batches inputs, sends them to the LLM, and handles errors by filling failed items with None while preserving order.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class input models to document."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analysis results, with None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods directly.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were explicitly listed in the context.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs), including Google's Gemini, OpenAI's GPT models, custom API endpoints, and local Ollama instances. It initializes with an API key, a path to a system prompt file, and a model identifier, configuring the appropriate LLM client based on the model type. The class supports two primary interaction modes: synchronous calls via `call_llm` and streaming responses via `stream_llm`, both of which use the loaded system prompt and provided user input to generate model outputs.",
        "init_method": {
          "description": "Initializes the MainLLM instance by validating the API key, loading the system prompt from a specified file, and setting up the appropriate LLM client based on the model name. It supports multiple LLM backends including Google Generative AI, OpenAI-compatible APIs, and Ollama, with specific handling for different model types such as gemini-, gpt-, and custom models.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key used for authenticating with the LLM provider."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt used for initializing the LLM."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The identifier of the model to be used, determining the backend client to instantiate."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Optional base URL for connecting to a custom LLM endpoint."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "Sends a synchronous request to the configured LLM with a system prompt and user input, returning the generated content as a string. It handles potential exceptions during the LLM call and logs errors appropriately.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The content returned by the LLM, or None if an error occurs."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions defined in the class.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "Initiates a streaming request to the configured LLM, yielding content chunks as they become available. This allows for real-time processing of LLM responses. Errors during the streaming process are logged and yielded as error messages.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "chunk_content",
                  "type": "str",
                  "description": "Yields content chunks from the LLM or an error message if an exception occurs."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions defined in the class.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are listed for this class.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It initializes with a structured dictionary to hold extracted information and provides methods to parse and extract specific sections from these files. The class prioritizes information extraction from pyproject.toml, followed by requirements.txt, and finally README files. It handles encoding issues by cleaning content and supports case-insensitive file matching.",
        "init_method": {
          "description": "Initializes the ProjektInfoExtractor with a predefined structure for storing project information. It sets up placeholders for various project details including overview and installation instructions, and defines a constant for indicating missing information.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "Removes null bytes from content, which can occur due to encoding errors when reading files as UTF-8 instead of UTF-16. This method ensures that the content is clean before further processing.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The input string potentially containing null bytes."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "The cleaned string with null bytes removed."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by _parse_readme, _parse_toml, and _parse_requirements."
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "Searches for a file among a list of files based on a set of patterns, performing a case-insensitive match against file extensions. Returns the first matching file or None if no match is found.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file extension patterns to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[Any]",
                  "description": "The first matching file object or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by extrahiere_info."
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "Extracts text under a specified Markdown heading (indicated by ##) from the given content. It uses regular expressions to find the section and returns the content between the heading and the next heading or end of the document.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The markdown content to extract from."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords to look for as headings."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[str]",
                  "description": "The extracted text under the heading or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by _parse_readme."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "Parses the content of a README file to extract project overview and installation information. It identifies the title, description, key features, tech stack, status, setup instructions, and quick start guide using regex and helper methods.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content and _extrahiere_sektion_aus_markdown.",
                "called_by": "This method is called by extrahiere_info."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "Parses the content of a pyproject.toml file to extract project metadata such as name, description, and dependencies. It handles potential TOML parsing errors and updates the internal info structure accordingly.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content.",
                "called_by": "This method is called by extrahiere_info."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "Parses the content of a requirements.txt file to extract dependency information. It filters out comments and empty lines, and only populates dependencies if they haven't already been set by a previous parser.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content.",
                "called_by": "This method is called by extrahiere_info."
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "Orchestrates the extraction of project information by finding relevant files and delegating parsing tasks to appropriate methods. It prioritizes pyproject.toml over requirements.txt and README files, formats dependencies, and derives a default title from the repository URL if necessary.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository to derive a title from if needed."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information."
                }
              ],
              "usage_context": {
                "calls": "Calls _finde_datei, _parse_toml, _parse_requirements, and _parse_readme.",
                "called_by": "This method is called by the main application logic."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on standard library modules like re, os, and tomllib, as well as typing annotations from typing module.",
          "instantiated_by": "This class is instantiated by the main application logic."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze Python source code using the AST (Abstract Syntax Tree) module to construct a directed graph representing function call relationships. It tracks local definitions, imports, and class contexts to resolve function names and build a comprehensive call graph. The class extends ast.NodeVisitor to traverse the AST nodes and records edges between callers and callees based on function calls.",
        "init_method": {
          "description": "Initializes the CallGraph with a filename and sets up internal data structures including tracking for current function and class, local definitions, a NetworkX DiGraph for the call graph, import mappings, a set of function names, and a dictionary of edges.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for call graph construction."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "Recursively extracts the dotted name components from an AST node representing a function call. It handles different types of AST nodes like ast.Call, ast.Name, and ast.Attribute to build a list of name parts that represent the full qualified name of the called entity.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "An AST node representing a function call or attribute access."
                }
              ],
              "returns": [
                {
                  "name": "parts",
                  "type": "list[str]",
                  "description": "A list of strings representing the dotted name components of the function call."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the _resolve_all_callee_names method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "Resolves a list of dotted name components into fully qualified names by checking local definitions, import mappings, and constructing appropriate names based on the current class context. It processes each component list to generate a list of resolved names suitable for use in the call graph.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists containing name components for potential callees."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of fully qualified names resolved from the input components."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _recursive_call method to extract name components.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "Constructs a fully qualified name for a function or method by combining the filename, optional class name, and base name. This helps in uniquely identifying functions within the scope of the file and class hierarchy.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name of the function or method."
                },
                {
                  "name": "class_name",
                  "type": "Optional[str]",
                  "description": "The name of the class if the function is a method."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "A fully qualified name constructed from the filename, class name (if provided), and base name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the visit_FunctionDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "Determines the current caller's name based on whether there is an active function context. If a function is currently being visited, it returns the function name; otherwise, it returns a placeholder indicating global scope or the filename.",
              "parameters": [
                {
                  "name": "self",
                  "type": "CallGraph",
                  "description": "The instance of the CallGraph class."
                }
              ],
              "returns": [
                {
                  "name": "caller_name",
                  "type": "str",
                  "description": "The name of the current caller or a placeholder if no function is active."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST nodes representing import statements. It maps imported module aliases to their actual module names and stores these mappings in the import_mapping dictionary for later resolution of function names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversing the AST.",
                "called_by": "This method is called during AST traversal when an import statement is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles AST nodes representing 'from ... import ...' statements. It extracts the module name and maps imported names to their respective modules, storing these mappings in the import_mapping dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversing the AST.",
                "called_by": "This method is called during AST traversal when a 'from ... import ...' statement is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes AST nodes representing class definitions. It temporarily sets the current class context while visiting the class body and restores the previous class context after processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversing the AST.",
                "called_by": "This method is called during AST traversal when a class definition is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes AST nodes representing function definitions. It registers the function in local definitions, adds it to the call graph, and manages the current function context during traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls _make_full_name to construct the full name of the function and generic_visit to continue traversing the AST.",
                "called_by": "This method is called during AST traversal when a function definition is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles AST nodes representing asynchronous function definitions. It delegates the processing to visit_FunctionDef since async functions are treated similarly to regular functions in terms of call graph construction.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls visit_FunctionDef to handle the function definition.",
                "called_by": "This method is called during AST traversal when an async function definition is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Processes AST nodes representing function calls. It identifies the caller, resolves the callee names, and records the edge in the call graph by updating the edges dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "An AST node representing a function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls _current_caller to get the caller name, _recursive_call to extract name components, and _resolve_all_callee_names to resolve callee names.",
                "called_by": "This method is called during AST traversal when a function call is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "Handles AST nodes representing conditional statements. Special handling is applied for if statements testing '__name__ == '__main__'' to treat the block as a main block context during traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "An AST node representing a conditional statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversing the AST.",
                "called_by": "This method is called during AST traversal when an if statement is encountered."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the ast module for parsing Python code, networkx for graph representation, and typing.Dict for type annotations.",
          "instantiated_by": "This class is instantiated by other components in the system that require call graph analysis of Python files."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as content and size to optimize performance by only loading data when accessed. The class provides properties for accessing the Git blob, content, and size of the file, along with utility methods for word count analysis and dictionary serialization.",
        "init_method": {
          "description": "Initializes a RepoFile object with a file path and a commit tree. It sets up internal attributes to store the file path, the Git tree object, and placeholders for the blob, content, and size which are lazily loaded.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "A property that lazily loads and returns the Git blob object associated with the file. If the blob hasn't been loaded yet, it attempts to retrieve it from the commit tree using the stored file path. If the file is not found in the tree, it raises a FileNotFoundError.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "A property that lazily loads and returns the decoded content of the file. It reads the data stream from the blob and decodes it as UTF-8 text, ignoring encoding errors. If the content has not yet been loaded, it fetches it from the blob.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "A property that lazily loads and returns the size of the file in bytes. It retrieves the size directly from the blob object. If the size has not yet been loaded, it fetches it from the blob.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "An example analysis method that counts the number of words in the file's content. It splits the content on whitespace and returns the length of the resulting list.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The total number of words in the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Provides a string representation of the RepoFile object, useful for debugging and logging purposes. It returns a formatted string showing the file path.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr_string",
                  "type": "str",
                  "description": "A string representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Converts the RepoFile object into a dictionary format, including basic file information such as path, name, size, and type. Optionally includes the file's content if requested.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "If True, includes the file's content in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary containing file metadata and optionally the content."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the 'tempfile', 'git.Repo', 'git.GitCommandError', 'logging', and 'os' modules.",
          "instantiated_by": "This class is not instantiated anywhere according to the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing functionality to access files within the repository. It supports retrieving all files as RepoFile objects, constructing a hierarchical file tree representation, and cleaning up temporary resources upon closing. The class implements context manager protocols (__enter__ and __exit__) to facilitate automatic resource management.",
        "init_method": {
          "description": "Initializes a GitRepository instance by cloning the specified repository URL into a temporary directory. It sets up necessary attributes such as the repository URL, temporary directory path, and references to the cloned repository and its latest commit. If cloning fails, it raises a RuntimeError after cleaning up any temporary resources.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "Retrieves a list of all files in the repository and creates RepoFile objects for each file. These objects are stored in the instance's 'files' attribute and returned. The method uses git ls-files to obtain the list of tracked files.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile constructor for each file path retrieved from the repository.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "Deletes the temporary directory and its contents associated with the repository. This method is typically invoked when the repository is no longer needed to free up system resources.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "Enables the use of the GitRepository instance in a 'with' statement, returning itself so that it can be used within the context block.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The GitRepository instance itself."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "Implements the context manager protocol's exit method, ensuring that the close() method is called when exiting a 'with' block, thereby cleaning up temporary resources.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "exc_type",
                  "type": "Any",
                  "description": "Exception type if an exception occurred in the with block."
                },
                {
                  "name": "exc_val",
                  "type": "Any",
                  "description": "Exception value if an exception occurred in the with block."
                },
                {
                  "name": "exc_tb",
                  "type": "Any",
                  "description": "Exception traceback if an exception occurred in the with block."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the close() method.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "Constructs a hierarchical tree representation of the repository's file structure. If no files have been loaded yet, it first retrieves all files using get_all_files. Then, it iterates through the files and builds a nested dictionary structure reflecting the directory hierarchy, including file details.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Flag indicating whether to include file content in the returned tree nodes."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the hierarchical file tree structure."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.getRepo.RepoFile for creating file representations.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze Python project structures by identifying and mapping relationships between functions, classes, and methods across multiple Python files. It performs static analysis on a given project root directory, collects definitions of functions and classes, resolves inter-file call relationships, and provides a structured representation of these relationships. The analyzer uses AST parsing to traverse Python files and maintains internal data structures to store definitions and call graphs.",
        "init_method": {
          "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including dictionaries for storing definitions, call graphs, and file ASTs, along with a set of directories to ignore during analysis.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory path of the Python project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "The main analysis method that orchestrates the process of finding Python files, collecting definitions from those files, resolving inter-file calls, and cleaning up temporary data structures before returning the final call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "defaultdict(list)",
                  "description": "A dictionary mapping callee identifiers to lists of caller information."
                }
              ],
              "usage_context": {
                "calls": "This method calls `_find_py_files` to locate Python files and then iterates over them to call `_collect_definitions` and `_resolve_calls`.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "Transforms the internal call graph into a more structured format with separate mappings for outgoing and incoming relationships, sorting the sets of related identifiers for consistent output.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing 'outgoing' and 'incoming' keys mapping identifiers to sorted lists of related identifiers."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "Recursively walks through the project root directory, excluding specified ignored directories, and collects paths to all Python (.py) files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list[str]",
                  "description": "A list of absolute paths to Python files found in the project root."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods.",
                "called_by": "This method is called by `analyze`."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "Parses a Python file using AST, identifies function and class definitions, and stores their metadata including file location and type in the internal definitions dictionary. It also determines whether functions are methods based on their parent class context.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls `path_to_module` to convert file paths to module names.",
                "called_by": "This method is called by `analyze`."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "Traverses the AST to find the parent node of a given AST node, which is used to determine if a function is defined within a class.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The AST tree to search within."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node whose parent is to be found."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST or None",
                  "description": "The parent AST node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods.",
                "called_by": "This method is called by `_collect_definitions`."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "Processes a Python file's AST using a CallResolverVisitor to identify and resolve inter-file calls, updating the internal call graph with the results.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file being processed for call resolution."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method instantiates and uses `CallResolverVisitor` to visit the AST and collect call information.",
                "called_by": "This method is called by `analyze`."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.relationship_analyzer.CallResolverVisitor and backend.relationship_analyzer.path_to_module.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is an AST (Abstract Syntax Tree) visitor designed to analyze Python code and resolve call relationships between functions, methods, and classes. It tracks the current execution context including class names, function names, and module paths to accurately map where calls originate and where they point to. It maintains mappings of scope and instance types to resolve qualified names and records call information in a structured format.",
        "init_method": {
          "description": "Initializes the CallResolverVisitor with the file path, project root, and definitions dictionary. It sets up internal tracking structures such as scope, instance types, and call records, and determines the module path based on the file path and project root.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The path to the Python file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project, used to compute relative module paths."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary mapping qualified names to their definitions, used to validate and resolve call targets."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles the visitation of class definitions in the AST. It updates the current class name context before visiting child nodes and restores the previous class name after processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing the class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definitions in the AST. It manages the caller name context by setting the full identifier for the function, which includes the module, class (if applicable), and function name, before traversing child nodes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing the function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes function calls in the AST. It resolves the qualified name of the called function and checks if it exists in the definitions. If so, it records the call with metadata about the caller, including file, line number, and caller type.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing the function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import statements in the AST. It adds imported names to the scope mapping, allowing resolution of qualified names later during call analysis.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing the import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes 'from ... import ...' statements in the AST. It correctly resolves the full module path for imports and maps the imported names to their qualified paths in the scope.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing the 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Handles assignment statements in the AST. Specifically, it identifies assignments to instances of classes by checking if the assigned value is a call to a known class and stores the mapping of variable names to qualified class names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node representing the assignment statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the qualified name of a function call based on the function node. It handles both direct name references and attribute access (e.g., obj.method). It uses the scope and instance types to determine the fully qualified path of the function.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.expr",
                  "description": "The AST node representing the function being called."
                }
              ],
              "returns": [
                {
                  "name": "qualified_name",
                  "type": "str or None",
                  "description": "The resolved qualified name of the function, or None if it cannot be resolved."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the visit_Call method to resolve the qualified name of a function call."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.relationship_analyzer.path_to_module function to compute module paths.",
          "instantiated_by": "This class is not instantiated by any other code within the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the metadata of a single function parameter. It encapsulates three core attributes: the parameter's name, its type, and a descriptive explanation. This class ensures consistent structure and data integrity for parameter descriptions within the system.",
        "init_method": {
          "description": "The constructor initializes a ParameterDescription instance with required fields for describing a function parameter. It inherits validation and serialization capabilities from pydantic.BaseModel.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not explicitly instantiated by any other component listed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model designed to represent and validate the description of a function's return value. It encapsulates three essential pieces of information about a return value: its name, type, and a textual description. This class ensures data integrity and structure for return value metadata, making it suitable for use in API documentation, code analysis tools, or any system requiring standardized return value specifications.",
        "init_method": {
          "description": "The constructor initializes the ReturnDescription instance with three required fields: name, type, and description. These fields are standard attributes that define the characteristics of a function's return value.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The data type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the source file.",
          "instantiated_by": "This class is not instantiated by any other components as indicated by the context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model designed to represent and validate the calling context of a function, specifically capturing information about what functions are called and by whom. It provides a structured way to define and enforce the expected format of usage context data.",
        "init_method": {
          "description": "Initializes a new instance of the UsageContext class with the specified 'calls' and 'called_by' attributes.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string describing the functions or methods that are called within the context."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string describing the function or method that calls the current context."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed for this class.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed information about a function's purpose, parameters, return values, and usage context. It serves as a structured representation for documenting function signatures and behavior, making it easier to analyze and communicate function details within a codebase.",
        "init_method": {
          "description": "The constructor initializes the FunctionDescription instance with required fields: overall description, a list of parameter descriptions, a list of return value descriptions, and a usage context object. It leverages Pydantic's BaseModel for data validation and serialization.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class is a Pydantic model designed to represent the complete JSON schema for a function. It serves as a structured data container that holds essential information about a function, including its unique identifier, a detailed description, and an optional error field. This class is intended to provide a standardized format for describing functions within a system, facilitating consistent data handling and validation.",
        "init_method": {
          "description": "Initializes a FunctionAnalysis instance with an identifier, a function description, and an optional error message. The constructor sets up the basic structure required to represent a function's metadata in a standardized way.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object containing detailed information about the function's purpose, parameters, and behavior."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store error messages related to the function, defaulting to None."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It encapsulates a textual description of the constructor's purpose and a list of parameters it accepts. This class serves as a structured representation for documenting constructor details, likely used in API documentation or code analysis tools.",
        "init_method": {
          "description": "Initializes a ConstructorDescription instance with a description string and a list of ParameterDescription objects. The class inherits from pydantic.BaseModel, enabling validation and serialization capabilities.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the constructor's purpose."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing the parameters accepted by the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components as indicated by the context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model designed to encapsulate information about a class's external dependencies and the entities that instantiate it. It serves as a structured representation of metadata related to class usage and integration within a system.",
        "init_method": {
          "description": "Initializes a ClassContext instance with two string attributes: 'dependencies' and 'instantiated_by'. These fields store information about the class's external dependencies and the entities responsible for its instantiation.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string describing the entities or components that instantiate the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to encapsulate a comprehensive analysis of a Python class. It holds structured information about the class's overall purpose, its constructor details, the methods it contains, and its usage context. This class serves as a standardized format for representing detailed metadata and structural analysis of classes within a codebase.",
        "init_method": {
          "description": "Initializes an instance of the ClassDescription class with fields for overall purpose, constructor description, list of method analyses, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose and role of the class being analyzed."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An instance of ConstructorDescription that details the initialization process and parameters of the analyzed class."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects, each representing a detailed breakdown of a method within the analyzed class."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An instance of ClassContext providing information on how the class is used and its dependencies."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any external modules beyond its base Pydantic model and the types it references.",
          "instantiated_by": "This class is not instantiated by any other components within the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as the primary data model for representing the complete JSON schema of a class. It encapsulates essential information about a class including its identifier, a detailed description, and an optional error field. This class is designed to provide a standardized structure for documenting class metadata and associated descriptions within a larger system.",
        "init_method": {
          "description": "Initializes a new instance of the ClassAnalysis class with required fields for the identifier and description, along with an optional error field.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An instance of ClassDescription providing detailed information about the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store any error messages related to the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It serves as a data structure for recording and organizing call-related metadata.",
        "init_method": {
          "description": "Initializes a CallInfo instance with file, function name, call mode, and line number attributes.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file path where the call occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that made the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, such as 'method', 'function', or 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number in the file where the call occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were identified for this class.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to represent structured context for analyzing a function. It encapsulates two key pieces of information: a list of function names that the analyzed function calls, and a list of CallInfo objects indicating which functions call the analyzed function. This model serves as a data structure for documenting and passing around metadata about function call relationships within a codebase.",
        "init_method": {
          "description": "The constructor initializes the FunctionContextInput model with two fields: 'calls', which is a list of strings representing function names called by the analyzed function, and 'called_by', which is a list of CallInfo objects describing the callers of the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the names of functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects that describe the functions which call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed for this class.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class serves as a data structure to encapsulate all necessary inputs required for generating a FunctionAnalysis object. It defines the expected fields including the mode, identifier, source code, imports, and contextual information. This class leverages Pydantic's BaseModel for data validation and serialization, ensuring that instances conform to the specified schema.",
        "init_method": {
          "description": "Initializes a FunctionAnalysisInput instance with the required fields: mode, identifier, source_code, imports, and context. The mode is constrained to the literal value 'function_analysis', ensuring strict adherence to the intended usage pattern.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "A literal string value that must be 'function_analysis' to indicate the correct mode of operation."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements used in the function's source code."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "An object containing contextual information about the function's environment and usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel and related typing modules for data validation and type hinting.",
          "instantiated_by": "This class is instantiated by components responsible for preparing input data for function analysis tasks."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to represent structured context information for a class's methods. It encapsulates details such as the method's identifier, the methods it calls, the methods that call it, its arguments, and its docstring. This class serves as a data transfer object for method context metadata, facilitating the documentation and analysis of method interdependencies within a class.",
        "init_method": {
          "description": "The constructor initializes the MethodContextInput instance with fields for storing method context information including its identifier, a list of methods it calls, a list of CallInfo objects representing methods that call it, a list of argument names, and an optional docstring.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the identifiers of methods called by this method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing methods that call this method."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of strings representing the argument names of the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "An optional string containing the docstring of the method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to encapsulate structured context information for analyzing a class. It holds three main pieces of information: a list of dependencies, a list of call information for instances where the class is instantiated, and a list of method context inputs that describe the methods within the class.",
        "init_method": {
          "description": "The constructor initializes the ClassContextInput instance with three attributes: dependencies, instantiated_by, and method_context. These attributes are intended to store contextual metadata about a class being analyzed.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of strings representing the dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects indicating where and how the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects describing the methods within the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class serves as a data structure for encapsulating the necessary inputs required to generate a ClassAnalysis object. It defines the expected fields including the mode of operation, a unique identifier for the class, the source code of the class being analyzed, a list of import statements, and contextual information about the class.",
        "init_method": {
          "description": "Initializes the ClassAnalysisInput instance with the specified parameters, setting up the required fields for class analysis.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal[\"class_analysis\"]",
              "description": "A literal string indicating the mode of operation, specifically set to 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements associated with the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "An object containing contextual information about the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on pydantic.BaseModel for data validation and typing modules for type hints.",
          "instantiated_by": "This class is instantiated by components responsible for generating ClassAnalysis objects based on input parameters."
        }
      },
      "error": null
    }
  }
}