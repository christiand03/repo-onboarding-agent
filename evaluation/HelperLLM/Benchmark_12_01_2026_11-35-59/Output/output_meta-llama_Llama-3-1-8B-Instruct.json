{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "This function converts a file path to a Python module path. It takes a file path and a project root as input, and returns the corresponding module path. If the file path is a Python file, it removes the .py extension. If the module path ends with .__init__, it removes the last 9 characters.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The file path to be converted."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The project root directory."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The converted module path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function builds a directed graph representing the file dependencies within a given repository. It takes a filename, an Abstract Syntax Tree (AST), and the repository root as input. The function uses the `networkx` library to create a directed graph and traverses the AST to identify import dependencies between files.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which to build the dependency graph."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The Abstract Syntax Tree representing the code in the repository."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies within the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.FileDependencyGraph",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between files in a Git repository. It iterates over all files in the repository, excluding non-Python files, and uses the `build_file_dependency_graph` function to create a graph for each Python file. The nodes and edges of these graphs are then added to a global graph, which is returned at the end.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository for which to build the dependency graph."
          }
        ],
        "returns": [
          {
            "name": "nx.DiGraph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the dependencies between files in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.File_Dependency.build_file_dependency_graph`.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves all temporary files within a specified directory. It uses the pathlib library to resolve the directory path and recursively search for files with the '.py' extension. The function returns a list of relative paths to these files.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory to search for temporary files."
          }
        ],
        "returns": [
          {
            "name": "list[Path]",
            "type": "list[Path]",
            "description": "A list of relative paths to temporary files within the specified directory."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "This function orchestrates the analysis of various functions within the system, utilizing the LLMHelper class to generate documentation for each function.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "LLMHelper, ClassAnalysisInput, ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "This function creates a safe version of a directed graph by renaming its nodes and then writes the safe graph to a file in the DOT format. The safe graph is created by mapping each node to a new name in the format 'n<i>', where <i> is the node's original index. The original node labels are then stored in the 'label' attribute of the corresponding safe node. The safe graph is then written to the specified output path using the NetworkX library's write_dot function.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input graph to be made safe."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The path where the safe graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "This function builds a filtered call graph by parsing all Python files in a Git repository and extracting the call relationships between functions. It filters out calls to external functions and only includes calls to self-written functions. The resulting graph is a directed graph where each node represents a function and each edge represents a call relationship between two functions.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "The Git repository to build the call graph for."
          }
        ],
        "returns": [
          {
            "name": "nx.DiGraph",
            "type": "nx.DiGraph",
            "description": "The filtered call graph as a directed graph."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The `wrap_cdata` function takes a string `content` and returns a string wrapped in CDATA tags. It uses an f-string to format the output. This function is designed to safely include arbitrary content within a CDATA section, which can help prevent XML parsing errors. The function does not perform any error checking on the input content.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "This function extracts text and handles images by decoding Base64 to bytes from a list of outputs. It returns a list of text strings or placeholders. The function iterates over each output, checks its type, and processes it accordingly. If the output is of type 'display_data' or 'execute_result', it checks if the output has data and processes it. If the output is of type 'stream', it appends the output text to the extracted XML snippets. If the output is of type 'error', it appends the error message to the extracted XML snippets. The function also has a helper function 'process_image' to handle images.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of outputs to be processed."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list of images to be processed."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of text strings or placeholders extracted from the outputs."
          }
        ],
        "usage_context": {
          "calls": "This function calls process_image.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "This function processes an image by decoding its base64 string and appending it to a list of images. If the image cannot be decoded, it returns an error message. If the mime type is not found in the data, it returns None.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The mime type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str",
            "description": "The result of the image processing, which can be an image placeholder, an error message, or None."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "This function takes a notebook file content as input, attempts to parse it as a JSON/Notebook, and returns the converted XML content along with extracted images. If the file cannot be parsed, it returns an error message and an empty list of images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the notebook file to be converted to XML."
          }
        ],
        "returns": [
          {
            "name": "xml_content",
            "type": "str",
            "description": "The converted XML content of the notebook file."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted images from the notebook file."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.extract_output_content and backend.converter.wrap_cdata.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes Jupyter notebooks from a repository by converting them to XML and storing the results in a dictionary. It iterates over the notebook files, logs information about each file, and returns a dictionary with the converted XML and images for each notebook. The function uses the `convert_notebook_to_xml` function to perform the conversion.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of repository files to process."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary with the converted XML and images for each notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "This function creates a bar chart comparing the number of JSON and TOON tokens and saves it to a specified output path. The chart displays the token comparison and the savings percentage. The function uses matplotlib to create the chart and save it to a file.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The savings percentage."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "This function calculates the net time by subtracting the sleep times for rate limits from the total duration. It is used for models starting with 'gemini-'.",
        "parameters": [
          {
            "name": "start_time",
            "type": "datetime.datetime",
            "description": "The start time of the operation."
          },
          {
            "name": "end_time",
            "type": "datetime.datetime",
            "description": "The end time of the operation."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The batch size."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float",
            "description": "The net time after subtracting sleep times."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is the entry point of the backend. It orchestrates the entire process, from input analysis to final report generation. It uses various helper functions and classes to extract information from the input, analyze the repository, and generate documentation. The function takes in several parameters, including the input, API keys, model names, and a status callback function. It returns a dictionary containing the analysis results.",
        "parameters": [
          {
            "name": "input",
            "type": "object",
            "description": "The input to be analyzed."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary containing model names for various services."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "A callback function to update the status."
          }
        ],
        "returns": [
          {
            "name": "analysis_results",
            "type": "dict",
            "description": "A dictionary containing the analysis results."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, and schemas.types.MethodContextInput.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The `update_status` function updates the status by calling the `status_callback` function if it exists, and logs the message using the `logging` module.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be logged and passed to the `status_callback` function."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "This function orchestrates the notebook workflow, which involves cloning a repository, extracting basic project information, and generating reports for each notebook using a specified LLM model. It takes in input, API keys, and a model name, and returns a final report and metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input to be processed, which may contain a repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary of API keys, including 'gpt', 'gemini', 'scadsllm', and 'ollama'."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the LLM model to be used for generating reports."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function for updating the status."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated by the notebook workflow."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary of metrics, including helper time, main time, total time, helper model, main model, json tokens, toon tokens, and savings percent."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, and backend.main.update_status.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The `gemini_payload` function generates a payload for the Gemini protocol by parsing the provided XML content and images. It extracts context information, notebook XML structure, and image URLs from the input data. The function returns a list of payload content items, including text and image URLs.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "object",
            "description": "Basic information about the project or notebook."
          },
          {
            "name": "nb_path",
            "type": "string",
            "description": "The current notebook path."
          },
          {
            "name": "xml_content",
            "type": "string",
            "description": "The XML content of the notebook."
          },
          {
            "name": "images",
            "type": "list",
            "description": "A list of image data, where each item contains the image data and its MIME type."
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "list",
            "description": "A list of payload content items, including text and image URLs."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "This function converts a file path to a Python module path. It takes a file path and a project root as input, and returns the corresponding module path. If the file path is a Python file, the function removes the .py extension. If the resulting module path ends with .__init__, the function removes the last 9 characters.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The file path to be converted to a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The project root directory."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The module path corresponding to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The `encrypt_text` function takes a string input and returns the encrypted text using the `cipher_suite` object. It returns the original input if the text or cipher suite is invalid. The function uses the `cryptography.fernet.Fernet` library for encryption.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text if the input is valid, otherwise the original input."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The `decrypt_text` function decrypts a given text using a cipher suite. If the text is empty or the cipher suite is not available, it returns the original text. If decryption fails, it also returns the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text, or the original text if decryption fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "This function inserts a new user into the database with the provided username, name, and password. It uses the `stauth.Hasher.hash` function to hash the password before insertion. The function returns the ID of the newly inserted user.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the new user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The name of the new user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password of the new user."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted user."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "The `fetch_all_users` function retrieves all users from the database by querying the `dbusers` collection.",
        "parameters": [],
        "returns": [
          {
            "name": "all_users",
            "type": "list",
            "description": "A list of all users in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The `fetch_user` function retrieves a user from the database by their username. It uses the `dbusers` collection to find a document with a matching `_id` field. If a match is found, the function returns the entire document. Otherwise, it returns `None`. The function does not perform any error handling or validation on the input `username`.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to search for in the database."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict",
            "description": "The entire document from the `dbusers` collection that matches the input `username`, or `None` if no match is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name of a user in the database by setting the 'name' field to the provided 'new_name' value. It uses the MongoDB update_one method to achieve this. The function takes two parameters: 'username' and 'new_name', both of which are strings. The function does not return any additional information beyond the count of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The current username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates the Gemini API key for a given username in the database by encrypting the key and then using the `dbusers.update_one` method to update the document. The function takes two parameters: `username` and `gemini_api_key`, both of which are strings. It returns the number of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to update the Gemini API key for."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The Gemini API key to be encrypted and updated."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls `database.db.encrypt_text`.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "Updates the GPT API key for a specified user in the database by encrypting the provided key and storing it in the user's document. The function uses the `encrypt_text` function from the `database.db` module to encrypt the key. If the user already exists in the database, the function updates their document with the new encrypted key. If the user does not exist, the function creates a new document with the encrypted key.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose GPT API key is to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The GPT API key to be encrypted and stored in the user's document."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls `database.db.encrypt_text`.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "Updates the Ollama base URL for a specified user in the database. This function uses the MongoDB update_one method to modify the user document. The update operation sets the ollama_base_url field to the provided value, stripping any leading or trailing whitespace. The function returns the number of documents modified.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to update."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new Ollama base URL to set for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "Updates the opensrc_api_key for a given username in the database by encrypting the provided API key and storing it in the dbusers collection. The function uses the pymongo library to interact with the MongoDB database. The modified count is returned as a result.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to update the opensrc_api_key for."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The opensrc_api_key to be encrypted and updated in the database."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "Updates the opensrc_base_url for a specified username in the database. This function takes a username and a new opensrc_base_url, strips any leading/trailing whitespace from the URL, and updates the corresponding document in the database. The function returns the number of documents modified.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to update the opensrc_base_url for."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new opensrc_base_url to update for the specified username."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The `fetch_gemini_key` function retrieves the Gemini API key associated with a given username from the database. It uses the `dbusers` collection to find the user document and returns the `gemini_api_key` field if the user exists. If the user does not exist, it returns `None`. The function takes a `username` parameter, which is expected to be a string.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to retrieve the Gemini API key for."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The Gemini API key associated with the given username, or `None` if the user does not exist."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "This function fetches the Ollama URL associated with a given username from a MongoDB database. It uses the `dbusers` collection to find the user document and returns the `ollama_base_url` field if the user exists. If the user does not exist, it returns `None`. The function takes a `username` parameter and relies on the `dbusers` collection being properly configured and populated.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to fetch the Ollama URL for."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama URL associated with the given username, or `None` if the user does not exist."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The `fetch_gpt_key` function retrieves a GPT API key from a MongoDB database based on a provided username. It uses the `dbusers` collection to find the user document and returns the `gpt_api_key` field if the user exists. If the user is not found, it returns `None`. The function relies on the `pymongo` library to interact with the MongoDB database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to search for in the database."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the provided username, or `None` if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "The `fetch_opensrc_key` function retrieves the Open Source API key for a given username from the database. It uses the `dbusers` collection to find the user document and returns the `opensrc_api_key` field if the user exists. If the user does not exist, it returns `None`. This function is designed to handle user authentication and API key management.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the Open Source API key."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The Open Source API key for the given username, or `None` if the user does not exist."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function fetches the Open Source URL associated with a given username from the database. It uses the `dbusers` collection to find the user document and returns the `opensrc_base_url` field if the user exists. If the user does not exist, it returns `None`. The function takes a `username` parameter of type `str` and does not return any value.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to fetch the Open Source URL for."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The Open Source URL associated with the given username, or `None` if the user does not exist."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "This function deletes a user from the database by their username. It uses the pymongo library to interact with the MongoDB database. The function takes a username as input and returns the number of documents deleted. If the username does not exist in the database, it will return 0.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted"
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves decrypted API keys for a given username from a MongoDB database. It first finds the user in the database, then decrypts the API keys and base URLs associated with the user. If the user is not found, it returns None for all API keys and URLs.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve decrypted API keys."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The decrypted Ollama base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The decrypted OpenSRC base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls `database.db.decrypt_text`.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "This function creates a new chat entry by generating a unique ID, storing the username, chat name, and creation time, and then inserting this data into the 'chats' collection of the MongoDB database. The function returns the ID of the newly inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user creating the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "str",
            "description": "The ID of the newly inserted document in the 'chats' collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "This function fetches all defined chats for a given user. It retrieves the chats from the database, sorting them in ascending order by creation date.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chats for the specified user, sorted by creation date."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks if a chat exists in the database for a given username and chat name. It uses the `dbchats` collection to find a document matching the specified username and chat name. If a matching document is found, the function returns `True`; otherwise, it returns `False`. The function relies on the `dbchats` collection being properly configured and populated with relevant data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to search for in the database."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to search for in the database."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "bool",
            "description": "Whether a chat exists in the database for the given username and chat name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and all associated exchanges by updating the chat's entry in the database and modifying the chat name in all relevant exchange messages. It takes three parameters: the username of the chat owner, the old name of the chat, and the new name of the chat. The function returns the number of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the chat owner."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The old name of the chat."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name of the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of modified documents."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "This function inserts a new exchange into the database. It takes in various parameters such as question, answer, feedback, username, and chat name. The function generates a unique ID for the exchange and creates a dictionary with the provided information. It then attempts to insert the dictionary into the database using the `dbexchanges.insert_one` method. If successful, it returns the new ID; otherwise, it returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer to the question."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "The feedback provided."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main used."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "The total time."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "The helper time."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "The main time."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of Toon tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The savings percentage."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique ID of the newly inserted exchange."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function fetches exchanges by a given username from the database. It sorts the exchanges by their creation time in ascending order. The function takes a username as input and returns a list of exchanges.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch exchanges."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges sorted by their creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function fetches exchanges by chat from the database. It takes a username and a chat name as input, and returns a list of exchanges sorted by creation date in ascending order. The function uses the pymongo library to interact with the MongoDB database. If the specified username and chat name do not exist in the database, the function will return an empty list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchanges by."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to filter exchanges by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges sorted by creation date in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "This function updates the feedback of an exchange in the database by setting the feedback field to a specified value. It uses the MongoDB update_one method to perform the update. The function takes two parameters: the exchange ID and the new feedback value. It returns the number of documents modified.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "int",
            "description": "The ID of the exchange to update"
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The new feedback value to set for the exchange"
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message for a specific exchange in the database. It takes an exchange ID and a new feedback message as input, and returns the number of documents modified. The function uses the MongoDB update_one method to update the document, and the modified_count property to get the number of documents modified.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "int",
            "description": "The ID of the exchange to update."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to update."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "Deletes a document from the exchanges collection in the database by its ID. The function uses the pymongo library to interact with the MongoDB database. It takes a string parameter representing the ID of the document to be deleted and returns the number of documents deleted.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the document to be deleted from the exchanges collection."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the exchanges collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "This function deletes a full chat, including all related exchanges, to maintain consistency between the frontend and backend. It takes a username and a chat name as input and returns the number of deleted documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the chat owner."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of deleted documents."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The clean_names function takes a list of model names as input, splits each name at the '/' character, and returns a new list containing the last part of each split name.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list",
            "description": "A list of model names"
          }
        ],
        "returns": [
          {
            "name": "cleaned_names",
            "type": "list",
            "description": "A list of cleaned model names"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "This function filters a list of models based on a selected category. If the category is 'STANDARD', it returns only the models that are also in the STANDARD_MODELS list. Otherwise, it returns the models that contain any of the keywords associated with the category.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered list",
            "type": "list",
            "description": "The filtered list of models."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "The `save_gemini_cb` function is a callback that saves the Gemini key to the database. It retrieves the new key from the session state, updates the Gemini key in the database, and clears the session state. Finally, it displays a toast message indicating that the key has been saved successfully.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "The `save_ollama_cb` function updates the Ollama URL in the database and displays a toast notification when a new URL is provided. It retrieves the new URL from the session state and uses it to update the Ollama URL in the database. If the new URL is not empty, it calls the `update_ollama_url` function from the `database.db` module to update the Ollama URL.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "The function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other function."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "This function loads data from the database for a given user. It first checks if the user has already been loaded, and if not, it fetches the user's chats and exchanges from the database. It then populates the `st.session_state.chats` dictionary with the fetched data. If no chats or exchanges are found, it creates a default chat and inserts it into the database. Finally, it sets the `st.session_state.loaded_user` variable to the current user.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to load data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls `database.db.fetch_chats_by_user`, `database.db.fetch_exchanges_by_user`, and `database.db.insert_chat`.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback of an exchange in the database and reruns the Streamlit application. It takes an exchange object and a new feedback value as input. The function modifies the exchange object in place by adding the new feedback value, then updates the database with the new feedback. Finally, it reruns the Streamlit application using the `st.rerun()` function.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "The exchange object to be updated."
          },
          {
            "name": "val",
            "type": "any",
            "description": "The new feedback value to be added to the exchange object."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "This function handles the deletion of an exchange in a chat. It deletes the exchange from the database and removes it from the chat's exchanges list if it exists. The function then reruns the Streamlit application to reflect the changes.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat where the exchange is to be deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange to be deleted, including its ID."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "This function handles the deletion of a chat by removing it from the database and updating the application state. It ensures that the active chat is updated accordingly and a new empty chat is created if all chats are deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user deleting the chat"
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted"
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_full_chat and database.db.insert_chat.",
          "called_by": "This function is called by unknown functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "This function extracts the repository name from a given text, typically a URL. It uses regular expressions to find the URL, parses it using the `urlparse` function, and then extracts the path. The repository name is assumed to be the last part of the path, and it is stripped of the `.git` extension if present. If no URL is found, the function returns `None`.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text from which to extract the repository name."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name, or `None` if no URL is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The `stream_text_generator` function takes a string of text as input, splits it into individual words, and yields each word with a trailing space. It introduces a 10ms delay between each word.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be processed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is used by no other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "This function renders Markdown text with embedded Mermaid diagrams. It splits the input text into parts, processes each part, and uses Streamlit to display the results. If a part is a Mermaid code block, it is rendered using the `st_mermaid` function; otherwise, it is displayed as plain text. The function also provides an option to stream the text generator for Mermaid diagrams.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The Markdown text to render, which may contain Mermaid code blocks."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the text generator for Mermaid diagrams."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The render_exchange function is responsible for rendering a chat message in the frontend, including displaying the user's question, the assistant's answer, and various buttons for feedback, comments, and download. It handles different scenarios, including errors and successful responses.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the user's question, the assistant's answer, and other relevant information."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    }
  },
  "classes": {}
}