{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function attempts to calculate the relative path of the file with respect to the project root. If this fails, it falls back to using the file's base name. The function then removes any '.py' extension from the path, replaces path separators with dots, and removes any '__init__' suffix before returning the resulting module path.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The path to the file to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The converted module path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "The `build_file_dependency_graph` function constructs a directed graph representing the file dependencies within a given abstract syntax tree (AST). It utilizes the `FileDependencyGraph` class to visit the AST and extract import dependencies. The function then constructs a graph using the `networkx` library, adding nodes for each file and edges to represent the dependencies between them. The resulting graph is returned as a `nx.DiGraph` object.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree (AST) of the file being analyzed."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository containing the file being analyzed."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies within the given AST."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.FileDependencyGraph.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "The `build_repository_graph` function constructs a directed graph representing the dependencies between Python files within a Git repository. It iterates through all Python files in the repository, parsing each file's abstract syntax tree (AST) to identify import relationships. These relationships are then used to build a global dependency graph. The function returns this graph as a `networkx.DiGraph` object.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "A `GitRepository` object representing the repository to analyze."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the dependencies between Python files in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.File_Dependency.build_file_dependency_graph`.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "The `get_all_temp_files` function retrieves a list of all Python files within a specified directory and its subdirectories. It takes a directory path as input, resolves it to an absolute path, and then uses a recursive glob pattern to find all files with the `.py` extension. The function returns a list of `Path` objects representing the relative paths of these files to the specified directory. This function appears to be part of a larger system for analyzing or processing Python files within a directory structure.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory in which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of `Path` objects representing the relative paths of all Python files found within the specified directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function is a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analysis for each method, including add_item, check_stock, and generate_report. The function uses these analyses to generate documentation for classes. It utilizes the LLMHelper class to process the inputs and generate the final documentation.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, and schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The `make_safe_dot` function generates a safe dot representation of a given directed graph. It takes a `networkx.DiGraph` object and an output file path as input, creates a copy of the graph, relabels its nodes to ensure they are safe for dot representation, and then writes the modified graph to the specified output path. The function utilizes the `networkx` library for graph manipulation and the `nx_pydot` module for writing the dot file. The relabeling process involves assigning a unique, safe identifier to each node, while preserving the original node labels as attributes. This process ensures that the resulting dot file can be safely processed by graph visualization tools.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input directed graph to be converted to a safe dot representation."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the safe dot representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The `build_filtered_callgraph` function constructs a global call graph and filters it to include only self-written functions. It takes a `GitRepository` object as input, iterates over all Python files in the repository, and uses the `ast` module to parse the file contents. The function then builds a directed graph using `networkx` and filters the edges to only include calls between self-written functions. The resulting graph is returned as a `nx.DiGraph` object.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "A `GitRepository` object representing the repository to analyze."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the filtered call graph of self-written functions."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.callgraph.CallGraph`.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The `wrap_cdata` function is designed to wrap a given content in CDATA tags. It takes a single parameter, `content`, which is expected to be a string. The function returns a formatted string where the content is enclosed within CDATA tags. This is typically used in XML to prevent the content from being parsed as XML markup. The function does not handle any exceptions and assumes that the input will always be a string or can be converted to a string. The purpose of this function is to ensure that the content is treated as literal characters within an XML document.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The `extract_output_content` function is designed to extract text and handle images from a list of outputs. It iterates through each output, checks its type, and processes the data accordingly. For display data and execution results, it extracts text or images encoded in Base64 and appends them to a list. For stream outputs, it directly appends the output text. In case of errors, it appends the error name and value. The function returns a list of extracted text strings or placeholders for images.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of output objects to be processed."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list to store image data."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of extracted text strings or placeholders for images."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The `process_image` function processes an image based on its MIME type. It checks if the provided MIME type exists in the `data` dictionary and attempts to decode the corresponding base64-encoded string. If successful, it appends the image data to the `image_list` and returns a placeholder string. If an error occurs during decoding, it returns an error message. If the MIME type is not found in the `data` dictionary, the function returns `None`.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "success",
            "type": "str",
            "description": "A placeholder string indicating the image has been successfully processed."
          },
          {
            "name": "error",
            "type": "str",
            "description": "An error message if the image decoding fails."
          },
          {
            "name": "not_found",
            "type": "NoneType",
            "description": "If the MIME type is not found in the `data` dictionary."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The `convert_notebook_to_xml` function takes a notebook file content as input, attempts to parse it as a JSON notebook, and then converts its cells into XML format. If the parsing fails, it returns an error message. The function handles two types of cells: markdown and code. For markdown cells, it directly converts the source into XML. For code cells, it wraps the source code in a CDATA section and converts it into XML. If a code cell has outputs, it extracts the output content, wraps it in a CDATA section, and appends it as an output cell in the XML. The function returns the XML representation of the notebook and a list of extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the notebook file to be converted."
          }
        ],
        "returns": [
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML representation of the notebook."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted images from the notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.extract_output_content and backend.converter.wrap_cdata.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "The `process_repo_notebooks` function processes a list of repository files, filtering out non-notebook files and converting the remaining notebooks to XML format. It logs the number of notebooks found and the processing of each notebook. The function returns a dictionary containing the XML output and images for each processed notebook. The conversion is performed by calling the `convert_notebook_to_xml` function. The function utilizes logging to track its progress and handles the conversion of notebooks to XML format.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of repository files to be processed."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary containing the XML output and images for each processed notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The `create_savings_chart` function generates a bar chart comparing JSON and TOON tokens and saves it to a specified output path. It takes four parameters: `json_tokens`, `toon_tokens`, `savings_percent`, and `output_path`. The function uses matplotlib to create the chart, customizing its appearance with labels, colors, and a title that includes the savings percentage. The chart displays the number of tokens for each format, with values shown above the bars. Finally, the function saves the chart to the specified output path and closes the plot.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage of savings."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The `calculate_net_time` function calculates the net time spent on a task by subtracting the total sleep time from the total duration. It takes into account the start and end times, the total number of items, the batch size, and the model name. If the model name does not start with 'gemini-', it returns the total duration. If the total number of items is 0, it returns 0. Otherwise, it calculates the number of batches, the total sleep time, and the net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float",
            "description": "The start time of the task."
          },
          {
            "name": "end_time",
            "type": "float",
            "description": "The end time of the task."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The batch size."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float",
            "description": "The net time spent on the task."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is a complex workflow that performs various tasks, including analyzing input, extracting repository information, and generating documentation. It takes in several parameters, including input, api_keys, model_names, and status_callback. The function first updates the status, then extracts the repository URL and clones the repository. It then analyzes the repository, extracts basic information, and constructs a file tree. The function also performs relationship analysis and creates an abstract syntax tree (AST) schema. Finally, it prepares inputs for the Helper LLM, initializes the Helper LLM, and calls it to generate documentation for functions and classes. The function also calls the Main LLM to generate a final report.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input to be analyzed"
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary of API keys"
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary of model names"
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "A callback function to update the status"
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated by the Main LLM"
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary of metrics, including helper time, main time, total time, and token savings"
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, and schemas.types.MethodContextInput.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The update_status function updates the status by calling the status_callback function with the provided message if it exists, and logs the message as info. The function takes a single parameter, msg, which is expected to be a string. The purpose of this function appears to be to notify or log changes in the system's status. The function does not return any value. It relies on the status_callback function and the logging module to perform its operations.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be used for updating the status."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The notebook_workflow function is a complex workflow that processes notebooks from a GitHub repository. It extracts basic project information, clones the repository, processes the notebooks, and generates a report using a large language model (LLM). The function takes in several parameters, including input, api_keys, model, and status_callback, and returns a dictionary containing the report and metrics. The function uses various helper functions and classes, such as ProjektInfoExtractor and MainLLM, to perform its tasks.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input string containing the GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the LLM model to use for report generation."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to update the status of the workflow."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The generated report as a string."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics about the workflow, such as execution time and model usage."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, and backend.main.update_status.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The `gemini_payload` function generates a payload content list by processing the provided `basic_info`, `nb_path`, `xml_content`, and `images`. It first creates an intro JSON object containing the basic information and current notebook path. Then, it iterates over the XML content to find image placeholders, extracts the corresponding text segments, and appends them to the payload content list along with the image data. Finally, it returns the payload content list.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "dict",
            "description": "A dictionary containing basic information about the notebook."
          },
          {
            "name": "nb_path",
            "type": "str",
            "description": "The path to the current notebook."
          },
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML content of the notebook."
          },
          {
            "name": "images",
            "type": "list",
            "description": "A list of image data, where each image is a dictionary containing the image data and other metadata."
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "list",
            "description": "A list of dictionaries, where each dictionary represents a segment of the payload content, either text or an image URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function attempts to calculate the relative path from the project root to the file. If this fails, it falls back to using the file's basename. The function then removes any '.py' extension and replaces path separators with '.' to form the module path. If the resulting module path ends with '.__init__', this suffix is removed before returning the final module path.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The path to the file to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project, used as a reference point for calculating the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The converted module path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The `database.db.encrypt_text` function is designed to encrypt a given text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available. If either condition is true, it returns the original text. Otherwise, it encrypts the text using the cipher suite, strips any leading or trailing whitespace, encodes the text, and then decodes the encrypted result before returning it. The function is intended to provide a basic level of security for sensitive text data. It relies on the `cryptography.fernet.Fernet` library for encryption. The function's simplicity and focus on text encryption make it a straightforward utility for securing data.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The `decrypt_text` function is designed to decrypt a given text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available. If either condition is true, it returns the original text. Otherwise, it attempts to decrypt the text using the cipher suite and returns the decrypted text. If an exception occurs during decryption, it catches the exception and returns the original text. The function is intended to handle text decryption securely, utilizing the `cryptography.fernet.Fernet` library for encryption and decryption operations.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text if decryption is successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The `insert_user` function creates a new user document in the database. It takes in three parameters: `username`, `name`, and `password`. The function hashes the provided password using `stauth.Hasher.hash` and constructs a user dictionary with the provided information, along with some default empty fields for API keys and base URLs. The function then inserts this user document into the database using `dbusers.insert_one` and returns the inserted ID of the newly created user document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password for the user, which will be hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "The `fetch_all_users` function retrieves all users from a database. It utilizes the `dbusers.find()` method, which is likely a part of a MongoDB database interaction, given the presence of `pymongo.MongoClient` in the imports. The function returns a list of all users found in the database. The implementation is straightforward, relying on the `find()` method to fetch all documents from the collection and converting the result to a list. This function does not handle any potential exceptions that might occur during database interactions. It is designed to provide a simple way to fetch all user data from the database.",
        "parameters": [],
        "returns": [
          {
            "name": "users",
            "type": "list",
            "description": "A list of all users retrieved from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The `fetch_user` function retrieves a user document from a database based on the provided `username`. It uses the `find_one` method of the `dbusers` collection to query the database. The function returns the first matching document, or `None` if no document is found. The `username` is used as the value for the `_id` field in the query filter. This function appears to be part of a larger database interaction system, possibly using MongoDB as the database management system.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to query the database for."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict or None",
            "description": "The user document retrieved from the database, or `None` if no document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "The `update_user_name` function updates the name of a user in the database. It takes two parameters: `username` and `new_name`, both of which are strings. The function uses the `update_one` method of the `dbusers` collection to update the `name` field of the document with the matching `_id` (which is set to the `username`). The function returns the number of documents modified by the update operation. This function appears to be part of a larger system that interacts with a MongoDB database, and it does not handle any potential errors that may occur during the update process.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "The `update_gemini_key` function updates a user's Gemini API key in the database. It takes two parameters: `username` and `gemini_api_key`. The function first encrypts the provided API key using the `encrypt_text` function, then updates the corresponding user document in the database with the encrypted key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "The `update_gpt_key` function updates the GPT API key for a given username in the database. It takes two parameters: `username` and `gpt_api_key`. The function encrypts the provided GPT API key using the `encrypt_text` function and then updates the corresponding document in the database. The function returns the number of documents modified as a result of the update operation. This function appears to be part of a larger system for managing user credentials and API keys. It relies on external dependencies such as a database and encryption library to perform its operations.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which the GPT API key should be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be updated for the given username."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified as a result of the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "The update_ollama_url function updates the ollama_base_url for a given username in the database. It uses the dbusers collection and the update_one method to set the new ollama_base_url. The function returns the number of documents modified. The ollama_base_url is stripped of leading and trailing whitespace before being updated. This function appears to be part of a larger database management system, utilizing MongoDB for data storage.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which the ollama_base_url is to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new ollama_base_url to be updated for the given username."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "The `update_opensrc_key` function updates the Open Source API key for a given user in the database. It takes two parameters: `username` and `opensrc_api_key`. The function first encrypts the provided API key using the `encrypt_text` function and then updates the user's document in the database with the encrypted key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The new Open Source API key to be updated for the given user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "The `update_opensrc_url` function updates the `opensrc_base_url` field for a user in the database. It takes two parameters: `username` and `opensrc_base_url`. The function uses the `dbusers.update_one` method to update the user's document in the database. The `opensrc_base_url` is stripped of any leading or trailing whitespace before being updated. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to update."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new opensrc base URL to update for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The `fetch_gemini_key` function retrieves a Gemini API key associated with a given username from a database. It uses the `dbusers` collection to find a document with the matching `_id` field, which is set to the provided `username`. If a matching document is found, it returns the `gemini_api_key` value; otherwise, it returns `None`. This function appears to be part of a larger system that manages user data and API keys. The function's implementation is straightforward, relying on the `find_one` method of the `dbusers` collection to retrieve the desired data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the Gemini API key."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str or None",
            "description": "The Gemini API key associated with the provided username, or `None` if no matching document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The `fetch_ollama_url` function retrieves the Ollama base URL associated with a given username from the database. It uses the `dbusers` collection and filters the result to only include the `ollama_base_url` field. If a user with the provided username is found, the function returns the `ollama_base_url`; otherwise, it returns `None`. This function appears to be part of a larger system that utilizes a MongoDB database. The function's logic is straightforward and does not involve any complex operations.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to retrieve the Ollama base URL."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the provided username, or `None` if no user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The `fetch_gpt_key` function retrieves a GPT API key associated with a given username from a database. It uses the `dbusers` collection to find a document with the specified username and returns the `gpt_api_key` field if the document exists. If no document is found, the function returns `None`. The function takes a single parameter, `username`, which is expected to be a string. The function's purpose is to provide a way to retrieve a user's GPT API key based on their username.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the GPT API key to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the given username, or `None` if no document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "The `fetch_opensrc_key` function retrieves the Open Source API key associated with a given username from the database. It uses the `dbusers` collection and filters the result to only include the `opensrc_api_key` field. If a user with the provided username is found, the function returns their Open Source API key; otherwise, it returns `None`. This function appears to be part of a larger system that manages user data and API keys. The function's implementation is straightforward, relying on the `find_one` method of the `dbusers` collection to retrieve the desired data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The Open Source API key associated with the provided username, or `None` if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "The `fetch_opensrc_url` function retrieves the opensrc base URL for a given username from the database. It uses the `dbusers` collection to find a document with the matching username and returns the `opensrc_base_url` field if found. If no document is found, it returns `None`. The function takes a single parameter, `username`, which is a string. The function's purpose is to provide a way to fetch the opensrc base URL for a specific user. It is designed to work with a MongoDB database, utilizing the `pymongo` library.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to fetch the opensrc base URL for."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The opensrc base URL for the given username, or `None` if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The `delete_user` function is designed to delete a user from the database based on their username. It utilizes the `dbusers.delete_one` method to remove the user document from the database. The function returns the number of documents deleted, which should be 1 if the user exists and 0 if the user does not exist. The function takes a single parameter, `username`, which is expected to be a string. The deletion operation is performed on the `_id` field of the user document, which is assumed to match the provided username.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, which should be 1 if the user exists and 0 if the user does not exist."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "The `get_decrypted_api_keys` function retrieves a user's decrypted API keys from the database based on their username. It first attempts to find the user in the database using the provided username. If the user is found, it decrypts the Gemini, GPT, and OpenSrc API keys using the `decrypt_text` function. The function also retrieves the Ollama base URL and OpenSrc base URL from the user's database entry. If the user is not found, the function returns `None` for all API keys and URLs.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSrc API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSrc base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The `insert_chat` function creates a new chat entry in the database. It takes two parameters, `username` and `chat_name`, and uses them to construct a chat document. The function then inserts this document into the database using `dbchats.insert_one` and returns the inserted ID. The chat document includes a unique ID generated by `uuid.uuid4`, the provided username and chat name, and a timestamp for when the chat was created. This function appears to be part of a larger system for managing chats, possibly in a web application. It relies on the `uuid` and `datetime` modules for generating unique IDs and timestamps, respectively.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted chat document."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "The `fetch_chats_by_user` function retrieves all chats associated with a given user, identified by their `username`. It queries a database using the `dbchats.find` method, filtering results by the `username` field. The results are sorted in ascending order by the `created_at` timestamp. This function returns a list of chat objects. The purpose of this function is to fetch and organize user-specific chat data from the database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chat objects associated with the given username, sorted by creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "The `check_chat_exists` function checks if a chat exists in the database for a given username and chat name. It uses the `dbchats.find_one` method to query the database and returns `True` if a matching document is found, indicating the chat exists, and `False` otherwise. This function is designed to verify the presence of a specific chat in the database. The function takes two parameters, `username` and `chat_name`, both of which are strings. It does not handle any exceptions that may occur during the database query.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "existence",
            "type": "bool",
            "description": "A boolean indicating whether the chat exists in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "The `rename_chat_fully` function renames a chat and all associated exchanges for a given user. It takes three parameters: `username`, `old_name`, and `new_name`, which represent the user's username, the current name of the chat, and the desired new name, respectively. The function first updates the chat entry in the database using the `dbchats.update_one` method, and then updates all associated messages (exchanges) using the `dbexchanges.update_many` method. The function returns the number of modified documents, indicating the success of the rename operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose chat is being renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The desired new name for the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the rename operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The `insert_exchange` function is designed to insert a new exchange record into a database. It takes in various parameters such as question, answer, feedback, username, and chat name, among others. The function generates a unique identifier for the new record and constructs a dictionary representing the exchange. It then attempts to insert this record into the database using `dbexchanges.insert_one`. If successful, the function returns the new identifier; otherwise, it catches any exceptions, prints an error message, and returns `None`. The function relies on imported modules such as `uuid` for generating unique identifiers and `datetime` for timestamping the record creation. The database interaction is facilitated by `pymongo`, indicating a MongoDB database.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in the exchange."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback related to the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat where the exchange occurred."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "Optional parameter indicating if a helper was used, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "Optional parameter indicating if the main system was used, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Optional parameter for the total time taken, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Optional parameter for the time taken by the helper, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Optional parameter for the time taken by the main system, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Optional parameter for JSON tokens, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Optional parameter for Toon tokens, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Optional parameter for savings percentage, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique identifier of the newly inserted exchange record, or `None` if the insertion fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "The `fetch_exchanges_by_user` function retrieves a list of exchanges associated with a given username from the database. It uses the `dbexchanges` collection and sorts the results by the `created_at` timestamp in ascending order. The function takes a `username` parameter of type `str` and returns a list of exchanges. The database interaction is facilitated by the `pymongo` library. The function does not perform any error handling or data validation on the input username.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve exchanges"
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the given username, sorted by creation timestamp"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "The `fetch_exchanges_by_chat` function retrieves a list of exchanges from the database that belong to a specific user and chat. It takes two parameters, `username` and `chat_name`, both of which are strings. The function uses the `dbexchanges` collection to find the relevant exchanges, sorting them by the `created_at` field in ascending order. The function returns a list of these exchanges. The purpose of this function appears to be data retrieval for a specific user's chat history.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose exchanges are being retrieved."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which exchanges are being retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges belonging to the specified user and chat, sorted by creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "The `update_exchange_feedback` function updates the feedback for a specific exchange in the database. It takes two parameters: `exchange_id` and `feedback`, where `feedback` is an integer. The function uses the `dbexchanges` collection to update the document with the matching `_id` field. The update operation sets the `feedback` field to the provided value. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "unknown",
            "description": "The ID of the exchange to update"
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The new feedback value for the exchange"
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "The `update_exchange_feedback_message` function updates the feedback message associated with a specific exchange in the database. It takes two parameters: `exchange_id` and `feedback_message`. The function uses the `dbexchanges.update_one` method to update the feedback message in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "unknown",
            "description": "The ID of the exchange to update."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to associate with the exchange."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "The `delete_exchange_by_id` function deletes a document from a MongoDB database based on the provided `exchange_id`. It utilizes the `dbexchanges.delete_one` method to perform the deletion and returns the number of documents deleted. The function takes a single parameter, `exchange_id`, which is expected to be a string. The deletion operation is performed on a MongoDB collection, and the result is returned as an integer indicating the number of documents deleted. This function appears to be part of a larger database management system, likely used to manage exchange data.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the exchange to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The `delete_full_chat` function deletes a specified chat and all associated exchanges from the database. It ensures consistency between the frontend and backend by removing all related data in two steps: first, it deletes all messages in the chat, and then it removes the chat itself from the chat list. The function takes two parameters, `username` and `chat_name`, and returns the number of chats deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of chats deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The `clean_names` function takes a list of model names as input and returns a new list with the names cleaned by splitting each name at the '/' character and keeping only the last part. This function appears to be designed to extract the final component of a path or identifier. It does not perform any error checking or handling on the input list or its elements. The function is implemented using a list comprehension for efficiency and readability.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list",
            "description": "A list of model names to be cleaned."
          }
        ],
        "returns": [
          {
            "name": "cleaned_model_list",
            "type": "list",
            "description": "A list of cleaned model names."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The `get_filtered_models` function filters a list of models based on a selected category. It uses a set of predefined keywords associated with each category to determine which models to include in the filtered list. If the category is 'STANDARD', it returns only models that are also in the standard list. Otherwise, it checks each model's name for the presence of any category keywords and includes it in the filtered list if a match is found. If no matches are found, it returns the original list.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The original list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered_list",
            "type": "list",
            "description": "The filtered list of models based on the selected category."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "The `save_gemini_cb` function is designed to save a Gemini key to the database. It retrieves the new key from the session state, checks if it exists, and if so, updates the Gemini key in the database for the current user. After a successful update, it clears the session state variable holding the new key and displays a toast message indicating that the Gemini key has been saved successfully.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "The `save_ollama_cb` function is designed to save a new Ollama URL to the database. It retrieves the new URL from the session state and checks if it is not empty. If the URL is valid, it updates the Ollama URL in the database for the current user and displays a success toast message. The function appears to be part of a Streamlit application, utilizing session state and database interactions. It does not take any parameters and does not return any values. The function's purpose is to persist user-specific data in the database.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The `load_data_from_db` function loads chat and exchange data from the database for a given username. It checks if the data has already been loaded for the current user and only loads it if necessary. The function first loads defined chats, then exchanges, and finally creates a default chat if no data exists. It also sets the active chat and updates the session state accordingly.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load the data"
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "The `handle_feedback_change` function updates the feedback of an exchange in the database and triggers a rerun of the Streamlit application. It takes two parameters: `ex` and `val`, where `ex` is expected to be a dictionary containing an `_id` key and a `feedback` key, and `val` is the new feedback value. The function first updates the `feedback` key in the `ex` dictionary with the provided `val`. Then, it calls the `update_exchange_feedback` function from the `database.db` module to persist this change in the database. Finally, it triggers a rerun of the Streamlit application using `st.rerun()`. This function appears to be part of a larger application that handles user feedback for exchanges, likely in a web-based interface.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing information about the exchange, including its `_id` and current `feedback`."
          },
          {
            "name": "val",
            "type": "str",
            "description": "The new feedback value to be updated for the exchange."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "The `handle_delete_exchange` function is responsible for deleting an exchange from the database and updating the session state accordingly. It takes two parameters, `chat_name` and `ex`, where `ex` is expected to be a dictionary containing an `_id` key. The function first deletes the exchange from the database using the `database.db.delete_exchange_by_id` function. Then, it checks if the `chat_name` exists in the session state and if the exchange is present in the list of exchanges for that chat. If both conditions are met, it removes the exchange from the list. Finally, the function triggers a rerun of the Streamlit application using `st.rerun()`. This function appears to be part of a larger application that manages exchanges within chats, likely in a web-based interface.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is being deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, containing at least an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is not called by any other functions according to the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The `handle_delete_chat` function is responsible for handling the deletion of a chat. It takes two parameters, `username` and `chat_name`, and uses them to delete the specified chat from the database. After deletion, it cleans up the state by removing the chat from the session state and updates the active chat if necessary. If all chats are deleted, it creates a new empty chat. Finally, it triggers a rerun of the Streamlit application.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user deleting the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_full_chat and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The `extract_repo_name` function takes a text input and attempts to extract a repository name from it. It uses regular expressions to find a URL within the text, then parses the URL to extract the path. The function splits the path by '/' and takes the last part as the potential repository name. If the name ends with '.git', it removes this suffix. The function returns the extracted repository name or None if no URL is found in the text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to search for a repository URL."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name, or None if no URL is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The stream_text_generator function is a generator that takes a string of text as input and yields each word in the text, separated by a space, with a 0.01-second delay between each word. This function appears to be designed for use in a streaming or interactive context, where the text is displayed one word at a time. The function uses the time.sleep function to introduce the delay. The input text is split into words using the split method with a space as the separator.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be streamed."
          }
        ],
        "returns": [
          {
            "name": "word",
            "type": "str",
            "description": "Each word in the input text, separated by a space."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The `render_text_with_mermaid` function is designed to render markdown text that may contain mermaid code blocks. It splits the input text into parts based on the presence of mermaid code blocks, and then processes each part accordingly. If the part is a mermaid code block, it attempts to render it using the `st_mermaid` function. If rendering fails, it falls back to displaying the code block as plain text. If the part is not a mermaid code block, it renders the markdown text using either `st.write_stream` or `st.markdown`, depending on the value of the `should_stream` parameter.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The markdown text to be rendered, which may contain mermaid code blocks."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the rendered text or not. Defaults to False."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function is responsible for rendering an exchange in a chat interface. It takes two parameters: `ex` and `current_chat_name`. The function displays the question and answer in the chat, along with various buttons for feedback, commenting, downloading, and deleting the exchange. If the answer contains an error, it displays an error message instead. The function uses Streamlit to create the UI and interacts with the database to update feedback messages and delete exchanges.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing information about the exchange, including the question, answer, and feedback."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python source code and extract relevant information about imports, functions, and classes. It initializes with source code, file path, and project root, and uses these to construct a schema that details the structure of the code. The class utilizes methods like visit_Import, visit_ClassDef, and visit_FunctionDef to gather specific information about the code's structure.",
        "init_method": {
          "description": "The constructor of the ASTVisitor class initializes the object with source code, file path, and project root. It sets up instance attributes for source code, file path, project root, module path, and an empty schema. The module path is determined by calling the path_to_module function with the file path and project root. The schema is a dictionary that will store information about imports, functions, and classes found in the source code.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code to be analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file containing the source code."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method handles Import nodes in the AST. It extracts the names of imported modules and adds them to the schema's imports list. It then calls the generic_visit method to continue traversing the AST.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method to continue AST traversal.",
                "called_by": "This method is called by the ASTVisitor's traversal mechanism when it encounters an Import node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method handles ImportFrom nodes in the AST. It extracts the module name and names of imported entities, constructs a full identifier (module_name.entity_name), and adds it to the schema's imports list. It then continues AST traversal with generic_visit.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method to continue AST traversal.",
                "called_by": "This method is called by the ASTVisitor's traversal mechanism when it encounters an ImportFrom node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method handles ClassDef nodes in the AST. It constructs a class identifier, extracts class information (name, docstring, source code segment), and adds it to the schema's classes list. It keeps track of the current class being processed and continues AST traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method to continue AST traversal.",
                "called_by": "This method is called by the ASTVisitor's traversal mechanism when it encounters a ClassDef node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method handles FunctionDef nodes in the AST. If a class is currently being processed, it adds method information to the class's context; otherwise, it adds function information directly to the schema. It extracts details like function name, arguments, docstring, and source code segment.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the generic_visit method to continue AST traversal.",
                "called_by": "This method is called by the ASTVisitor's traversal mechanism when it encounters a FunctionDef node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method handles AsyncFunctionDef nodes in the AST by delegating the processing to the visit_FunctionDef method, effectively treating async functions similarly to regular functions.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls visit_FunctionDef to process the async function.",
                "called_by": "This method is called by the ASTVisitor's traversal mechanism when it encounters an AsyncFunctionDef node."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the path_to_module function from backend.AST_Schema for determining the module path.",
          "instantiated_by": "The class is instantiated with source code, file path, and project root to analyze the structure of the provided source code."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing the abstract syntax tree (AST) of a repository and providing a schema of the code structure. It has two primary methods: merge_relationship_data and analyze_repository. The class is designed to work with Python files and utilizes the ASTVisitor class to parse the code. The merge_relationship_data method merges relationship data into the full schema, while the analyze_repository method analyzes a repository and returns a schema of the code structure.",
        "init_method": {
          "description": "The __init__ method is the constructor of the ASTAnalyzer class. It does not take any parameters and does not perform any initialization.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "The merge_relationship_data method merges relationship data into the full schema. It takes two parameters: full_schema and raw_relationships. The method iterates over the files in the full schema, and for each file, it updates the context of the functions and classes with the outgoing and incoming calls. It also updates the dependencies of the classes.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema of the code structure."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "The raw relationship data to be merged into the full schema."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated full schema with the merged relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other methods."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "The analyze_repository method analyzes a repository and returns a schema of the code structure. It takes two parameters: files and repo. The method iterates over the files in the repository, and for each file, it parses the code using the ASTVisitor class and updates the full schema with the parsed data.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects to be analyzed."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "The repository to be analyzed."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The schema of the code structure."
                }
              ],
              "usage_context": {
                "calls": "This method calls the ASTVisitor class to parse the code.",
                "called_by": "This method is not called by any other methods."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ASTAnalyzer class depends on the ASTVisitor class.",
          "instantiated_by": "The ASTAnalyzer class is not instantiated by any other classes."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve file dependencies within a repository. It utilizes the NodeVisitor class from the ast module to traverse the abstract syntax tree of Python files and identify import statements. The class provides methods to resolve relative imports and track dependencies between files.",
        "init_method": {
          "description": "The __init__ method initializes the FileDependencyGraph object with a filename and a repository root. It sets the filename and repo_root attributes of the object.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to analyze."
            },
            {
              "name": "repo_root",
              "type": "str",
              "description": "The root directory of the repository."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "The _resolve_module_name method resolves relative imports of the form `from .. import name1, name2`. It returns a list of existing module or symbol names. If no resolution is possible, it raises an ImportError.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import node to resolve."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists to resolve the import.",
                "called_by": "This method is called by the visit_ImportFrom method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "The visit_Import method visits an import node and adds the imported module to the import dependencies of the current file.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "The import node to visit."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "The base name of the imported module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_ImportFrom method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "The visit_ImportFrom method visits an import from node and resolves the relative import. If the import is relative, it calls the _resolve_module_name method to resolve it.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import from node to visit."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _resolve_module_name method to resolve relative imports.",
                "called_by": "This method is not called by any other method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The FileDependencyGraph class depends on backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
          "instantiated_by": "The FileDependencyGraph class is not instantiated by any other class or method."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class is designed to interact with various language models for generating code snippet documentation. It centralizes API interaction, error handling, and validates I/O using Pydantic. The class takes in several parameters during initialization, including an API key, function and class prompt paths, and a model name. It then configures batch settings based on the model name and initializes language models for function and class analysis.",
        "init_method": {
          "description": "The constructor initializes the LLMHelper object with the provided parameters. It checks if the API key is set, reads the function and class system prompts from files, and configures batch settings based on the model name. It also initializes language models for function and class analysis.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for the language model."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "The path to the function system prompt file."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "The path to the class system prompt file."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the language model to use (default is 'gemini-2.0-flash-lite')."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the language model API (default is None)."
            }
          ]
        },
        "methods": [
          {
            "identifier": "backend.HelperLLM.LLMHelper._configure_batch_settings",
            "description": {
              "overall": "This method configures the batch settings for the language model based on the model name. It sets the batch size to a specific value depending on the model name.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "The name of the language model."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the constructor to configure batch settings.",
                "called_by": "This method is called by the constructor."
              }
            },
            "error": null
          },
          {
            "identifier": "backend.HelperLLM.LLMHelper.generate_for_functions",
            "description": {
              "overall": "This method generates and validates documentation for a batch of functions. It takes in a list of function inputs, creates JSON payloads, and sends them to the language model for processing. It then returns a list of validated function analyses.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function inputs to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "validated_functions",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analyses."
                }
              ],
              "usage_context": {
                "calls": "This method calls the language model's batch method to process the function inputs.",
                "called_by": "This method is not called by any other method in the class."
              }
            },
            "error": null
          },
          {
            "identifier": "backend.HelperLLM.LLMHelper.generate_for_classes",
            "description": {
              "overall": "This method generates and validates documentation for a batch of classes. It takes in a list of class inputs, creates JSON payloads, and sends them to the language model for processing. It then returns a list of validated class analyses.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class inputs to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "validated_classes",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analyses."
                }
              ],
              "usage_context": {
                "calls": "This method calls the language model's batch method to process the class inputs.",
                "called_by": "This method is not called by any other method in the class."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class is the primary class for interacting with the LLM (Large Language Model). It provides methods for calling and streaming the LLM, and it handles the initialization of the LLM with the provided model and API key. The class is designed to be flexible and can work with different LLM models and APIs.",
        "init_method": {
          "description": "The __init__ method initializes the MainLLM class with the provided API key, prompt file path, model name, and base URL. It checks if the API key is set and raises a ValueError if it is not. It also reads the system prompt from the provided file path and initializes the LLM with the provided model and API key.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for the LLM"
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt"
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the LLM model (default is 'gemini-2.5-pro')"
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the LLM API (default is None)"
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "The call_llm method calls the LLM with the provided user input and returns the response. It creates a list of messages with the system prompt and user input, and then invokes the LLM with these messages.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The user input to be passed to the LLM"
                }
              ],
              "returns": [
                {
                  "name": "response",
                  "type": "str",
                  "description": "The response from the LLM"
                }
              ],
              "usage_context": {
                "calls": "The method calls the invoke method of the LLM.",
                "called_by": "The method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "The stream_llm method streams the LLM with the provided user input and yields the response chunks. It creates a list of messages with the system prompt and user input, and then streams the LLM with these messages.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The user input to be passed to the LLM"
                }
              ],
              "returns": [
                {
                  "name": "chunk",
                  "type": "str",
                  "description": "A chunk of the response from the LLM"
                }
              ],
              "usage_context": {
                "calls": "The method calls the stream method of the LLM.",
                "called_by": "The method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class does not have any external dependencies listed in the provided context.",
          "instantiated_by": "The class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README, pyproject.toml, and requirements.txt. It initializes a structured information dictionary and populates it by parsing the contents of these files.",
        "init_method": {
          "description": "The constructor initializes the class with a structured information dictionary containing placeholders for project overview and installation information. It sets up default values for various project attributes.",
          "parameters": [
            {
              "name": "self",
              "type": "instance",
              "description": "Reference to the instance of the class"
            }
          ]
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from a given content string, which can occur due to encoding errors when reading files.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The content to be cleaned"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches for a file in a list of files that matches one of the given patterns in a case-insensitive manner.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "List of file patterns to search for"
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "List of files to search in"
                }
              ],
              "returns": [
                {
                  "name": "file",
                  "type": "Optional[Any]",
                  "description": "The found file or None if not found"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text under a Markdown heading (##) based on given keywords.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The Markdown content to extract from"
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "Keywords to identify the section"
                }
              ],
              "returns": [
                {
                  "name": "section_text",
                  "type": "Optional[str]",
                  "description": "The extracted section text or None if not found"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file and extracts relevant project information.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file and extracts project information.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file and extracts dependencies.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the extraction of project information from various files.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "List of files to extract information from"
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository"
                }
              ],
              "returns": [
                {
                  "name": "project_info",
                  "type": "Dict[str, Any]",
                  "description": "The extracted project information"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze the call structure of a given Python file. It utilizes the abstract syntax tree (AST) to traverse and understand the definitions and calls within the file, constructing a directed graph that represents the call relationships between functions and methods.",
        "init_method": {
          "description": "The constructor of the CallGraph class initializes the object with a given filename. It sets up several instance variables to keep track of the current function and class being processed, as well as data structures to store local definitions, the call graph, import mappings, and function sets.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "This method recursively resolves the components of a call node in the AST, returning a list of name components as a dotted string. It handles different types of nodes such as Call, Name, and Attribute.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Node",
                  "description": "The node in the AST to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "This method takes a list of callee nodes and resolves their names based on local definitions and import mappings. It returns a list of resolved callee names.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists containing name steps."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved callee names."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "This method constructs a full name for a given basename and optional class name, prefixing them with the filename.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name."
                },
                {
                  "name": "class_name",
                  "type": "str | None",
                  "description": "The class name."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The full name constructed from the basename and class name."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "This method returns the current caller, which is either the current function or a representation of the global scope if no function is being processed.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The current caller."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method handles Import nodes in the AST, updating the import mapping with the names and aliases of imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method handles ImportFrom nodes in the AST, updating the import mapping with the names and aliases of imported modules from a specific module.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method handles ClassDef nodes in the AST, temporarily updating the current class being processed and then reverting it after visiting the class definition.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method handles FunctionDef nodes in the AST, updating local definitions and the call graph with the function name and its full name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method handles AsyncFunctionDef nodes in the AST by delegating to the visit_FunctionDef method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method handles Call nodes in the AST, resolving the caller and callee names and updating the call graph with the call relationship.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The Call node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "This method handles If nodes in the AST, specifically checking for a common pattern where the condition is a comparison of __name__, and temporarily adjusts the current function being processed.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The If node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the 'ast' and 'networkx' modules for its operation.",
          "instantiated_by": "The class is instantiated with a filename to analyze the call graph of that file."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents an individual file within a Git repository. It provides lazy loading of the file content, allowing for efficient handling of large files. The class offers various methods for accessing file properties, such as its path, size, and content.",
        "init_method": {
          "description": "The constructor initializes a RepoFile object with a given file path and commit tree. It sets up the object's state by storing the file path and commit tree, and initializes internal variables for lazy loading of the file's blob, content, and size.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The Tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "This property lazy-loads the Git blob object associated with the file. If the blob is not already loaded, it attempts to retrieve it from the commit tree. If the file is not found, it raises a FileNotFoundError.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "This property lazy-loads and returns the decoded content of the file. If the content is not already loaded, it reads the content from the blob's data stream and decodes it using UTF-8.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "This property lazy-loads and returns the size of the file in bytes. If the size is not already loaded, it retrieves it from the blob's size attribute.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "This method analyzes the file content and returns the word count. It splits the content into words using whitespace as a delimiter and returns the number of words.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The number of words in the file content."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "This method returns a dictionary representation of the RepoFile object. It includes the file's path, name, size, and type. If include_content is True, it also includes the file content.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include the file content in the dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to the repository's files as RepoFile objects. It handles cloning, file retrieval, and cleanup. The class is designed to be used as a context manager, ensuring the temporary directory is deleted after use.",
        "init_method": {
          "description": "The class is initialized with a repository URL, which is used to clone the repository into a temporary directory. The constructor also sets up the repository object and retrieves the latest commit.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "string",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "This method retrieves a list of all files in the repository as RepoFile objects. It uses the repository's git ls-files command to get the file paths and then creates RepoFile instances for each file.",
              "parameters": [],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.getRepo.RepoFile class to create RepoFile instances.",
                "called_by": "This method is not explicitly called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "This method deletes the temporary directory and its contents. It is called when the context manager exits.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods or classes.",
                "called_by": "This method is called by the __exit__ method when the context manager exits."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "This method constructs a file tree representation of the repository's files. It uses the get_all_files method to retrieve the files and then builds a nested dictionary structure representing the file tree.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "boolean",
                  "description": "A flag indicating whether to include file contents in the file tree representation."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the file tree structure of the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the get_all_files method to retrieve the repository's files.",
                "called_by": "This method is not explicitly called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the backend.getRepo.RepoFile class.",
          "instantiated_by": "The class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze a project by traversing its directory structure, identifying Python files, and resolving function and method calls within those files. It constructs a call graph that represents the relationships between different parts of the project.",
        "init_method": {
          "description": "The constructor initializes the ProjectAnalyzer with a project root directory. It sets up instance attributes such as the project root path, definitions, call graph, file ASTs, and directories to ignore.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "This method orchestrates the analysis of the project by finding Python files, collecting definitions, resolving calls, and returning the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "dict",
                  "description": "A dictionary representing the call graph of the project."
                }
              ],
              "usage_context": {
                "calls": "This method calls _find_py_files, _collect_definitions, and _resolve_calls to perform the analysis.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "This method processes the call graph to extract raw relationships between callers and callees, organizing them into outgoing and incoming relationship sets.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing outgoing and incoming relationship sets."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "This method traverses the project directory structure to find all Python files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list",
                  "description": "A list of paths to Python files in the project."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "This method reads Python files, parses their AST, and collects definitions of functions, methods, and classes.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method uses path_to_module to generate module paths.",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "This method finds the parent node of a given node in the AST.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The AST being traversed."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The node whose parent is being sought."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST",
                  "description": "The parent node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "This method resolves function and method calls within a given Python file by using a CallResolverVisitor.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method uses CallResolverVisitor to resolve calls.",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ProjectAnalyzer depends on CallResolverVisitor and path_to_module for its operations.",
          "instantiated_by": "The class is not instantiated by any part of the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python code and resolve function calls, tracking the call relationships between different parts of the codebase. It is particularly focused on identifying and recording calls to defined functions or methods within the code.",
        "init_method": {
          "description": "The constructor initializes the visitor with a filepath, project root, and definitions. It sets up the necessary instance variables to track the module path, definitions, scope, instance types, and current caller and class names.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The file path of the code being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary of definitions in the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method is called when a class definition node is encountered in the AST. It temporarily updates the current class name and then performs a generic visit of the class definition node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node for the class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method is called when a function definition node is encountered in the AST. It updates the current caller name based on whether the function is defined inside a class or not, and then performs a generic visit of the function definition node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node for the function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method is called when a call node is encountered in the AST. It attempts to resolve the called function's pathname and, if resolvable and defined, records the call relationship.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node for the function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method is called when an import node is encountered in the AST. It updates the scope with the imported names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node for the import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method is called when an import from node is encountered in the AST. It updates the scope with the imported names, taking into account the module and level of the import.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node for the import from statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "This method is called when an assign node is encountered in the AST. It checks if the assignment is to a class instance and updates the instance types accordingly.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node for the assignment."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "This method attempts to resolve the full pathname of a called function or method based on the AST node of the call.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.Name or ast.Attribute",
                  "description": "The AST node for the function or method being called."
                }
              ],
              "returns": [
                {
                  "name": "pathname",
                  "type": "str or None",
                  "description": "The resolved pathname of the called function or method, or None if it cannot be resolved."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the backend.relationship_analyzer.path_to_module function.",
          "instantiated_by": "The class is not instantiated by any part of the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic model that represents a single parameter of a function. It encapsulates the name, type, and description of the parameter, providing a structured way to document and validate function parameters.",
        "init_method": {
          "description": "The class is initialized with three attributes: name, type, and description, all of which are strings. These attributes are used to describe a single parameter of a function.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the parameter."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ParameterDescription class does not have any external dependencies.",
          "instantiated_by": "There is no information available about where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model that represents the return value of a function. It encapsulates the name, type, and description of the return value, providing a structured way to document and validate function returns.",
        "init_method": {
          "description": "The class is initialized with three parameters: name, type, and description, all of which are strings. These parameters are used to set up the instance attributes of the class.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ReturnDescription class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model that describes the calling context of a function. It encapsulates information about the functions a method calls and where it is called, providing a structured way to represent and analyze method interactions within a system.",
        "init_method": {
          "description": "The UsageContext class is initialized with two parameters: calls and called_by, which represent the functions a method calls and where it is called, respectively.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string representing the functions a method calls."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string representing where a method is called."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The UsageContext class has no external dependencies.",
          "instantiated_by": "The UsageContext class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class represents a detailed analysis of a function's purpose and signature, encapsulating its overall description, parameters, return values, and usage context.",
        "init_method": {
          "description": "The class is initialized with attributes that describe a function's overall purpose, parameters, return values, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the function's overall purpose."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects describing the function's parameters."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects describing the function's return values."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "A UsageContext object describing the function's usage context."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class represents a model for analyzing functions, encapsulating their identifier, description, and potential error messages. It inherits from BaseModel, indicating it is a Pydantic model designed for data validation and parsing. The class does not define any methods beyond the constructor, suggesting its primary role is data representation.",
        "init_method": {
          "description": "The class is initialized with an identifier of type str, a description of type FunctionDescription, and an optional error message of type str. The error message defaults to None if not provided.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique identifier for the function being analyzed."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "A detailed description of the function's purpose and behavior."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional error message associated with the function analysis, defaults to None."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionAnalysis class does not have any external dependencies listed.",
          "instantiated_by": "There are no specified instances where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model that describes the __init__ method of a class. It contains two main attributes: description and parameters. The description attribute is a string that provides a summary of the class's constructor, while the parameters attribute is a list of ParameterDescription objects that detail the parameters of the constructor.",
        "init_method": {
          "description": "The ConstructorDescription class is initialized with a description and a list of parameters.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A string describing the class's constructor."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing the parameters of the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ConstructorDescription class has no external dependencies.",
          "instantiated_by": "The ConstructorDescription class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model that describes the external dependencies and primary points of instantiation of a class. It has two attributes: dependencies and instantiated_by, which are both strings. This class provides a structured way to represent the context in which a class is used.",
        "init_method": {
          "description": "The ClassContext class is initialized with two parameters: dependencies and instantiated_by, which are both strings. These parameters are used to set the corresponding attributes of the class.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string representing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string representing the primary points of instantiation of the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassContext class does not have any external dependencies.",
          "instantiated_by": "The ClassContext class is not instantiated by any other classes or functions."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to contain the detailed analysis of a class's purpose, constructor, and methods. It provides a structured way to represent the analysis of a class, including its overall purpose, constructor details, method descriptions, and usage context. The class is built on top of Pydantic's BaseModel, ensuring data validation and serialization capabilities.",
        "init_method": {
          "description": "The ClassDescription class is initialized with four attributes: overall, init_method, methods, and usage_context. The overall attribute is a string describing the class's purpose, init_method is an object of type ConstructorDescription, methods is a list of FunctionAnalysis objects, and usage_context is an object of type ClassContext.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the class's purpose."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object of type ConstructorDescription describing the class's constructor."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects describing the class's methods."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object of type ClassContext describing the class's usage context."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassDescription class has no external dependencies.",
          "instantiated_by": "The ClassDescription class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class represents the main model for the entire JSON schema for a class, encapsulating its identifier, description, and potential error information. It inherits from pydantic's BaseModel, leveraging its validation capabilities. The class is designed to provide a structured representation of a class's analysis, including its purpose, methods, and usage context. The description field is of type ClassDescription, indicating a nested structure for detailed class analysis. The error field is optional, allowing for the inclusion of error messages when necessary.",
        "init_method": {
          "description": "The ClassAnalysis class is initialized with an identifier, a description of type ClassDescription, and an optional error message. The identifier is a string that uniquely represents the class, while the description provides a detailed analysis of the class's structure and behavior.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the class."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "A detailed description of the class's structure and behavior."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional error message associated with the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassAnalysis class has no external dependencies.",
          "instantiated_by": "The ClassAnalysis class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer. It is used in 'called_by' and 'instantiated_by' lists to provide information about the caller, including the file, function, mode, and line number. This class inherits from pydantic's BaseModel, allowing for data validation and serialization. The class has four attributes: file, function, mode, and line, which are used to store the caller's information.",
        "init_method": {
          "description": "The class is initialized with four parameters: file, function, mode, and line. These parameters are used to set the corresponding attributes of the class.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file where the call event occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that made the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, e.g., 'method', 'function', 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number where the call event occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The CallInfo class has no external dependencies.",
          "instantiated_by": "The CallInfo class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class represents a structured context for analyzing a function, encapsulating information about the functions it calls and the entities that call it.",
        "init_method": {
          "description": "The class is initialized with two parameters: calls and called_by, which are lists of strings and CallInfo objects, respectively.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of function calls made by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the entities that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionContextInput class has no external dependencies.",
          "instantiated_by": "The FunctionContextInput class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class represents the required input to generate a FunctionAnalysis object. It inherits from pydantic's BaseModel and defines the structure for input data. The class has attributes for mode, identifier, source_code, imports, and context, which are used to provide a comprehensive analysis of a function.",
        "init_method": {
          "description": "The class is initialized with the provided mode, identifier, source_code, imports, and context. The mode is restricted to 'function_analysis', indicating the purpose of the input data.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "The mode of analysis, which is fixed as 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the function as a string."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the function."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "Additional context for the function analysis, defined by the FunctionContextInput model."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionAnalysisInput class does not have any external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class represents a structured context for a class's methods, encapsulating information about the method's identifier, calls, callers, arguments, and documentation.",
        "init_method": {
          "description": "The class is initialized with attributes that provide context for a method, including its identifier, calls, callers, arguments, and documentation.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The identifier of the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of methods or functions called by the method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of callers of the method, where each caller is represented by a CallInfo object."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of argument names for the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "The documentation string for the method, if available."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class represents a structured context for analyzing a class, encapsulating information about dependencies, instantiation, and method contexts. It inherits from pydantic's BaseModel, ensuring data validation and parsing capabilities. The class has three primary attributes: dependencies, instantiated_by, and method_context, which are lists of strings, CallInfo objects, and MethodContextInput objects, respectively.",
        "init_method": {
          "description": "The class is initialized with three parameters: dependencies, instantiated_by, and method_context, which are lists of strings, CallInfo objects, and MethodContextInput objects, respectively. These parameters are used to set up the instance attributes of the class.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of strings representing the dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing where the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects representing the method contexts of the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class represents the required input to generate a ClassAnalysis object. It encapsulates the necessary information for class analysis, including the mode, identifier, source code, imports, and context. The class inherits from pydantic's BaseModel, ensuring validation and structure for the input data.",
        "init_method": {
          "description": "The class is initialized with the mode, identifier, source code, imports, and context. The mode is restricted to 'class_analysis', and the identifier, source code, and imports are required as strings and a list of strings, respectively. The context is an instance of ClassContextInput.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "The mode of analysis, restricted to 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The identifier of the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the class being analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "The context in which the class is being analyzed."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassAnalysisInput class has no external dependencies.",
          "instantiated_by": "The ClassAnalysisInput class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    }
  }
}