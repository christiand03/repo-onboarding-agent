{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies within a codebase. It takes a filename, an abstract syntax tree (AST), and a repository root path as inputs. It uses a custom visitor class to traverse the AST and extract import dependencies. These dependencies are then added to a NetworkX DiGraph, where nodes represent files and edges represent dependency relationships from caller to callee.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed for dependencies."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree of the file being analyzed."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory path of the repository containing the file."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing file dependencies, where nodes are files and edges indicate import relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.FileDependencyGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between Python files within a Git repository. It iterates through all files in the repository, filters for Python files, parses their content into ASTs, and builds individual dependency graphs for each file. These individual graphs are then merged into a single global graph that captures the overall dependency structure of the repository.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository object containing the files to analyze for dependencies."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the dependency relationships between Python files in the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.build_file_dependency_graph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories. It resolves the given directory path to an absolute path, then uses recursive globbing to find all .py files. Each file path is normalized relative to the root directory. The function returns a list of Path objects representing these files.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The directory path from which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of Path objects representing all Python files found in the directory and its subdirectories, relative to the root directory."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analysis for three example functions: add_item, check_stock, and generate_report. These analyses are then passed to the LLMHelper to simulate documentation generation for a class named InventoryManager. The function sets up mock inputs, processes them through the LLMHelper, and aggregates the results into a final documentation dictionary.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a copy of the graph and generates a mapping from original node names to safe identifiers prefixed with 'n'. The original node names are then stored as labels in the relabeled graph. Finally, the modified graph is written to a file in DOT format using the pydot library.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph to be processed and saved."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The function builds a filtered call graph from a Git repository by parsing Python files and extracting function call relationships. It identifies functions defined within the repository and constructs a directed graph containing only those functions and their interdependencies. The graph is built using NetworkX and includes nodes for functions and edges representing calls between them. Only calls between functions owned by the project are included in the final graph.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "The Git repository object containing the files to analyze for building the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the filtered call graph of functions defined within the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The function 'wrap_cdata' takes a string input named 'content' and wraps it with CDATA (Character Data) tags. This is commonly used in XML processing to safely include text that might otherwise be interpreted as markup. The function returns a formatted string that begins with '<![CDATA[' followed by a newline, the original content, another newline, and ends with ']]>'.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The string content that needs to be wrapped with CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "A string that contains the original content wrapped in CDATA tags with newlines around it."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The function extracts content from notebook outputs, handling both text and image data. It processes outputs based on their type, such as display_data, execute_result, stream, or error, and returns a list of extracted text snippets or image placeholders. For image data, it decodes Base64 strings and appends them to an image list with metadata. The function also includes error handling for image decoding issues.",
        "parameters": [
          {
            "name": "outputs",
            "type": "Any",
            "description": "A collection of notebook output objects to be processed."
          },
          {
            "name": "image_list",
            "type": "List[Dict[str, Any]]",
            "description": "A mutable list to store decoded image data along with metadata."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "List[str]",
            "description": "A list of text strings or XML placeholders representing the extracted content from the outputs."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The function processes an image by checking if a given MIME type exists in a data dictionary. If found, it decodes the base64 string, appends the image data to a global list, and returns an XML placeholder string with the image index and MIME type. If an exception occurs during processing, it returns an error message. If the MIME type is not found in the data, the function returns None.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str or None",
            "description": "Returns an XML placeholder string with image details if successful, otherwise returns an error message or None if the MIME type is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "This function converts a Jupyter notebook, represented as a string of JSON content, into an XML format. It processes each cell in the notebook, handling markdown and code cells differently. For code cells, it also extracts and includes output content if present. The function returns the constructed XML string along with a list of extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "A string containing the JSON representation of a Jupyter notebook."
          }
        ],
        "returns": [
          {
            "name": "xml_output",
            "type": "str",
            "description": "The generated XML string representing the notebook content."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted images from the notebook cells."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.extract_output_content, backend.converter.wrap_cdata",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files to identify and convert Jupyter notebook files (.ipynb) into XML format along with associated images. It iterates through the notebook files, logs the processing status, and returns a dictionary mapping each notebook file path to its converted XML content and image data. The function relies on an external helper function to perform the actual conversion.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "List[File]",
            "description": "A list of file objects representing the files in the repository, each expected to have a 'path' attribute and a 'content' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "Dict[str, Dict[str, Any]]",
            "description": "A dictionary where keys are the paths of the processed notebook files and values are dictionaries containing the converted XML output and associated images."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.convert_notebook_to_xml",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The function creates a bar chart comparing token counts between two formats, JSON and TOON, and saves the resulting visualization to a specified file path. It takes token counts for both formats, calculates the savings percentage, and uses matplotlib to render and save the chart. The chart includes labeled axes, a title indicating the savings percentage, grid lines, and numeric values displayed above each bar.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of tokens used by the JSON format."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of tokens used by the TOON format."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage savings achieved by using the TOON format compared to JSON."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the generated chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function calculates the net duration of an operation by subtracting sleep times caused by rate limits from the total elapsed time. It specifically handles cases where the model name starts with 'gemini-' and adjusts the calculation based on the number of items processed and batch size. If the model is not a gemini model, it returns the total duration directly. For zero items, it returns zero. Otherwise, it computes the number of batches, determines the sleep count, and subtracts the total sleep time from the total duration.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float or datetime",
            "description": "The starting timestamp of the operation."
          },
          {
            "name": "end_time",
            "type": "float or datetime",
            "description": "The ending timestamp of the operation."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items processed during the operation."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The number of items processed per batch."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used, which determines whether rate limit adjustments apply."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float or int",
            "description": "The calculated net time after subtracting sleep durations due to rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The `main_workflow` function orchestrates a comprehensive code analysis and documentation generation process for a given repository. It begins by extracting API keys and model configurations, then clones the repository and analyzes its structure. The function proceeds to extract basic project information, construct a file tree, and perform relationship analysis between components. It generates an abstract syntax tree (AST) schema and enriches it with relationship data. Subsequently, it prepares inputs for a helper LLM to analyze functions and classes, and calls the helper LLM to generate documentation. Finally, it prepares inputs for a main LLM to produce a final report, saves the results, and returns both the report and performance metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "Any",
            "description": "The input provided to the workflow, typically a string containing a repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services such as Gemini, OpenAI, and SCADSLMM."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary specifying the names of models to be used for helper and main LLMs."
          },
          {
            "name": "status_callback",
            "type": "Callable[[str], None]",
            "description": "An optional callback function to report progress updates."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final markdown report generated by the main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and token usage metrics for the analysis process."
          }
        ],
        "usage_context": {
          "calls": "backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, schemas.types.MethodContextInput",
          "called_by": "This function calls no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The function 'update_status' takes a message as input and logs it using the logging module. It also invokes an optional callback function named 'status_callback' if it is defined. This function serves as a centralized logging and status reporting mechanism.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be logged and optionally passed to the status callback."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function orchestrates the analysis of Jupyter notebooks from a GitHub repository using a specified language model. It begins by extracting a repository URL from the input, clones the repository, processes its files into XML format, and extracts basic project information. It then iterates through each notebook, constructs a payload for the LLM, and generates individual reports. Finally, it compiles all reports into a single markdown file and returns both the report content and processing metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "Any",
            "description": "The input string containing the repository URL or other relevant data."
          },
          {
            "name": "api_keys",
            "type": "Dict[str, str]",
            "description": "A dictionary mapping API key identifiers to their respective keys for accessing different LLM services."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the language model to be used for generating reports."
          },
          {
            "name": "status_callback",
            "type": "Optional[Callable[[str], None]]",
            "description": "An optional callback function to report progress updates during execution."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "A compiled markdown report containing analysis results for each notebook."
          },
          {
            "name": "metrics",
            "type": "Dict[str, Union[str, float]]",
            "description": "A dictionary containing timing and model-related metrics for the workflow execution."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, and backend.main.update_status.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The function `gemini_payload` constructs a structured payload for use with a Gemini-based API by combining basic information, a notebook path, and XML content with embedded image placeholders. It processes the XML content to identify image placeholders, replaces them with base64-encoded image data from a provided list, and builds a list of text and image components suitable for multimodal input. The resulting payload is returned as a list of dictionaries, each representing either a text segment or an image component.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "Any",
            "description": "A data structure containing basic information to be included in the payload."
          },
          {
            "name": "nb_path",
            "type": "Any",
            "description": "The path to the current notebook, included in the payload for context."
          },
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML content of the notebook, which may contain image placeholders."
          },
          {
            "name": "images",
            "type": "List[Dict[str, Any]]",
            "description": "A list of image data dictionaries, each containing at least a 'data' key with base64-encoded image data."
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries representing the constructed payload, where each dictionary contains either a 'text' or 'image_url' component."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not under the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to represent the package correctly.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The function encrypts a given text string using a Fernet cipher suite. It first checks if the input text is empty or if the cipher suite is not available; in such cases, it returns the input text unchanged. If both conditions are satisfied, it encodes the stripped text to bytes, encrypts it using the cipher suite, and then decodes the result back to a string for return.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text string to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted version of the input text, or the original text if encryption was not performed."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The function decrypt_text is designed to decrypt a given encrypted text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available, returning the original text in such cases. If both conditions are met, it attempts to decrypt the text by encoding it, decrypting it with the cipher suite, and then decoding it back to a string. In case of any exception during decryption, it gracefully returns the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The encrypted text that needs to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str",
            "description": "The decrypted text if the decryption process succeeds; otherwise, the original input text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. The password is hashed using a hasher utility before being stored. The function also initializes additional fields such as API keys with empty strings. It returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user, used as the '_id' field in the database."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The plain text password of the user, which gets hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The unique identifier of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It performs a database query to find all records and returns them as a list. The function does not take any parameters and directly accesses a global or module-level variable 'dbusers' which is expected to be a MongoDB collection object.",
        "parameters": [],
        "returns": [
          {
            "name": "result",
            "type": "list",
            "description": "A list containing all user documents retrieved from the 'dbusers' MongoDB collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The function fetch_user retrieves a user document from a MongoDB collection named 'dbusers' based on the provided username. It uses the find_one method to search for a document where the '_id' field matches the given username. The function does not perform any additional processing or validation on the retrieved data before returning it.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to locate the specific user document in the database."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "Any",
            "description": "The user document retrieved from the 'dbusers' collection, or None if no matching document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name field of a user document in a MongoDB collection identified by the user's username. It uses the MongoDB update_one method to modify only the name field, leaving other fields unchanged. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user whose name needs to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name value to set for the specified user."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates the Gemini API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key needs to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be stored for the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This indicates whether the user's API key was updated."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "This function updates the GPT API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key needs to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This indicates whether the user's GPT API key was updated."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and performs an update operation on the user document. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL needs to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new Ollama base URL to be set for the user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. Typically 1 if the user exists and the update was applied."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the OpenSRC API key for a given user in the database. It first encrypts the provided API key using an encryption function, then performs a MongoDB update operation to store the encrypted key under the user's document. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose OpenSRC API key needs to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The OpenSRC API key to be updated for the specified user. This key is stripped of leading/trailing whitespace before encryption."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. Typically 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open source base URL for a user in the database. It takes a username and a new open source base URL as inputs, strips any leading or trailing whitespace from the URL, and attempts to update the corresponding document in the 'dbusers' collection. The function returns the count of modified documents, which should be 1 if the update was successful or 0 if no matching document was found.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL needs to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open source base URL to be set for the user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This will typically be 1 if a matching document was found and updated, or 0 if no matching document was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str or None",
            "description": "The Gemini API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The function retrieves a GPT API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gpt_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the OpenSource API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'opensrc_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to look up the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The OpenSource API key if a user is found; otherwise, None."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "The function retrieves the open source base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'opensrc_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose open source base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str or None",
            "description": "The open source base URL associated with the user, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The function 'delete_user' removes a user document from a MongoDB collection based on the provided username. It uses the 'delete_one' method to target a specific user identified by the '_id' field and returns the count of deleted documents. This operation is typically used to permanently remove a user account from the database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, typically 1 if the user was found and deleted, or 0 if no matching document was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys associated with a given username from a database. It fetches user data, decrypts sensitive API keys using a decryption function, and returns both decrypted keys and related URLs. The function handles cases where the user may not exist by returning None for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key for the user, or an empty string if not found."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL for the user, or an empty string if not found."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSRC base URL for the user, or an empty string if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The function 'insert_chat' creates a new chat entry in a database collection. It generates a unique identifier using UUID, assigns the provided username and chat name, and records the current timestamp. The function then inserts this chat document into the database and returns the ID of the newly inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "result.inserted_id",
            "type": "str",
            "description": "The unique identifier of the newly inserted chat document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet den Benutzernamen als Filterkriterium und sortiert die Ergebnisse nach dem Erstellungsdatum in aufsteigender Reihenfolge. Das Ergebnis ist eine Liste der Chat-Dokumente, die dem Benutzer zugeordnet sind.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "Der Benutzername des Benutzers, dessen Chats abgerufen werden sollen."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "Eine Liste von Chat-Dokumenten, die dem angegebenen Benutzernamen zugeordnet sind und nach Erstellungsdatum sortiert sind."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a lookup using MongoDB's find_one method with a query that matches both the username and chat name. The result is evaluated to determine if the chat exists, returning a boolean value indicating the presence or absence of the chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if a chat with the specified username and chat_name exists in the database; False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and updates all associated exchanges in the database. It first updates the chat entry in the chats collection, then updates all related exchange entries in the exchanges collection. The function returns the number of modified chat documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to assign to the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of chat documents that were successfully modified during the renaming operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The function inserts a new exchange record into a MongoDB collection. It generates a unique ID for the exchange, constructs a dictionary with all the provided details including optional fields with default values, and attempts to insert this document into the database. If the insertion fails, it catches the exception, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in response to the question."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback associated with the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used in the exchange, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main component used in the exchange, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Total time taken for the exchange, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Time taken by the helper component, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Time taken by the main component, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Number of JSON tokens used, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Number of Toon tokens used, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Percentage saved during the exchange, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique ID generated for the inserted exchange record, or None if insertion failed."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves all exchange records from a MongoDB collection for a given username, sorted by creation timestamp in ascending order. It queries the 'dbexchanges' collection using the provided username as a filter and sorts the results by the 'created_at' field. The function returns the list of matching exchange records.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchange records by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange records matching the provided username, sorted by creation timestamp."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with specific criteria and orders the results by creation date in ascending order. The function returns the fetched exchanges as a list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the exchanges to be retrieved."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat associated with the exchanges to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange documents matching the provided username and chat name, sorted by creation date in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "The function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document with the new feedback value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The feedback value to be set in the document."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified as a result of the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message associated with a specific exchange ID in a MongoDB collection. It uses the 'update_one' method to modify a document where the '_id' field matches the provided exchange ID, setting the 'feedback_message' field to the new value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be set for the specified exchange."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes a document from the 'dbexchanges' collection in a MongoDB database based on a given exchange ID. It performs a deletion operation and returns the count of deleted documents. The function takes a single string parameter representing the unique identifier of the exchange to be deleted.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "A string representing the unique identifier of the exchange document to be deleted."
          }
        ],
        "returns": [
          {
            "name": "result.deleted_count",
            "type": "int",
            "description": "The number of documents that were deleted as a result of the operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The function deletes all exchanges and the chat itself associated with a given username and chat name from the database. It first removes all exchange records matching the criteria, then deletes the chat record itself. The function returns the count of deleted chat documents, which indicates whether the operation was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "del_chat.deleted_count",
            "type": "int",
            "description": "The number of chat documents that were deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The function 'clean_names' takes a list of strings representing model paths and extracts the final component of each path, effectively removing directory prefixes. It uses list comprehension to process each element in the input list by splitting on the '/' character and selecting the last segment.",
        "parameters": [
          {
            "name": "model_list",
            "type": "List[str]",
            "description": "A list of strings where each string represents a full path to a model, typically including directory components separated by '/'."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "List[str]",
            "description": "A list of strings containing only the final component of each path in the input list."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The function filters a given list of models based on a specified category name. It retrieves keywords associated with the category and applies filtering logic to either return models that exist in a standard list or models whose names contain any of the retrieved keywords. If no filtering criteria are met, it defaults to returning the original list.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "A list of model names to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category used to determine filtering criteria."
          }
        ],
        "returns": [
          {
            "name": "filtered_models",
            "type": "list",
            "description": "A list of model names that match the filtering criteria. If no filtering is applied, the original source_list is returned."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function handles the saving of a Gemini API key entered by the user in a Streamlit frontend application. It retrieves the key from the session state, updates the database with the new key for the current user, clears the input field, and displays a success message to the user. The function is designed to be triggered by a UI event such as a button click.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function retrieves an Ollama URL from the Streamlit session state and updates the database with the new URL for the current user. It also displays a success toast message upon completion. The function does not perform any validation on the URL format or existence.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_ollama_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The function loads chat and exchange data from a database for a given username, ensuring that data is only fetched when necessary based on session state. It initializes session state variables for chats and active chat, handles legacy support for exchanges, and ensures a default chat exists if none are present. The function interacts with database functions to retrieve chats and exchanges, and inserts a new chat if needed.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which chat and exchange data should be loaded from the database."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value for a given exchange object and persists the change to the database. It also triggers a re-render of the Streamlit application to reflect the updated feedback value. The function takes two arguments: an exchange dictionary and a new feedback value. It modifies the exchange dictionary in place by updating its 'feedback' key, then calls a database update function to save the change, and finally reruns the Streamlit app.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing an exchange object, expected to contain keys such as 'feedback' and '_id'."
          },
          {
            "name": "val",
            "type": "Any",
            "description": "The new feedback value to be assigned to the exchange object."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "This function handles the deletion of an exchange from the database and updates the session state to reflect the removal of the exchange from the specified chat. It first deletes the exchange from the database using its ID, then checks if the exchange exists in the session state for the given chat and removes it if found. Finally, it triggers a rerun of the Streamlit app to update the UI.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is to be removed."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_exchange_by_id",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The function handles the deletion of a chat by first removing the chat data from the database using a database function, then cleaning up the session state by removing the deleted chat. If no chats remain after deletion, it creates a new default chat and sets it as the active one. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_full_chat, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from any URL present in that text. It uses regular expressions to find a URL, parses it using urllib.parse.urlparse, and then extracts the last segment of the URL path, which typically represents the repository name. If the extracted name ends with '.git', it removes the extension. If no URL is found or the path is empty, the function returns None.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string that may contain a URL from which the repository name is to be extracted."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name from the URL, with the '.git' suffix removed if present. Returns None if no valid URL is found or if the path is empty."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The function 'stream_text_generator' takes a string of text as input and yields each word from the text followed by a space, with a small delay of 0.01 seconds between each word. This creates a streaming effect where words are produced one at a time. The function uses the 'time.sleep' function to introduce the delay, making it suitable for simulating real-time text output.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string of text that will be split into words and yielded one at a time."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text based on Mermaid code block delimiters and handles regular text and Mermaid diagrams differently. Regular text is rendered using Streamlit's markdown or streaming capabilities, while Mermaid diagrams are rendered using a dedicated mermaid component. If rendering fails, it falls back to displaying the diagram as plain code.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "A string containing markdown text that may include Mermaid diagram code blocks."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A boolean flag indicating whether to stream the regular text content instead of rendering it directly."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "frontend.frontend.stream_text_generator",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function renders a chat exchange in a Streamlit interface, displaying a user question and an assistant's response. It handles both regular responses and error cases, providing interactive feedback mechanisms such as like/dislike buttons, comment popovers, download options, and delete functionality. The function uses Streamlit components to build a rich UI with toolbars, containers, and various interactive elements.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the question, answer, feedback information, and ID."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat, used for handling deletion operations."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, frontend.frontend.render_text_with_mermaid",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse Python Abstract Syntax Tree (AST) nodes and collect structural information about modules, including imports, classes, and functions. It extends the standard `ast.NodeVisitor` to customize traversal behavior for extracting schema details such as identifiers, source code segments, and contextual metadata. The visitor maintains internal state to track the current class during traversal and builds a hierarchical schema representation.",
        "init_method": {
          "description": "Initializes the ASTVisitor with source code, file path, and project root. It computes the module path using a helper function, initializes an empty schema structure to store collected information, and sets up tracking for the current class being visited.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The full source code of the file being analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The file path of the source code being processed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project for resolving relative paths."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import statements in the AST by extracting the names of imported modules and appending them to the schema's imports list. It iterates over all aliases in the import node and adds their names to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering an import node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes 'from ... import ...' statements by extracting module and alias names and appending them to the schema's imports list in the format 'module.alias'. It handles multiple aliases in a single import statement.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering an import from node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Visits class definitions in the AST and creates a structured representation of the class, including its identifier, name, docstring, source code segment, and line numbers. It appends this information to the schema's classes list and tracks the current class being processed.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering a class definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Handles function definitions in the AST. If a class is currently being processed, it records the function as a method within that class's context. Otherwise, it treats the function as a top-level function and stores its details in the schema's functions list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering a function definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles asynchronous function definitions by delegating to the regular function visitor method. This ensures that async functions are treated similarly to regular functions in terms of schema collection.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering an async function definition node."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.AST_Schema.path_to_module for computing module paths.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Tree (AST) and merging relationship data such as function calls, method dependencies, and class instantiations. It constructs a schema representation of the codebase that includes information about imports, functions, classes, and their contextual relationships. The class provides two main functionalities: one for building a schema from a list of files and another for enriching that schema with call graph information.",
        "init_method": {
          "description": "Initializes an instance of the ASTAnalyzer class. The constructor currently does not perform any initialization actions.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "Merges relationship data (such as outgoing and incoming calls) into a full schema by updating function and class contexts with call information. It processes AST nodes to associate functions with their callers and callees, and classes with their dependencies based on method-level call graphs.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary representing the full schema of the repository, including file paths and their AST node structures."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "A dictionary containing raw relationship data with keys 'outgoing' and 'incoming', mapping identifiers to lists of called or calling entities."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "dict",
                  "description": "The updated full_schema with merged relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "Analyzes a list of files in a Git repository to construct a schema representation of the codebase. It parses each Python file's content into an AST, uses an ASTVisitor to extract structural elements like imports, functions, and classes, and builds a hierarchical schema organized by file path.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects containing file paths and content."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "An instance of GitRepository providing access to repository metadata."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "dict",
                  "description": "A dictionary representing the schema of the repository, organized by file paths and containing AST node information."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.AST_Schema.ASTVisitor class during AST traversal.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.AST_Schema.ASTVisitor class for AST traversal and schema generation.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve Python file dependencies, particularly focusing on handling relative imports. It extends NodeVisitor to traverse AST nodes of Python files and builds a dependency graph by tracking import relationships. The class resolves relative imports by mapping them to actual module or symbol names based on file system checks and AST parsing of __init__.py files.",
        "init_method": {
          "description": "Initializes the FileDependencyGraph with a filename and repository root path. It sets up the necessary attributes to track dependencies and resolve imports.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for dependencies."
            },
            {
              "name": "repo_root",
              "type": "Any",
              "description": "The root directory of the repository being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "Resolves relative imports by analyzing the AST node of an import statement. It determines the actual module or symbol names that are imported, checking for their existence in the file system and validating against __init__.py exports. It raises an ImportError if no valid resolution can be made.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles Import nodes in the AST by adding the imported module names to the import_dependencies dictionary. It tracks which modules are imported by the current file.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "An AST node representing an import statement."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "The base name of the imported module, if available."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes ImportFrom nodes in the AST. It extracts module names and delegates to visit_Import to record dependencies. For relative imports, it attempts to resolve them using _resolve_module_name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class serves as a centralized interface for interacting with various language models, particularly for generating and validating code documentation for functions and classes. It supports multiple LLM providers including Google Gemini, OpenAI, custom APIs, and Ollama, and handles batching and rate limiting for efficient processing. The class initializes with configuration parameters such as API keys, prompt file paths, and model specifications, and provides two main methods for generating documentation: one for functions and one for classes.",
        "init_method": {
          "description": "Initializes the LLMHelper with API credentials, prompt files, and model configuration. It reads system prompts from specified files, configures batch settings based on the model name, and sets up appropriate LLM clients depending on the model type. It also prepares structured output configurations for function and class analysis using Pydantic models.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "API key for accessing the language model service."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "Path to the file containing the system prompt for function documentation generation."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "Path to the file containing the system prompt for class documentation generation."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "Name of the language model to use. Defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Base URL for custom API endpoints. Optional."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures the batch size for processing requests based on the specified model name. Different models have different optimal batch sizes for efficiency and performance, which are determined by a series of conditional checks. If the model name does not match any known configurations, a default conservative batch size is applied.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "Name of the language model for which to configure batch settings."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called internally during initialization to determine the appropriate batch size for the configured model.",
                "called_by": "This method is called by the __init__ method of the LLMHelper class."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Processes a batch of function inputs to generate and validate documentation using the configured LLM. It divides the input into manageable batches, constructs conversation messages with system prompts, and sends these to the LLM for structured output. The method includes error handling and rate-limiting mechanisms to ensure robust execution across large datasets.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function input objects containing details needed for documentation generation."
                }
              ],
              "returns": [
                {
                  "name": "List[Optional[FunctionAnalysis]]",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analysis outputs or None for failed entries."
                }
              ],
              "usage_context": {
                "calls": "This method calls the function_llm.batch() method to process batches of conversations and uses time.sleep() for rate limiting.",
                "called_by": "This method is called externally to generate documentation for functions."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Processes a batch of class inputs to generate and validate documentation using the configured LLM. Similar to the function generation method, it batches inputs, constructs conversation messages, and sends them to the LLM for structured output. It also includes error handling and rate-limiting to manage large-scale processing.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class input objects containing details needed for documentation generation."
                }
              ],
              "returns": [
                {
                  "name": "List[Optional[ClassAnalysis]]",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analysis outputs or None for failed entries."
                }
              ],
              "usage_context": {
                "calls": "This method calls the class_llm.batch() method to process batches of conversations and uses time.sleep() for rate limiting.",
                "called_by": "This method is called externally to generate documentation for classes."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed in the context.",
          "instantiated_by": "No instantiation locations are explicitly listed in the context."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs), including Google's Gemini, OpenAI's GPT, custom API endpoints, and local Ollama models. It initializes with an API key, a prompt file path, and model specifications, setting up the appropriate LLM client based on the model name. The class supports two primary interaction modes: synchronous calls via `call_llm` and streaming responses via `stream_llm`, both utilizing a system prompt loaded from a file.",
        "init_method": {
          "description": "Initializes the MainLLM instance by validating the API key, loading a system prompt from a specified file, and configuring the underlying LLM client based on the provided model name and configuration. It supports multiple LLM backends including Google Generative AI, OpenAI-compatible APIs, and Ollama.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key used for authenticating with the LLM service."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt used for initializing the LLM."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use. Defaults to 'gemini-2.5-pro'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Optional base URL for connecting to a custom LLM endpoint."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "Synchronously invokes the configured LLM with a user input message and a system prompt. It constructs the necessary message sequence and attempts to retrieve a complete response from the LLM. In case of errors, it logs the issue and returns None.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The content of the LLM's response if successful, otherwise None."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions defined in the class or elsewhere in the provided code.",
                "called_by": "This method is not called by any other function or method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "Initiates a streaming interaction with the configured LLM using a user input message and a system prompt. It yields content chunks from the LLM as they become available, allowing for real-time processing of responses. Errors during streaming are logged and yielded as error messages.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be streamed through the LLM."
                }
              ],
              "returns": [
                {
                  "name": "chunk_content",
                  "type": "str",
                  "description": "Yields content chunks from the LLM's streaming response or an error message upon failure."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call other functions defined in the class or elsewhere in the provided code.",
                "called_by": "This method is not called by any other function or method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several external libraries including langchain_google_genai.ChatGoogleGenerativeAI, langchain_ollama.ChatOllama, langchain_openai.ChatOpenAI, and langchain.messages.HumanMessage and SystemMessage for constructing messages.",
          "instantiated_by": "This class is not instantiated by any other component mentioned in the provided context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It initializes with a structured dictionary to hold extracted information and provides methods to parse and extract specific sections from these files. The class prioritizes information extraction from pyproject.toml, followed by requirements.txt, and finally README files. It handles encoding issues by cleaning content and supports fallback mechanisms for missing information.",
        "init_method": {
          "description": "Initializes the ProjektInfoExtractor with a predefined structure for storing project information. It sets up placeholders for various project details including overview and installation instructions, and defines a constant for indicating missing information.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from the input string, which can occur due to encoding errors when reading files in UTF-8 format but they were actually encoded in UTF-16. It ensures clean text processing by filtering out invalid characters.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The input string potentially containing null bytes."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "The cleaned string with null bytes removed."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called.",
                "called_by": "This method is called by other parsing methods like _parse_readme, _parse_toml, and _parse_requirements to sanitize input before further processing."
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches through a list of files to find one that matches any of the given filename patterns, ignoring case differences. It returns the first matching file or None if no match is found.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of filename patterns to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[Any]",
                  "description": "The first matching file object or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called.",
                "called_by": "This method is called by the extrahiere_info method to locate relevant project files like README, pyproject.toml, and requirements.txt."
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text content from a markdown document under a specified heading (marked by ##). It uses regular expressions to match the heading and capture everything until the next heading or end of the document.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The markdown content to parse."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords representing potential section headings to look for."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[str]",
                  "description": "The extracted content under the matched heading or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called.",
                "called_by": "This method is called by _parse_readme to extract specific sections like Features, Tech Stack, Status, Installation, and Quick Start from README files."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "Parses the content of a README file to extract project overview and installation details. It identifies the title, description, key features, tech stack, current status, setup instructions, and quick start guide using regex and helper methods.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize input and _extrahiere_sektion_aus_markdown to extract specific sections.",
                "called_by": "This method is called by extrahiere_info to process README content after identifying the relevant file."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "Parses the content of a pyproject.toml file to extract project metadata such as name, description, and dependencies. It uses the tomllib library to load TOML data and updates the internal info structure accordingly.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize input and handles exceptions related to TOML parsing.",
                "called_by": "This method is called by extrahiere_info to process pyproject.toml content after identifying the relevant file."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "Parses the content of a requirements.txt file to extract dependency information. It filters out comments and empty lines, then stores the dependencies in the info structure only if no dependencies have been previously found from other sources.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to sanitize input.",
                "called_by": "This method is called by extrahiere_info to process requirements.txt content after identifying the relevant file."
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "Orchestrates the extraction of project information by finding relevant files and delegating parsing tasks to appropriate methods. It prioritizes pyproject.toml over requirements.txt and README files, formats dependencies, and derives a default project title from the repository URL if needed.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through for project files."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository, used to derive a default project title if none is found."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information organized into overview and installation sections."
                }
              ],
              "usage_context": {
                "calls": "Calls _finde_datei to locate relevant files, and _parse_readme, _parse_toml, and _parse_requirements to process their contents.",
                "called_by": "This method is the main entry point for extracting project information and is likely called by higher-level components in the application."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed in the context.",
          "instantiated_by": "No instantiation context is provided in the input."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze Python source code using the Abstract Syntax Tree (AST) to construct a directed graph representing function call relationships. It tracks local definitions, imports, and class contexts to resolve function names and build edges between callers and callees. The class leverages the ast.NodeVisitor base class to traverse the AST nodes and records information about function definitions, imports, and calls to build a comprehensive call graph.",
        "init_method": {
          "description": "Initializes the CallGraph with a filename and sets up internal data structures including tracking for current function and class, local definitions, a NetworkX directed graph, import mappings, a set of function names, and a dictionary of edges.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for call graph construction."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "Recursively extracts the dotted name components from an AST node representing a function call. It traverses the AST to build a list of name components, which can represent modules, classes, or function names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "An AST node representing a function call or attribute access."
                }
              ],
              "returns": [
                {
                  "name": "parts",
                  "type": "list[str]",
                  "description": "A list of strings representing the dotted name components."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the _resolve_all_callee_names method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "Resolves a list of dotted name components into fully qualified names by checking local definitions, import mappings, and class context. It handles various naming conventions and constructs appropriate full names based on the context.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists containing name components for potential callees."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved fully qualified names for the callees."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "Constructs a fully qualified name for a function or method, incorporating the filename, optional class name, and the base name. This helps in uniquely identifying functions within the call graph.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name of the function or method."
                },
                {
                  "name": "class_name",
                  "type": "Optional[str]",
                  "description": "The name of the class if the function is a method."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The fully qualified name constructed from the filename, class name, and base name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_FunctionDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "Determines the current caller's name based on whether there is an active function or class context. If no function is active, it defaults to the global scope or the filename.",
              "parameters": [
                {
                  "name": "self",
                  "type": "CallGraph",
                  "description": "The instance of the CallGraph class."
                }
              ],
              "returns": [
                {
                  "name": "caller_name",
                  "type": "str",
                  "description": "The name of the current caller, either the function name or a default global scope identifier."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles the AST node for import statements. It maps imported module names to their actual module names, storing them in the import mapping dictionary for later resolution of function names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles the AST node for 'from ... import ...' statements. It maps imported names to their respective module names, updating the import mapping dictionary accordingly.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes AST nodes representing class definitions. It temporarily sets the current class name during traversal and restores the previous class name after processing the class body.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes AST nodes representing function definitions. It registers the function in local definitions, adds the function to the call graph, and manages the current function context during traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _make_full_name and generic_visit methods.",
                "called_by": "This method is called by the AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Processes AST nodes representing asynchronous function definitions. It delegates the processing to the visit_FunctionDef method since async functions are treated similarly to regular functions in terms of call graph construction.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Processes AST nodes representing function calls. It identifies the caller and resolves the callee names, then updates the call graph edges by adding connections between the caller and each resolved callee.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "An AST node representing a function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _current_caller, _recursive_call, and _resolve_all_callee_names methods.",
                "called_by": "This method is called by the AST traversal mechanism."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "Processes AST nodes representing conditional statements. It specifically handles cases where the condition checks for '__name__ == '__main__'' to treat the main block differently, setting a special caller name during traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "An AST node representing an if statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the AST traversal mechanism."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the ast module for parsing Python source code, networkx for creating the directed graph, and typing.Dict for type hinting.",
          "instantiated_by": "This class is instantiated by the getRepo.GitRepository and basic_info.ProjektInfoExtractor classes."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as content and size, ensuring efficient resource usage by only loading data when accessed. The class provides properties for accessing the file's blob, content, and size, along with utility methods for word count analysis and serialization to dictionary format.",
        "init_method": {
          "description": "Initializes a RepoFile object with a file path and a commit tree. It sets up internal attributes to store the file path, the commit tree reference, and placeholders for the blob, content, and size which are lazily loaded upon first access.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "A property that lazily loads and returns the Git blob object associated with the file. If the blob has not yet been loaded, it attempts to retrieve it from the commit tree using the stored file path. If the file is not found in the tree, a FileNotFoundError is raised.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "A property that lazily loads and returns the decoded content of the file. It reads the data stream from the blob and decodes it as UTF-8 text, ignoring encoding errors. The content is cached after the first access to avoid repeated decoding operations.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "A property that lazily loads and returns the size of the file in bytes. It retrieves the size directly from the blob object and caches it after the first access to avoid redundant lookups.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "An example analysis method that counts the number of words in the file's content. It splits the content on whitespace and returns the length of the resulting list, providing a simple way to analyze textual content.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The total number of words in the file's content."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Provides a string representation of the RepoFile object, useful for debugging and logging purposes. It displays the file path in a readable format.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr",
                  "type": "str",
                  "description": "A string representation of the RepoFile object including the file path."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Serializes the RepoFile object into a dictionary format, optionally including the file's content. It includes basic metadata such as path, name, size, and type, and conditionally adds the content if requested.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "If True, includes the file's content in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other functions according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the 'tempfile', 'git.Repo', 'git.GitCommandError', 'logging', and 'os' modules.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to its files through RepoFile objects. It supports listing all files, retrieving a hierarchical file tree, and cleaning up the temporary directory upon closing. The class implements context manager protocols (__enter__ and __exit__) to facilitate automatic resource management.",
        "init_method": {
          "description": "Initializes a GitRepository instance by cloning the specified repository URL into a temporary directory. It sets up necessary attributes like the repository URL, temporary directory path, and references to the cloned repository and its latest commit. If cloning fails, it raises a RuntimeError after cleaning up resources.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "Retrieves a list of all files in the repository and creates RepoFile objects for each file. It uses git ls-files to obtain the file paths and constructs RepoFile instances with the commit tree for each file.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile class to instantiate file objects.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "Deletes the temporary directory and its contents associated with the repository. It prints a message indicating the deletion and resets the temp_dir attribute.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "Enables the use of the GitRepository instance in a 'with' statement, returning the instance itself for use within the context block.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "GitRepository",
                  "description": "Returns the GitRepository instance."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "Handles cleanup when exiting a 'with' block by calling the close method to delete the temporary directory.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "exc_type",
                  "type": "Any",
                  "description": "Exception type if an exception occurred in the with block."
                },
                {
                  "name": "exc_val",
                  "type": "Any",
                  "description": "Exception value if an exception occurred in the with block."
                },
                {
                  "name": "exc_tb",
                  "type": "Any",
                  "description": "Exception traceback if an exception occurred in the with block."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "Constructs a hierarchical tree representation of the repository's file structure. If no files have been retrieved yet, it first calls get_all_files to populate the internal list of files. Then, it iterates over these files to build a nested dictionary structure reflecting the directory hierarchy.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Flag indicating whether to include file content in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the hierarchical file tree structure."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods directly.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.getRepo.RepoFile class.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is responsible for analyzing Python project structures to build a call graph that represents relationships between functions, classes, and methods. It traverses Python files in a given project root directory, collects definitions (functions, classes, methods) along with their locations, and resolves inter-function calls to construct a detailed call graph. The analyzer also provides functionality to retrieve raw relationship data in terms of outgoing and incoming call relationships.",
        "init_method": {
          "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including a dictionary for storing definitions, a call graph represented as a defaultdict, and a mapping of file paths to ASTs. It also defines a set of directories to ignore during file traversal.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory path of the Python project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "The main analysis method that orchestrates the process of finding Python files, collecting definitions from those files, and resolving inter-function calls. It clears the AST cache after processing and returns the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "defaultdict(list)",
                  "description": "A dictionary mapping callee identifiers to lists of caller information."
                }
              ],
              "usage_context": {
                "calls": "This method internally calls `_find_py_files`, `_collect_definitions`, and `_resolve_calls`.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "Transforms the internal call graph into a more accessible format by separating outgoing and incoming relationships. It organizes these relationships into dictionaries keyed by identifiers, with values being sorted lists of related identifiers.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing 'outgoing' and 'incoming' keys mapping identifiers to sorted lists of related identifiers."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods according to the provided context.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "Recursively walks through the project root directory to find all Python (.py) files, excluding certain directories such as .git, venv, etc. It returns a list of absolute paths to these files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list[str]",
                  "description": "A list of absolute file paths ending in .py."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods according to the provided context.",
                "called_by": "This method is called by the `analyze` method."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "Parses a Python file's source code into an Abstract Syntax Tree (AST) and extracts definitions of functions, classes, and methods. It associates each definition with metadata like file path, line number, and type, storing them in the internal definitions dictionary.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file to be parsed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls `path_to_module` to derive module paths from file paths.",
                "called_by": "This method is called by the `analyze` method."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "Traverses the AST to find the parent node of a given AST node. This is used to determine if a function or method is defined within a class.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The AST tree to search within."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node whose parent is to be found."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST or None",
                  "description": "The parent AST node of the specified node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods according to the provided context.",
                "called_by": "This method is called by `_collect_definitions`."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "Uses a CallResolverVisitor to traverse the AST of a Python file and resolve function calls. It updates the internal call graph with the resolved calls.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file whose calls are to be resolved."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method instantiates and uses `CallResolverVisitor` to visit the AST and collect call information.",
                "called_by": "This method is called by the `analyze` method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.relationship_analyzer.CallResolverVisitor and backend.relationship_analyzer.path_to_module modules.",
          "instantiated_by": "This class is not instantiated by any other code based on the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is an AST (Abstract Syntax Tree) visitor designed to analyze Python code and track function calls, class definitions, and variable assignments within a given file. It maintains scope information, resolves qualified names for functions and methods, and records call relationships between different parts of the codebase. This class is particularly useful for static analysis tools that need to understand the flow of calls and dependencies in Python projects.",
        "init_method": {
          "description": "Initializes the CallResolverVisitor with a file path, project root directory, and a set of definitions. It sets up internal tracking structures such as scope, instance types, and call records, and computes the module path based on the file path and project root.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The absolute path to the Python file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project, used to compute relative module paths."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary mapping qualified names to their definitions, used for resolving call targets."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles the visiting of class definitions in the AST. It updates the current class name context during traversal and ensures that the previous class name is restored after processing the class definition.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing the class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor when encountering a class definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definitions in the AST. It manages the caller name context by setting the full identifier of the function (including class context if applicable) before traversing the function body and restoring the previous caller name afterward.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing the function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor when encountering a function definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes function calls in the AST. It resolves the qualified name of the called function, checks if it exists in the definitions, and records the call relationship including the caller's type and location.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing the function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor when encountering a function call node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import statements in the AST. It maps imported names to their actual module paths in the scope dictionary, allowing for later resolution of qualified names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing the import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor when encountering an import node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes 'from ... import ...' statements in the AST. It resolves the full module path for imports and maps the imported names to their qualified names in the scope dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing the 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor when encountering an 'import from' node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Handles assignment statements in the AST. Specifically, it identifies assignments where the right-hand side is a call to a class constructor, and records the type of the assigned variable.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node representing the assignment statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the generic AST visitor when encountering an assignment node."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the qualified name of a function call node. It handles both direct name lookups and attribute-based calls (like obj.method). It checks the scope and local definitions to determine the fully qualified name of the called function.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.expr",
                  "description": "The AST node representing the function being called."
                }
              ],
              "returns": [
                {
                  "name": "qualified_name",
                  "type": "str or None",
                  "description": "The fully qualified name of the function if resolved, otherwise None."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the visit_Call method to resolve the qualified name of a function call."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.relationship_analyzer.path_to_module utility function to compute module paths.",
          "instantiated_by": "This class is not directly instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the structure of a single parameter within a function. It enforces that each parameter has a name, a type, and a descriptive string, making it suitable for use in API schemas or documentation systems where parameter metadata needs to be consistently structured and validated.",
        "init_method": {
          "description": "The class is initialized with three required fields: name, type, and description. These fields define the essential properties of a function parameter.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The data type of the parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A human-readable description of the parameter's purpose."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed for this class.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic BaseModel designed to represent and validate the description of a function's return value. It encapsulates three essential properties: the name of the return value, its type, and a textual description. This class ensures that any return value metadata adheres to a consistent structure, making it suitable for use in API documentation, code analysis tools, or any system requiring standardized return value specifications.",
        "init_method": {
          "description": "The class is initialized with three required fields: 'name', 'type', and 'description'. These fields define the core attributes of a return value description. Since this class inherits from pydantic.BaseModel, it automatically gains validation capabilities based on the type hints provided.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model designed to represent and validate the calling context of a function, specifically capturing information about what functions are called and by whom. It serves as a structured data container for describing the relationships between functions in a codebase.",
        "init_method": {
          "description": "Initializes a UsageContext instance with two string fields: 'calls' and 'called_by'. These fields are intended to store textual descriptions of the functions being called and the functions that call them, respectively.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string describing the functions or methods that are called within the context."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string describing the function or method that calls the current function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not explicitly instantiated in the provided context, suggesting it may be used indirectly or in a different part of the codebase."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed information about a function's purpose, parameters, return values, and usage context. It serves as a structured representation for documenting function signatures and behavior, making it easier to analyze and communicate function details within a codebase.",
        "init_method": {
          "description": "The constructor initializes the FunctionDescription instance with required fields: overall description, a list of parameter descriptions, a list of return value descriptions, and a usage context object. It leverages Pydantic's BaseModel for data validation and serialization.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports list, which includes standard typing utilities and Pydantic components.",
          "instantiated_by": "This class is not instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class is a Pydantic model designed to represent the complete JSON schema for a function. It encapsulates essential information about a function including its unique identifier, a detailed description, and an optional error field for capturing validation issues.",
        "init_method": {
          "description": "Initializes a FunctionAnalysis instance with required fields for the function's identifier and description, along with an optional error field.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object containing detailed information about the function's purpose, parameters, and return values."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store any validation errors encountered during processing."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It captures a textual description of the constructor and a list of parameter descriptions that define its inputs.",
        "init_method": {
          "description": "Initializes a ConstructorDescription instance with a description of the constructor and a list of ParameterDescription objects representing its parameters.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the constructor's purpose and behavior."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component as indicated in the context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model designed to encapsulate information about a class's external dependencies and the entities that instantiate it. It serves as a structured representation of metadata related to class usage and integration within a system.",
        "init_method": {
          "description": "Initializes a ClassContext instance with two string attributes: 'dependencies' and 'instantiated_by'. These fields store information about the class's external dependencies and the entities responsible for its instantiation.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string describing the entities or components that instantiate the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to encapsulate a comprehensive analysis of a Python class. It holds information about the class's overall purpose, its constructor details, a list of its methods along with their descriptions, and contextual usage information. This class serves as a structured representation for documenting and communicating the essential characteristics and behaviors of a class within a codebase.",
        "init_method": {
          "description": "Initializes a new instance of the ClassDescription class. The constructor takes parameters corresponding to the fields defined in the class, including overall description, constructor details, a list of method analyses, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose and functionality of the class being analyzed."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object containing detailed information about the class's constructor, including its parameters and initialization logic."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects, each representing a method within the class and its associated metadata."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing contextual information about how the class is used, such as dependencies and instantiation points."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components as indicated in the context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as the primary data model for representing the complete JSON schema of a class. It encapsulates essential information about a class including its identifier, a detailed description, and an optional error field for capturing any issues during processing.",
        "init_method": {
          "description": "Initializes a new instance of the ClassAnalysis class with required fields for the identifier and description, along with an optional error field.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An instance of ClassDescription providing detailed information about the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to capture any errors encountered during class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It serves as a data structure to capture metadata related to how functions are invoked within the system.",
        "init_method": {
          "description": "Initializes a CallInfo instance with attributes representing a call event, including the file path, function name, call mode, and line number.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file path where the call occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that made the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, such as 'method', 'function', or 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number in the file where the call occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were identified for this class.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to represent structured context for analyzing a function. It encapsulates two key pieces of information: a list of function names that the analyzed function calls, and a list of CallInfo objects indicating which functions call the analyzed function. This model serves as a data structure for tracking and documenting the call relationships within a codebase.",
        "init_method": {
          "description": "Initializes the FunctionContextInput instance with two attributes: 'calls', a list of strings representing function names called by the analyzed function, and 'called_by', a list of CallInfo objects representing functions that call the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the names of functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are explicitly listed for this class.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class serves as a data structure to encapsulate all necessary inputs required for generating a FunctionAnalysis object. It defines the expected fields including the mode, identifier, source code, imports, and contextual information needed for function analysis.",
        "init_method": {
          "description": "Initializes the FunctionAnalysisInput instance with the required fields: mode, identifier, source_code, imports, and context. The mode is constrained to the literal value 'function_analysis', ensuring type safety and correct usage of the class.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "A literal string value that must be 'function_analysis' to ensure correct instantiation."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements used in the function's source code."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "An object containing contextual information about the function's environment and usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on pydantic.BaseModel for data validation and typing modules for type hints.",
          "instantiated_by": "This class is instantiated by components responsible for preparing input data for function analysis tasks."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to represent structured context information for a class's methods. It encapsulates details such as the method's identifier, the methods it calls, the methods that call it, its arguments, and its docstring. This class serves as a data transfer object for method context metadata, enabling consistent representation and validation of method-related information.",
        "init_method": {
          "description": "The constructor initializes the MethodContextInput instance with fields for storing method context information including identifier, list of called methods, list of callers, method arguments, and an optional docstring.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the identifiers of methods called by this method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the methods that call this method."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of strings representing the argument names of the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "An optional string containing the docstring of the method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to encapsulate structured context information for analyzing a class. It holds three main pieces of information: a list of dependencies, a list of call information for instances where the class is instantiated, and a list of method context inputs for each method within the class.",
        "init_method": {
          "description": "The constructor initializes the ClassContextInput instance with three attributes: dependencies, instantiated_by, and method_context. These attributes are expected to hold lists of strings, CallInfo objects, and MethodContextInput objects respectively.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of string identifiers representing the dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects detailing where and how the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects providing context for each method within the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class serves as a data structure for encapsulating the necessary inputs required to generate a ClassAnalysis object. It defines the expected fields including the mode of operation, a unique identifier for the class being analyzed, the source code of the class, a list of import statements, and contextual information about the class.",
        "init_method": {
          "description": "Initializes the ClassAnalysisInput instance with the required fields: mode, identifier, source_code, imports, and context. The mode is constrained to the literal value 'class_analysis', ensuring that only class analysis operations can instantiate this object.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "A literal string that specifies the mode of operation as 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements associated with the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "Contextual information related to the class being analyzed."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports list.",
          "instantiated_by": "This class is not instantiated by any other classes or functions based on the provided context."
        }
      },
      "error": null
    }
  }
}