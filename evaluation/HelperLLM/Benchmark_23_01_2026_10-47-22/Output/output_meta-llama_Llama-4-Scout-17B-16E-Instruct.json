{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "This function converts a file path into a Python module path. It takes a file path and a project root directory as input, and returns the corresponding module path. The function handles cases where the file path is not relative to the project root. It also removes the '.py' extension and replaces directory separators with dots to form the module path.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The file path to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The module path corresponding to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies within a repository. It utilizes an Abstract Syntax Tree (AST) visitor to traverse the AST of a given file, identifying import dependencies. These dependencies are then used to populate a directed graph, where nodes represent files and edges signify import relationships.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which to construct the dependency graph."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The Abstract Syntax Tree of the file."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.FileDependencyGraph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between files in a Git repository. It iterates over all Python files in the repository, builds a dependency graph for each file using the `build_file_dependency_graph` function, and then aggregates these graphs into a single, global graph. The function returns this global graph as a networkx DiGraph object.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository for which to build the dependency graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "The aggregated dependency graph for the entire repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.build_file_dependency_graph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves a list of all Python files within a specified directory and its subdirectories. It uses the pathlib library to handle file paths. The function takes a directory path as input, resolves it to an absolute path, and then uses the rglob method to find all files with the .py extension. The results are returned as a list of relative paths.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of pathlib.Path objects representing the Python files found, relative to the root directory."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "This function serves as a main orchestrator for testing the LLMHelper class. It defines pre-computed analyses for multiple methods, including 'add_item', 'check_stock', and 'generate_report'. These analyses are then used to generate documentation for the InventoryManager class.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "LLMHelper, FunctionAnalysisInput.model_validate, ClassAnalysisInput",
          "called_by": ""
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "This function generates a DOT file from a directed graph, ensuring node names are safe for use in the DOT language. It creates a mapping of original node names to safe names, relabels the graph nodes, and then writes the graph to a file in DOT format.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input directed graph to be converted."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT file will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "This function constructs a filtered call graph from a given Git repository, focusing only on functions written by the user. It iterates through all Python files in the repository, parses their abstract syntax trees (ASTs), and extracts function definitions and call relationships. The function then builds a directed graph (nx.DiGraph) representing the call relationships between user-defined functions.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "The Git repository object from which to extract the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the filtered call relationships between user-defined functions in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.callgraph.CallGraph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "This function takes a content string as input and wraps it in CDATA (Character Data) tags, which are used in XML to escape a block of text so that it is treated as character data, not as XML markup.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content string to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The `extract_output_content` function processes a list of output objects and extracts text or image data. It handles images by decoding Base64 strings to bytes and returns a list of text strings or placeholders. The function iterates through each output object, checks its type, and extracts relevant data. It prioritizes 'image/png' over 'image/jpeg' when processing images.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of output objects containing data to be extracted."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list to store image data in the form of dictionaries with 'mime_type' and 'data' keys."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of extracted text strings or image placeholders."
          }
        ],
        "usage_context": {
          "calls": "This function calls the `process_image` helper function with 'image/png' and 'image/jpeg' mime types.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The `process_image` function processes a given image MIME type by retrieving its base64 encoded string from a data dictionary, cleaning the string, and adding it to a list of images. It then returns an XML placeholder for the image. If the MIME type is not found in the data or an exception occurs during processing, it returns an error message or None, respectively.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "xml_placeholder",
            "type": "str",
            "description": "An XML placeholder for the image if successful, an error message if not."
          },
          {
            "name": "None",
            "type": "None",
            "description": "If the MIME type is not found in the data."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "This function converts a notebook file content into XML format. It reads the notebook using nbformat, processes each cell based on its type (markdown or code), and constructs XML parts accordingly. The function handles errors during JSON/Notebook parsing and returns the XML content along with any extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the notebook file to be converted."
          }
        ],
        "returns": [
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML representation of the notebook content."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of images extracted during the conversion process."
          }
        ],
        "usage_context": {
          "calls": "This function calls extract_output_content and wrap_cdata.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files, identifies Jupyter notebook files (.ipynb), converts their content to XML, and returns a dictionary with the conversion results. It logs information about the number of notebooks found and the processing of each notebook. The function utilizes an external converter function to perform the notebook-to-XML conversion.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of files in the repository, where each file is expected to have a 'path' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary where keys are the paths of the processed notebook files and values are dictionaries containing the XML output and a list of images."
          }
        ],
        "usage_context": {
          "calls": "This function calls the convert_notebook_to_xml function from the backend.converter module.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "This function creates a bar chart comparing JSON and TOON tokens, highlighting the savings percentage, and saves it to a specified output path.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage of savings."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function 'calculate_net_time' calculates the net time by subtracting sleep times from the total duration, considering rate limits for the 'gemini-' model. It takes into account the number of batches and the sleep count to determine the total sleep time. If the model name does not start with 'gemini-', it returns the total duration. The function handles edge cases such as zero total items or non-positive net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "datetime",
            "description": "The start time of the process."
          },
          {
            "name": "end_time",
            "type": "datetime",
            "description": "The end time of the process."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items to process."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The batch size for processing items."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model, which affects rate limiting if it starts with 'gemini-'."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "int",
            "description": "The net time after subtracting sleep times from the total duration."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is the primary entry point for the backend analysis process. It takes in user input, API keys, and model names, and orchestrates the cloning of a repository, extraction of project information, and analysis of the project's codebase using various LLMs (Large Language Models). The function returns a final report and metrics about the analysis process.",
        "parameters": [
          {
            "name": "input",
            "type": "string",
            "description": "The user input to be analyzed."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary of API keys for various LLMs."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary of model names for the LLMs."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "An optional callback function to update the status of the analysis process."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "string",
            "description": "The final report generated by the analysis process."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary of metrics about the analysis process, including time taken and token usage."
          }
        ],
        "usage_context": {
          "calls": "This function calls the following functions: ASTAnalyzer, ASTAnalyzer.analyze_repository, ASTAnalyzer.merge_relationship_data, LLMHelper, LLMHelper.generate_for_classes, LLMHelper.generate_for_functions, MainLLM, MainLLM.call_llm, ProjektInfoExtractor, ProjektInfoExtractor.extrahiere_info, GitRepository, calculate_net_time, create_savings_chart, update_status, ProjectAnalyzer, ProjectAnalyzer.analyze, ProjectAnalyzer.get_raw_relationships.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The `update_status` function updates the status by invoking a callback function with a given message and logging the message at the info level.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be used for updating the status."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function is designed to process a repository of notebooks through a specified model (e.g., GPT, Gemini). It extracts information, generates reports for each notebook, and saves these reports to a file. The function takes an input string, API keys, a model name, and an optional status callback. It clones a Git repository from a URL found in the input, processes the notebooks, and then uses an LLM (Large Language Model) to generate reports. The function handles exceptions, logs events, and returns a final report along with processing metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "string",
            "description": "The input string containing a URL to a Git repository."
          },
          {
            "name": "api_keys",
            "type": "object",
            "description": "A dictionary of API keys for different models."
          },
          {
            "name": "model",
            "type": "string",
            "description": "The name of the model to use for processing (e.g., 'gpt-', 'gemini-', etc.)."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "An optional callback function to update the status."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "string",
            "description": "The final report generated from processing all notebooks."
          },
          {
            "name": "metrics",
            "type": "object",
            "description": "A dictionary of metrics related to the processing time and model used."
          }
        ],
        "usage_context": {
          "calls": "This function calls the following functions: backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The `gemini_payload` function constructs a payload for the Gemini model by combining context information, notebook XML structure, and image data. It takes in basic information, a notebook path, XML content, and image data, and returns a list of payload content. The function uses regular expressions to find image placeholders in the XML content and replaces them with base64-encoded image data.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "object",
            "description": "Basic information about the project"
          },
          {
            "name": "nb_path",
            "type": "string",
            "description": "The current notebook path"
          },
          {
            "name": "xml_content",
            "type": "string",
            "description": "The XML content of the notebook"
          },
          {
            "name": "images",
            "type": "array",
            "description": "A list of image data"
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "array",
            "description": "A list of payload content, including text and image data"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "This function converts a file path into a Python module path. It takes a file path and a project root directory as input, calculates the relative path, and then transforms it into a module path by replacing directory separators with dots. The function also handles cases where the file path is absolute or the file has a .py extension.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to the file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The module path equivalent to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "This function encrypts a given text using a cipher suite. If the input text is empty or the cipher suite is not available, it returns the original text. The function appears to be part of a larger system that handles encryption and decryption of text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text if encryption is successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "This function decrypts a given text using a cipher suite. If the input text is empty or the cipher suite is not available, it returns the original text. The function handles exceptions by returning the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text if successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The `insert_user` function creates a new user document in the database with the provided username, name, and password. The password is hashed for secure storage. The function then inserts this user document into the database and returns the ID of the newly inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password for the user, which will be hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all users from a database collection named 'dbusers' and returns them as a list. It appears to be part of a larger database interaction system, likely using MongoDB given the 'dbusers.find()' method. The function does not take any parameters and does not include any error handling or data processing beyond the query itself.",
        "parameters": [],
        "returns": [
          {
            "name": "list_of_users",
            "type": "list",
            "description": "A list of user documents retrieved from the 'dbusers' collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "This function retrieves a user's data from the database based on their username. It uses the pymongo library to interact with the MongoDB database. The function takes a username as input and returns the corresponding user document from the database. If no user is found, it returns None. The function does not perform any error checking or handling beyond what is provided by the MongoDB query.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to fetch from the database."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict",
            "description": "The user document from the database, or None if no user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name of a user in the database. It takes a username and a new name as input, and modifies the 'name' field of the user document in the database. The function returns the number of documents modified.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The current username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates a user's Gemini API key in the database. It takes a username and a Gemini API key as input, encrypts the key, and then updates the corresponding user's document in the database with the encrypted key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is being updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be encrypted and stored in the database."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "This function updates a user's GPT API key in the database. It takes a username and a GPT API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose GPT API key is being updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the 'ollama_base_url' field for a specified user in the database. It takes a username and a URL as input, strips any leading/trailing whitespace from the URL, and then updates the corresponding document in the database. The function returns the number of documents modified by the operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose 'ollama_base_url' is to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new 'ollama_base_url' to be set for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the Open Source API key for a given user in the database. It takes a username and an Open Source API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The new Open Source API key to be encrypted and stored in the database."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open source base URL for a given user in the database. It takes a username and an open source base URL as input, strips any leading or trailing whitespace from the URL, and then updates the corresponding field in the user's document. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose open source base URL is to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open source base URL to be set for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "This function retrieves a Gemini API key for a given username from a MongoDB database. It queries the 'dbusers' collection with the provided username and projects only the 'gemini_api_key' field. If a matching user is found, it returns the Gemini API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The Gemini API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "This function retrieves the 'ollama_base_url' for a given username from the database. It uses a MongoDB query to find the user document with the matching username and projects only the 'ollama_base_url' field. If the user is found, it returns the 'ollama_base_url'; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The 'ollama_base_url' associated with the given username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "This function retrieves a GPT API key for a given username from a MongoDB database. It queries the 'dbusers' collection with the provided username and projects only the 'gpt_api_key' field. If a matching user is found, it returns the GPT API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The GPT API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the Open Source API key for a given username from the database. It queries the 'dbusers' collection with the provided username and projects only the 'opensrc_api_key' field. If a matching user is found, it returns the Open Source API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The Open Source API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function retrieves the open source URL for a given username from the database. It queries the 'dbusers' collection for a document matching the provided username and returns the 'opensrc_base_url' field if found. If no matching document exists, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The open source URL associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "This function deletes a user from the database by their username. It utilizes the pymongo library to interact with the MongoDB database. The function takes a username as input, uses it to identify the user document in the database, and then deletes that document. The function returns the number of documents deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted (1 if the user existed, 0 if not)."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys for a given username from a database. It searches for a user by their username, then decrypts and returns their Gemini, Ollama, GPT, and OpenSRC API keys, along with the OpenSRC base URL. If the user is not found, it returns None for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to retrieve API keys."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSRC base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "This function creates a new chat entry in the database. It generates a unique ID for the chat, records the username, chat name, and the current timestamp. The function then inserts this new chat entry into the database and returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user creating the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted chat document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "This function retrieves all chats defined for a given user from the database. It uses the pymongo library to query the database and sorts the results by creation date in ascending order. The function takes a username as input and returns a list of chats associated with that user.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chats associated with the given username."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks if a chat with a given name exists for a specific username in the database. It uses a MongoDB collection to perform the check. The function takes two parameters, a username and a chat name, and returns a boolean value indicating whether the chat exists.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to check for chat existence."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if the chat exists, False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and all associated exchanges in the database. It takes the username, old chat name, and new chat name as input, updates the chat entry, and then updates all messages (exchanges) to reflect the new chat name. The function returns the number of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the chat owner."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name for the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "This function inserts a new exchange into the database. It creates a new document with the provided details and attempts to insert it into the database. If successful, it returns the ID of the newly inserted document; otherwise, it returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "The feedback given."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used (optional, default: '')."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main used (optional, default: '')."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "The total time (optional, default: '')."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "The helper time (optional, default: '')."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "The main time (optional, default: '')."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The JSON tokens (optional, default: 0)."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The toon tokens (optional, default: 0)."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The savings percent (optional, default: 0.0)."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The ID of the newly inserted document if successful."
          },
          {
            "name": "None",
            "type": "None",
            "description": "If an error occurs during insertion."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves a list of exchanges associated with a given username from a database, sorted by a timestamp field 'created_at' in ascending order. The function appears to be part of a larger system that interacts with a MongoDB database using the PyMongo library. It takes a username as input and returns a list of exchanges. The purpose of this function is to fetch and return user-specific exchange data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch exchanges."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the given username."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a list of exchanges for a specific chat given a username and chat name. It queries a database collection named 'exchanges' with a filter on 'username' and 'chat_name', sorts the results by 'created_at' in ascending order, and returns the exchanges as a list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchanges by."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The chat name to filter exchanges by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges matching the filter criteria."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "This function updates the feedback for a specific exchange in the database. It takes an exchange ID and a new feedback value as input, and returns the number of documents modified by the update operation. The function uses the PyMongo library to interact with the MongoDB database. The update operation is performed using the $set operator, which sets the value of the feedback field to the provided value. The function returns the modified_count attribute of the result object, which indicates the number of documents that were modified.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "objectId",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The new feedback value to be set."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message for a specific exchange in the database. It takes an exchange ID and a feedback message as input, and returns the number of documents modified by the update operation. The function uses the PyMongo library to interact with the MongoDB database.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "objectId",
            "description": "The ID of the exchange to update"
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to set"
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes an exchange by its ID from the database and returns the number of documents deleted. It takes an exchange ID as input, uses it to query the database, and then removes the corresponding document. The function returns the count of deleted documents.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the exchange to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "This function deletes a full chat and all associated exchanges for a given username and chat name. It ensures consistency between the frontend and backend by removing all related data. The function first deletes all messages in the chat, then removes the chat itself from the chat list. It returns the number of chats deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the chat owner."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of chats deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "This function takes a list of model names, splits each name by the '/' character, and returns a list of the last part of each name. It appears to be used for cleaning or standardizing model names by extracting the final part of a potentially full path. The function uses a list comprehension to achieve this in a concise manner. It does not include any error handling or type checking for the inputs.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list",
            "description": "A list of model names that may contain full paths."
          }
        ],
        "returns": [
          {
            "name": "cleaned_names",
            "type": "list",
            "description": "A list of cleaned model names."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "This function filters a list of models based on a selected category. It uses predefined keywords for each category to determine which models to include in the filtered list. If the category includes the keyword 'STANDARD', it only returns models that are also in the standard models list. Otherwise, it checks if any of the category's keywords are present in the model's name.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered_list",
            "type": "list",
            "description": "The filtered list of models."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function saves a Gemini key to the database. It retrieves the key from the session state, updates the database with the new key for the current user, and then clears the session state. If successful, it displays a toast notification.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function saves a new Ollama URL to the database. It retrieves the URL from the session state, updates the database with the new URL for the current user, and displays a toast notification upon success.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "This function loads chat and exchange data consistently from the database for a given user. It checks if the user has already been loaded, and if not, it initializes the user's chat data. It loads defined chats, then exchanges, and sorts them accordingly. If no chats exist, it creates a default chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to load data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value associated with an exchange in the database and reruns the Streamlit application.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing an exchange, expected to contain an '_id' key and a 'feedback' key."
          },
          {
            "name": "val",
            "type": "any",
            "description": "The new feedback value to be associated with the exchange."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "This function handles the deletion of an exchange from a chat session. It removes the exchange from the database and updates the chat session state accordingly. The function then triggers a rerun of the Streamlit application.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "The exchange to be deleted, containing an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "This function handles the deletion of a chat. It calls the database function to delete the chat, cleans up the session state by removing the chat and updating the active chat if necessary. If all chats are deleted, it creates a new empty chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who owns the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_full_chat and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "This function takes a string input and attempts to extract a repository name from it. It searches for a URL in the text, parses the URL, and then extracts the last part of the path as the repository name. If the repository name ends with '.git', it is stripped. The function returns the extracted repository name or None if no URL is found.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input string to search for a repository name."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name or None if no URL is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The `stream_text_generator` function takes a string input `text` and splits it into words, yielding each word followed by a space with a 10ms delay between each yield.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input string to be streamed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "This function renders markdown text with mermaid code blocks using Streamlit. It splits the markdown text into parts, rendering non-mermaid parts as markdown and mermaid parts as mermaid diagrams. If streaming is enabled, it streams the text; otherwise, it uses standard markdown rendering.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The markdown text to be rendered, which may contain mermaid code blocks."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the text or use standard markdown rendering. Defaults to False."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function is responsible for rendering a single exchange (question and answer) in a chat interface using Streamlit. It displays the user's question, the assistant's answer, and provides various interactive elements such as feedback buttons, a comment popover, a download button, and a delete button. The function handles different scenarios, including error cases, and updates the exchange's feedback message and status accordingly.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the question, answer, feedback, and other relevant information."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls the following functions: database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python source code and extract relevant information about its structure. It initializes with source code, file path, and project root, and provides methods to visit different types of nodes in the AST, such as imports, class definitions, and function definitions. The class populates a schema that includes information about imports, functions, and classes found in the source code.",
        "init_method": {
          "description": "The constructor of the ASTVisitor class initializes the object with the source code, file path, and project root. It sets up the module path and an empty schema to store information about imports, functions, and classes. The constructor also calls the path_to_module function to determine the module path from the file path and project root.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code to be analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file containing the source code."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method is called when an Import node is encountered in the AST. It extracts the names of the imported modules and adds them to the schema's imports list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method is called when an ImportFrom node is encountered in the AST. It extracts the module name and the names of the imported modules, and adds them to the schema's imports list in the format 'module_name.imported_name'.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method is called when a ClassDef node is encountered in the AST. It extracts information about the class, including its name, docstring, and source code segment, and adds it to the schema's classes list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method is called when a FunctionDef node is encountered in the AST. If the function is a method of a class, it extracts information about the method and adds it to the class's method context. Otherwise, it adds information about the function to the schema's functions list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method is called when an AsyncFunctionDef node is encountered in the AST. It simply calls the visit_FunctionDef method to handle it in the same way as a FunctionDef node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the path_to_module function from the backend.AST_Schema module.",
          "instantiated_by": "The class is not instantiated by any other part of the code provided in the input."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is designed to analyze Abstract Syntax Tree (AST) schema data. It provides methods to merge relationship data into a full schema and to analyze a repository by parsing its Python files and extracting relevant information.",
        "init_method": {
          "description": "The constructor of the ASTAnalyzer class does not initialize any instance attributes. It is a simple constructor that does nothing.",
          "parameters": [
            {
              "name": "self",
              "type": "instance of ASTAnalyzer",
              "description": "Reference to the instance of the class."
            }
          ]
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method merges relationship data into a full schema. It takes raw relationship data and integrates it into the provided full schema by updating function and class contexts with call and dependency information.",
              "parameters": [
                {
                  "name": "self",
                  "type": "instance of ASTAnalyzer",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema to be updated with relationship data."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "Raw relationship data to be merged into the full schema."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated full schema with integrated relationship data."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method analyzes a repository by parsing its Python files and extracting AST nodes. It returns a schema containing the extracted information.",
              "parameters": [
                {
                  "name": "self",
                  "type": "instance of ASTAnalyzer",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects to be analyzed."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "A Git repository object providing context for the analysis."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A schema containing the extracted AST nodes and other relevant information."
                }
              ],
              "usage_context": {
                "calls": "The method calls the ASTVisitor class to visit and parse the AST of each Python file.",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the ASTVisitor class for analyzing the AST of Python files.",
          "instantiated_by": "The class is not instantiated by any other part of the system according to the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve file dependencies in a repository. It utilizes the abstract syntax tree (AST) to parse import statements and determine the actual module or symbol names being imported. The class provides methods to resolve relative imports, visit import statements, and track dependencies between files.",
        "init_method": {
          "description": "The constructor initializes the FileDependencyGraph with a filename and a repository root. It sets up the filename and repository root as instance attributes.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed."
            },
            {
              "name": "repo_root",
              "type": "object",
              "description": "The root directory of the repository."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "This method resolves relative imports of the form `from .. import name1, name2`. It returns a list of actual existing module or symbol names. If no resolution is possible, it raises an ImportError.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The ImportFrom node to resolve."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls get_all_temp_files, init_exports_symbol, and module_file_exists to resolve the module names.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method visits Import nodes in the AST. It adds the imported module or symbol name to the import dependencies of the current file.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "The Import or ImportFrom node to visit."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "The base name of the module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method visits ImportFrom nodes in the AST. If the import is of the form `from a.b.c import d`, it takes the last part of the module (c) and sets it as the callee for the caller file. It attempts to resolve relative imports and handles ImportErrors.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The ImportFrom node to visit."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "module_file_exists",
            "description": {
              "overall": "This method checks if a module file exists at a given relative base path and name.",
              "parameters": [
                {
                  "name": "rel_base",
                  "type": "Path",
                  "description": "The relative base path."
                },
                {
                  "name": "name",
                  "type": "str",
                  "description": "The name of the module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "init_exports_symbol",
            "description": {
              "overall": "This method checks if a symbol is exported in the __init__.py file of a given relative base path. It verifies if the symbol is in the __all__ list or defined as a name (function, class, or assignment).",
              "parameters": [
                {
                  "name": "rel_base",
                  "type": "Path",
                  "description": "The relative base path."
                },
                {
                  "name": "symbol",
                  "type": "str",
                  "description": "The symbol to check."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on get_all_temp_files, init_exports_symbol, and module_file_exists to resolve module names and track dependencies.",
          "instantiated_by": "The class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class is designed to interact with Google Gemini for generating code snippet documentation. It centralizes API interaction, error handling, and validates I/O using Pydantic. The class initializes with an API key, function and class prompt paths, and model settings, then configures batch settings based on the model. It provides methods to generate documentation for functions and classes in batches.",
        "init_method": {
          "description": "The constructor initializes the LLMHelper with an API key, paths to function and class system prompts, and model settings. It validates the API key, reads and sets the system prompts, configures batch settings based on the model, and sets up the language model (LLM) with structured output for functions and classes.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The Gemini API key required for interacting with the model."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "The file path to the function system prompt."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "The file path to the class system prompt."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use, defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the model API, optional."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures batch settings based on the model name. It sets the batch size for processing requests in batches.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "The name of the model which determines the batch size."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Generates and validates documentation for a batch of functions. It takes a list of function inputs, processes them in batches based on the configured batch size, and returns a list of validated function analyses.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function inputs to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_functions",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analyses."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Generates and validates documentation for a batch of classes. It takes a list of class inputs, processes them in batches based on the configured batch size, and returns a list of validated class analyses.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class inputs to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_classes",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analyses."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the primary interface for interacting with a Large Language Model (LLM). It initializes the LLM based on a provided model name and API key, and offers methods for calling the LLM with a user's input, either in a blocking or streaming manner.",
        "init_method": {
          "description": "The constructor of the MainLLM class initializes the LLM with a given API key, prompt file path, model name, and base URL. It validates the API key, reads the system prompt from the specified file, and sets up the LLM instance based on the model name, which can be a Gemini, GPT, or custom model.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for accessing the LLM."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use, defaults to 'gemini-2.5-pro'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for custom models, defaults to None."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "The call_llm method takes a user's input, constructs a message with the system prompt and the user's input, and then calls the LLM to get a response. It logs the success or failure of the call and returns the response content if successful.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input provided by the user."
                }
              ],
              "returns": [
                {
                  "name": "response",
                  "type": "str",
                  "description": "The content of the response from the LLM, or None if an error occurs."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "The stream_llm method is similar to call_llm but instead of returning the full response at once, it streams the response from the LLM. It yields chunks of the response content as they become available.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input provided by the user."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on external APIs for interacting with the LLMs, including Gemini, GPT, and custom models.",
          "instantiated_by": "The class is instantiated by components that require interaction with an LLM, passing in the necessary API key, prompt file path, model name, and base URL."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README, pyproject.toml, and requirements.txt. It initializes a structured information object that includes project overview and installation details.",
        "init_method": {
          "description": "The constructor initializes the class with a structured information object containing placeholders for project information. It sets up default values for project overview and installation details.",
          "parameters": [
            {
              "name": "self",
              "type": "reference",
              "description": "Reference to the instance of the class"
            }
          ]
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from a given content string, which can occur due to encoding errors when reading files.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The content string to be cleaned"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches case-insensitively for a file that matches one of the given patterns in a list of files.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file patterns to search for"
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to search in"
                }
              ],
              "returns": [
                {
                  "name": "file",
                  "type": "Optional[Any]",
                  "description": "The found file object or None if not found"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text under a Markdown heading (##) based on given keywords.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The Markdown content to search in"
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords to search for"
                }
              ],
              "returns": [
                {
                  "name": "section_text",
                  "type": "Optional[str]",
                  "description": "The extracted section text or None if not found"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file and extracts relevant project information.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file and extracts project information.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file and extracts dependencies.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the extraction of project information from given files and a repository URL.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to extract information from"
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository"
                }
              ],
              "returns": [
                {
                  "name": "project_info",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class does not have explicit external dependencies listed.",
          "instantiated_by": "The class is not explicitly instantiated by any known components."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze the call structure of a given Python file. It utilizes the abstract syntax tree (AST) to traverse and understand the definitions and calls within the file, constructing a directed graph that represents the call relationships between functions and methods.",
        "init_method": {
          "description": "The constructor of the CallGraph class initializes the object with a given filename. It sets up several instance variables to keep track of the current function and class being processed, as well as data structures to store local definitions, the call graph, import mappings, and function sets.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "This method recursively resolves the components of a call node in the AST, returning a list of name components as a dotted string. It handles different types of nodes such as Call, Name, and Attribute.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Node",
                  "description": "The node in the AST to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "This method takes a list of callee nodes and resolves their names based on local definitions and import mappings. It returns a list of resolved callee names.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists representing the name steps of callee nodes."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved callee names."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "This method constructs a full name for a given basename and optional class name, prefixing them with the filename.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name to be used."
                },
                {
                  "name": "class_name",
                  "type": "str | None",
                  "description": "The optional class name."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The constructed full name."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "This method returns the current caller, which is either the current function or a representation of the global scope if no function is being processed.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The current caller."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method processes Import nodes in the AST, updating the import mapping with the names and aliases of imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method processes ImportFrom nodes in the AST, updating the import mapping with the names and aliases of imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method processes ClassDef nodes in the AST, temporarily updating the current class and then reverting it after processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method processes FunctionDef nodes in the AST, updating local definitions and the call graph with the function name and its full name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method processes AsyncFunctionDef nodes in the AST by delegating to visit_FunctionDef.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method processes Call nodes in the AST, resolving the callee names and updating the call edges in the graph.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The Call node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "This method processes If nodes in the AST, handling a special case when the condition checks the __name__ variable.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The If node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the 'ast' and 'networkx' modules for its operation.",
          "instantiated_by": "The class is instantiated with a filename to analyze the call graph of that file."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file in a Git repository. It provides lazy loading of the file content and offers various methods for analyzing and representing the file.",
        "init_method": {
          "description": "The constructor initializes the RepoFile object with a file path and a commit tree. It sets up the object's state by storing the file path and the commit tree, and initializes internal variables for lazy loading of the file's blob, content, and size.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The Tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "Lazy-loads the Git blob object associated with the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "Lazy-loads and returns the decoded content of the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "Lazy-loads and returns the size of the file in bytes.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "Analyzes the word count in the file content.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The number of words in the file content."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Converts the RepoFile object to a dictionary representation.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include the file content in the dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "The dictionary representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Returns a useful string representation of the RepoFile object.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr",
                  "type": "str",
                  "description": "A string representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository, including cloning it into a temporary directory and providing RepoFile objects. It allows for listing all files in the repository and provides a file tree structure.",
        "init_method": {
          "description": "The constructor initializes a GitRepository object by cloning a Git repository into a temporary directory. It sets up the repository object, latest commit, and commit tree. If cloning fails, it raises a RuntimeError.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "This method returns a list of all files in the repository as RepoFile objects. It uses the Git ls-files command to get file paths and creates RepoFile instances for each path.",
              "parameters": [],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile objects representing all files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile class to create objects for each file in the repository.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "This method deletes the temporary directory and its contents.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": "This method is called by the __exit__ method to ensure the temporary directory is cleaned up."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "This method returns the GitRepository object itself, allowing it to be used as a context manager.",
              "parameters": [],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The GitRepository object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": "This method is used implicitly when the GitRepository object is used as a context manager."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "This method calls the close method to delete the temporary directory and its contents when exiting the context manager.",
              "parameters": [
                {
                  "name": "exc_type",
                  "type": "Exception",
                  "description": "The exception type."
                },
                {
                  "name": "exc_val",
                  "type": "Exception",
                  "description": "The exception value."
                },
                {
                  "name": "exc_tb",
                  "type": "traceback",
                  "description": "The traceback object."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the close method to clean up resources.",
                "called_by": "This method is called automatically when exiting the context manager."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "This method returns a tree structure representing the files in the repository. If include_content is True, it includes the file contents in the tree.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include file contents in the tree."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the file tree structure."
                }
              ],
              "usage_context": {
                "calls": "This method calls the get_all_files method to populate the file tree if necessary.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the RepoFile class from the backend.getRepo module.",
          "instantiated_by": "The class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze a project by traversing its directory structure, identifying Python files, and resolving function and method calls within those files. It constructs a call graph that represents the relationships between different parts of the project.",
        "init_method": {
          "description": "The constructor initializes the ProjectAnalyzer with a project root directory. It sets up instance attributes such as the project root path, definitions, call graph, file ASTs, and directories to ignore.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "This method orchestrates the analysis of the project by finding Python files, collecting definitions, resolving calls, and returning the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "dict",
                  "description": "A dictionary representing the call graph of the project."
                }
              ],
              "usage_context": {
                "calls": "This method calls _find_py_files, _collect_definitions, and _resolve_calls to perform the analysis.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "This method processes the call graph to extract raw relationships between callers and callees, organizing them into outgoing and incoming relationship sets.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing outgoing and incoming relationship sets."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "This method traverses the project directory structure to find all Python files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list",
                  "description": "A list of paths to Python files in the project."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by analyze."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "This method reads Python files, parses their ASTs, and collects definitions of functions, methods, and classes.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls path_to_module.",
                "called_by": "This method is called by analyze."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "This method finds the parent node of a given node in the AST.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.Tree",
                  "description": "The AST being traversed."
                },
                {
                  "name": "node",
                  "type": "ast.Node",
                  "description": "The node whose parent is to be found."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.Node",
                  "description": "The parent node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by _collect_definitions."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "This method resolves function and method calls within a given Python file by visiting its AST.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls CallResolverVisitor.",
                "called_by": "This method is called by analyze."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ProjectAnalyzer depends on CallResolverVisitor and path_to_module for its operations.",
          "instantiated_by": "The class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python code and resolve function calls, tracking the call relationships between different parts of the codebase. It is particularly focused on identifying and recording calls to defined functions or methods within the code.",
        "init_method": {
          "description": "The constructor initializes the visitor with a filepath, project root, and definitions. It sets up the necessary instance variables to track the current module path, scope, instance types, and calls.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The file path of the code being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary of definitions in the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method is called when a class definition node is encountered in the AST. It temporarily updates the current class name and then performs a generic visit of the class node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node for the class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method is called when a function definition node is encountered in the AST. It updates the current caller name based on whether the function is defined inside a class or not, and then performs a generic visit of the function node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node for the function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method is called when a call node is encountered in the AST. It attempts to resolve the callee's pathname and, if resolvable and defined, records the call relationship.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node for the call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method is called when an import node is encountered in the AST. It updates the scope with the imported names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node for the import."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method is called when an import from node is encountered in the AST. It updates the scope with the imported names, considering the module and level.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node for the import from."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "This method is called when an assign node is encountered in the AST. It checks if the assignment is to a class instance and updates the instance types accordingly.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node for the assign."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "This method resolves the full pathname of a call's callee if possible.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.Name or ast.Attribute",
                  "description": "The AST node for the function being called."
                }
              ],
              "returns": [
                {
                  "name": "callee_pathname",
                  "type": "str or None",
                  "description": "The resolved pathname of the callee, or None if unresolved."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the backend.relationship_analyzer.path_to_module function.",
          "instantiated_by": "The class is not directly instantiated by any known part of the codebase."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic model designed to describe a single parameter of a function. It encapsulates the parameter's name, type, and description, providing a structured way to represent function parameter metadata.",
        "init_method": {
          "description": "The class is initialized with parameters for name, type, and description. These parameters are used to create an instance of ParameterDescription.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the parameter."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model designed to describe the return value of a function. It encapsulates three key attributes: name, type, and description of the return value.",
        "init_method": {
          "description": "The class is initialized with parameters for name, type, and description, which are used to create an instance of ReturnDescription.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model that describes the calling context of a function. It captures information about the functions or methods that a particular function calls and is called by. This class provides a structured way to represent the usage context of functions within a system, aiding in the analysis and documentation of code dependencies and interactions.",
        "init_method": {
          "description": "The class is initialized with two parameters: calls and called_by, both of which are strings. This setup allows for the description of the immediate calling context of a function.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string describing the functions or methods that the current function calls."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string describing the functions or methods that call the current function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to hold a detailed analysis of a function's purpose and signature. It encapsulates information about the function's overall description, parameters, return values, and usage context.",
        "init_method": {
          "description": "The class is initialized with parameters for overall description, parameters, returns, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the function's purpose."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing the function's parameters."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects detailing the function's return values."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "An object providing context about where and how the function is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class is a Pydantic model designed to represent the JSON schema for a function. It encapsulates key information about a function, including its identifier, description, and any potential errors. This model serves as a structured data representation for functions, facilitating consistent and reliable analysis or documentation generation.",
        "init_method": {
          "description": "The class is initialized with an identifier, description, and an optional error field. The identifier is a string representing the function's name, and the description is an object of type FunctionDescription providing detailed information about the function.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string representing the name or identifier of the function."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object containing a detailed description of the function."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional field to store any error messages related to the function's analysis. Defaults to None if no error is present."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model designed to describe the __init__ method of a class. It captures the description of the constructor and details about its parameters.",
        "init_method": {
          "description": "The class is initialized with a description of the constructor and a list of parameter descriptions.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A string describing the constructor."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing the parameters of the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model that describes the external dependencies and primary points of instantiation for a given class. It has two main attributes: dependencies and instantiated_by, both of which are strings. This class seems to provide a simple data structure for tracking class-level metadata.",
        "init_method": {
          "description": "The class is initialized with two string attributes: dependencies and instantiated_by. These attributes are set directly from the constructor parameters.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string representing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string indicating where the class is instantiated."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to hold a comprehensive analysis of a class, including its purpose, constructor details, and a list of its methods.",
        "init_method": {
          "description": "The constructor initializes a ClassDescription object with four main attributes: overall, init_method, methods, and usage_context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose of the class."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object containing details about the class constructor."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects, each describing a method of the class."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing context about how the class is used within the system."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as a structured model to represent the analysis of a Python class. It encapsulates the class identifier, a detailed description of the class, and an optional error message.",
        "init_method": {
          "description": "The constructor of ClassAnalysis initializes the object with an identifier, description, and an optional error message. It sets up the object's state with the provided parameters.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The name or identifier of the class being analyzed."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "A detailed description of the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional error message if the analysis encounters an issue."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer. It is used in 'called_by' and 'instantiated_by' lists to provide detailed information about call events.",
        "init_method": {
          "description": "The class is initialized with parameters for file, function, mode, and line. These parameters are used to set up the instance attributes.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file associated with the call event."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the caller function."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, e.g., 'method', 'function', 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number of the call event."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to hold structured context for analyzing a function. It captures information about the functions called by the analyzed function and the functions or methods that call it.",
        "init_method": {
          "description": "The class is initialized with two parameters: calls and called_by. The calls parameter is a list of strings representing the functions called by the analyzed function. The called_by parameter is a list of CallInfo objects representing the functions or methods that call the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions or methods that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class is a Pydantic model designed to serve as input for generating a FunctionAnalysis object. It encapsulates necessary details for analysis, including mode, identifier, source code, imports, and context.",
        "init_method": {
          "description": "The class is initialized with parameters defining the analysis input. It sets up the instance with a mode, identifier, source code, imports, and context.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "Specifies the mode of analysis, which must be 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the function's analysis."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "Contextual information about the function, such as dependencies and usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to hold structured context information for methods in a class. It encapsulates details such as the method identifier, calls made by the method, the methods or functions that call it, argument names, and an optional docstring.",
        "init_method": {
          "description": "The class is initialized with parameters for identifier, calls, called_by, args, and docstring. These parameters are used to set up the instance attributes.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The name of the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of methods or functions called by this method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of methods or functions that call this method."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of argument names for the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "An optional docstring for the method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to hold structured context for analyzing a class. It captures dependencies, instantiation information, and method context.",
        "init_method": {
          "description": "The constructor initializes a ClassContextInput object with dependencies, instantiated_by, and method_context.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of dependencies for the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of information about where the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of method context inputs for the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on external types such as CallInfo and MethodContextInput.",
          "instantiated_by": "This class is not instantiated by any known components."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class is a Pydantic model designed to serve as input for generating a ClassAnalysis object. It encapsulates essential information about a class, including its source code, identifier, and contextual dependencies. This model ensures that the input provided for class analysis is structured and valid.",
        "init_method": {
          "description": "The constructor of ClassAnalysisInput initializes the object with required parameters: mode, identifier, source_code, imports, and context. It sets up the instance attributes necessary for class analysis.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "Specifies the mode of analysis, which must be 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The name or identifier of the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class definition."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "Contextual information about the class, including dependencies and instantiation details."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    }
  }
}