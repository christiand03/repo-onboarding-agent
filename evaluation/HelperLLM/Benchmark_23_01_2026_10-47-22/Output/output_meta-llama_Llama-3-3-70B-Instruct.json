{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function attempts to calculate the relative path of the file with respect to the project root. If this fails, it falls back to using the file's basename. The function then removes any '.py' extension from the path and replaces path separators with dots to form a Python module path. Finally, it checks if the resulting module path ends with '__init__' and removes this if present, before returning the module path.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The path to the file to be converted into a Python module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The Python module path corresponding to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "The `build_file_dependency_graph` function constructs a directed graph representing file dependencies within a given repository. It utilizes the `networkx` library to create the graph and the `ast` module to parse the abstract syntax tree of the provided file. The function takes a filename, an abstract syntax tree, and the repository root as input, and returns a directed graph where nodes represent files and edges represent import dependencies. The graph is populated by visiting the abstract syntax tree and extracting import dependencies. The function ultimately returns the constructed graph, providing a visual representation of the file dependencies within the repository.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which to build the dependency graph."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree of the provided file."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies within the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.FileDependencyGraph.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "The `build_repository_graph` function constructs a directed graph representing the dependencies between Python files in a given Git repository. It iterates over all Python files in the repository, parsing each file's abstract syntax tree (AST) to identify dependencies. The function then builds a global graph by combining the individual file dependency graphs. The resulting graph is returned as a NetworkX DiGraph object.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository to analyze for file dependencies."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the dependencies between Python files in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.build_file_dependency_graph.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "The `get_all_temp_files` function retrieves a list of all Python files within a specified directory and its subdirectories. It takes a directory path as input, resolves it to an absolute path, and then uses a recursive glob pattern to find all files with the `.py` extension. The function returns a list of `Path` objects representing the relative paths of these files to the specified directory. This function appears to be designed for traversing and analyzing Python files within a directory structure, potentially for dependency analysis or code inspection purposes.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory in which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of `Path` objects representing the relative paths of all Python files found in the specified directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function is a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analysis for each method, including add_item, check_stock, and generate_report. The function then uses the LLMHelper class to generate documentation for these methods.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, and schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The `make_safe_dot` function generates a safe dot representation of a given directed graph. It takes a `networkx` DiGraph object and an output file path as input, creates a copy of the graph, relabels its nodes to ensure they are safe for dot representation, and then writes the modified graph to the specified output path. The function utilizes the `networkx` library for graph manipulation and the `nx_pydot` module for writing the dot file. The relabeling process involves assigning a unique, safe identifier to each node, while preserving the original node labels as attributes. This process enables the safe representation of the graph in a dot file.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input directed graph to be converted to a safe dot representation."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the safe dot representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The `build_filtered_callgraph` function constructs a global call graph and filters it to include only self-written functions. It takes a `GitRepository` object as input and returns a directed graph representing the call relationships between the functions. The function iterates over all Python files in the repository, parses their abstract syntax trees, and uses a `CallGraph` visitor to extract function calls. It then constructs the global call graph by adding edges between functions that call each other. The function filters out functions that are not self-written by checking if the caller and callee are in the set of own functions.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "A `GitRepository` object representing the repository to analyze."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the call relationships between self-written functions in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.callgraph.CallGraph`. ",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The `wrap_cdata` function is designed to encapsulate a given content within CDATA tags. This is typically used in XML to prevent the content from being parsed as XML markup. The function takes a single parameter, `content`, which is the string to be wrapped. It returns a new string with the content enclosed in CDATA tags. The implementation is straightforward, using Python's f-string formatting to insert the content between the opening and closing CDATA tags. The function does not handle any exceptions or edge cases explicitly. Given the simplicity of the function, its purpose is clear and focused on providing a basic utility for XML content wrapping.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The `extract_output_content` function is designed to extract text and handle images from a list of outputs. It iterates through each output, checks its type, and processes the data accordingly. For display data and execute results, it extracts text or images encoded in Base64 and appends them to a list. For stream outputs, it directly appends the text. In case of errors, it appends the error name and value. The function returns a list of extracted text strings or placeholders for images.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of output objects to extract content from."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list to store image data, where each image is represented as a dictionary with 'mime_type' and 'data' keys."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of extracted text strings or placeholders for images."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The `process_image` function processes an image based on its MIME type. It checks if the provided MIME type exists in the `data` dictionary and attempts to decode the corresponding base64-encoded string. If successful, it appends the image data to the `image_list` and returns a placeholder string. If an error occurs during decoding, it returns an error message. If the MIME type is not found in the `data` dictionary, the function returns `None`.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "success",
            "type": "str",
            "description": "A placeholder string indicating the image has been successfully processed."
          },
          {
            "name": "error",
            "type": "str",
            "description": "An error message if the image decoding fails."
          },
          {
            "name": "none",
            "type": "NoneType",
            "description": "If the MIME type is not found in the `data` dictionary."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The function `convert_notebook_to_xml` takes a notebook file content as input, attempts to parse it as a JSON notebook, and then converts its cells into XML format. If the parsing fails, it returns an error message. The function handles two types of cells: markdown and code. For markdown cells, it directly converts the source into XML. For code cells, it wraps the source code in a CDATA section and converts it into XML. If a code cell has outputs, it extracts the output content, wraps it in a CDATA section, and appends it as an output cell in the XML. The function returns the XML representation of the notebook and a list of extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the notebook file to be converted."
          }
        ],
        "returns": [
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML representation of the notebook."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted images from the notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.extract_output_content and backend.converter.wrap_cdata.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "The `process_repo_notebooks` function processes a list of repository files, identifies notebooks with the '.ipynb' extension, and converts them into XML format along with extracting images. It logs the number of notebooks found and the processing of each notebook. The function returns a dictionary where each key is the path of a notebook file and the value is another dictionary containing the XML output and images for that notebook.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of repository files to be processed."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary containing the XML output and images for each processed notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The `create_savings_chart` function generates a bar chart comparing JSON and TOON tokens and saves it to a specified output path. It takes four parameters: `json_tokens`, `toon_tokens`, `savings_percent`, and `output_path`. The function uses matplotlib to create the chart, customizing its appearance with labels, colors, and a title that includes the savings percentage. The chart displays the number of tokens for each format, with values shown above the bars. Finally, the function saves the chart to the specified output path and closes the plot.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage of savings."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The calculate_net_time function calculates the net time taken by a process, excluding sleep times for rate limits. It takes into account the start and end times of the process, the total number of items, the batch size, and the model name. If the model name does not start with 'gemini-', it returns the total duration. Otherwise, it calculates the number of batches, the total sleep time, and subtracts this from the total duration to get the net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float",
            "description": "The start time of the process."
          },
          {
            "name": "end_time",
            "type": "float",
            "description": "The end time of the process."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items being processed."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The size of each batch."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float",
            "description": "The net time taken by the process, excluding sleep times for rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is responsible for orchestrating the analysis of a given input. It begins by updating the status and then proceeds to extract the repository URL from the input. The function then clones the repository, extracts the files, and constructs a file tree. It also performs relationship analysis and creates an abstract syntax tree (AST) schema. The function prepares inputs for the Helper LLM and initializes it. It then calls the Helper LLM for function and class analysis, and finally, it calls the Main LLM to generate a final report.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input to be analyzed."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary containing model names for the Helper LLM and Main LLM."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to update the status."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated by the Main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics such as helper time, main time, and total time."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, and schemas.types.MethodContextInput.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The update_status function is designed to update the status by calling the status_callback function with the provided message if it exists. Additionally, it logs the message at the info level using the logging module. The function takes one parameter, msg, which is expected to be a string or a message that can be logged. The purpose of this function appears to be part of a larger system for managing and reporting status updates, possibly in a backend application or service.",
        "parameters": [
          {
            "name": "msg",
            "type": "string",
            "description": "The message to be used for updating the status and logging."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The notebook_workflow function is a complex process that analyzes input data, clones a repository, extracts basic project information, and generates reports using a large language model (LLM). It takes in several parameters, including input data, API keys, a model name, and an optional status callback function. The function returns a dictionary containing a report and metrics. The function's purpose is to automate the analysis of notebooks in a repository and provide a comprehensive report.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input data to be analyzed."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various models."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the model to be used for analysis."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to update the status of the analysis process."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The generated report."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics about the analysis process."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, and backend.main.update_status.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The gemini_payload function generates a payload content list by processing the provided basic information, notebook path, XML content, and images. It first creates an intro JSON object containing the basic information and notebook path, then iterates over the XML content to extract text segments and image placeholders. For each image placeholder, it appends a text segment and an image URL to the payload content list. Finally, it returns the payload content list.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "dict",
            "description": "A dictionary containing basic information about the notebook."
          },
          {
            "name": "nb_path",
            "type": "str",
            "description": "The path to the notebook."
          },
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML content of the notebook."
          },
          {
            "name": "images",
            "type": "list",
            "description": "A list of image data, where each image is a dictionary containing the image data and other metadata."
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "list",
            "description": "A list of dictionaries, where each dictionary represents a segment of the payload content, either text or an image URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function attempts to calculate the relative path from the project root to the file. If this fails, it falls back to using the file's basename. The function then removes any '.py' extension and replaces path separators with dots to form the module path. If the resulting module path ends with '.__init__', this suffix is removed before the path is returned.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The path to the file to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The file path converted into a Python module path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The `encrypt_text` function is designed to encrypt a given text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available. If either condition is true, it returns the original text. Otherwise, it encrypts the text using the cipher suite, strips any leading or trailing whitespace, encodes the text to bytes, and then decodes the encrypted bytes back to a string. The function returns the encrypted text as a string.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text as a string."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The `decrypt_text` function is designed to decrypt a given text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available. If either condition is true, it returns the original text. Otherwise, it attempts to decrypt the text using the cipher suite and returns the decrypted text. If an exception occurs during decryption, it catches the exception and returns the original text. The function takes a string as input and returns a string as output.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The `insert_user` function is designed to create a new user entry in a database. It takes in three parameters: `username`, `name`, and `password`. The function constructs a user dictionary with the provided information, hashes the password using `stauth.Hasher.hash`, and then inserts this user data into the database using `dbusers.insert_one`. The function returns the `_id` of the newly inserted user document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password for the user, which will be hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "The `fetch_all_users` function retrieves all users from a database. It utilizes the `dbusers.find()` method, which is likely a part of a MongoDB database interaction, given the presence of `pymongo.MongoClient` in the imports. The function returns the results as a list. The database connection and `dbusers` collection are not defined within this function, suggesting they are established elsewhere in the codebase. This function does not perform any error handling or filtering on the results. It simply fetches all users and returns them.",
        "parameters": [],
        "returns": [
          {
            "name": "users",
            "type": "list",
            "description": "A list of all users in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The `fetch_user` function retrieves a user document from a database based on the provided `username`. It uses the `dbusers` collection and the `find_one` method to locate the user. The function returns the user document if found, or `None` if no matching document exists. The database connection and collection are assumed to be established elsewhere in the codebase. This function does not perform any error handling or validation on the input `username`. The `username` is used directly as the `_id` field in the database query.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be fetched from the database."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict or None",
            "description": "The user document retrieved from the database, or `None` if no matching document exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "The `update_user_name` function updates the name of a user in the database. It takes two parameters, `username` and `new_name`, both of which are strings. The function uses the `update_one` method of the `dbusers` collection to update the `name` field of the document with the matching `_id` (which is set to the `username`). The function returns the number of documents modified by the update operation. Note that this function does not update the `_id` field itself, but rather only the `name` field.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "The update_gemini_key function updates a user's Gemini API key in the database. It takes two parameters: username and gemini_api_key. The function first encrypts the provided API key using the encrypt_text function, then updates the user's document in the database with the encrypted key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is being updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "The `update_gpt_key` function updates a user's GPT API key in the database. It takes two parameters: `username` and `gpt_api_key`. The function first encrypts the provided GPT API key using the `encrypt_text` function. Then, it uses the `update_one` method of the `dbusers` collection to update the user's document with the encrypted key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose GPT API key is to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "The `update_ollama_url` function updates the `ollama_base_url` field for a given user in the database. It takes two parameters: `username` and `ollama_base_url`. The function uses the `dbusers.update_one` method to update the user's document in the database. The `ollama_base_url` parameter is stripped of any leading or trailing whitespace before being updated. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to update."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new `ollama_base_url` value to update for the given user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "The `update_opensrc_key` function updates the Open Source API key for a given user in the database. It takes two parameters: `username` and `opensrc_api_key`. The function encrypts the provided API key using the `encrypt_text` function and then updates the corresponding user document in the database. The function returns the number of documents modified as a result of the update operation. The update operation is performed using the `update_one` method of the `dbusers` collection, which is likely a MongoDB collection. The function appears to be part of a larger system that manages user data and API keys.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom the Open Source API key is being updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The new Open Source API key to be updated for the given user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified as a result of the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "The `update_opensrc_url` function updates the `opensrc_base_url` field for a user in the database. It takes two parameters: `username` and `opensrc_base_url`. The function uses the `dbusers.update_one` method to update the user's document in the database. The `opensrc_base_url` is stripped of leading and trailing whitespace before being updated. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to update."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new `opensrc_base_url` to update for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The `fetch_gemini_key` function retrieves a Gemini API key associated with a given username from a MongoDB database. It uses the `dbusers` collection and filters the result to only include the `gemini_api_key` field. If a user with the specified username is found, the function returns their Gemini API key; otherwise, it returns `None`. This function appears to be part of a larger system that manages user data and API keys. The function's implementation is straightforward, relying on MongoDB's query capabilities to fetch the desired data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "Gemini API key",
            "type": "str or None",
            "description": "The Gemini API key associated with the specified username, or `None` if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The `fetch_ollama_url` function retrieves the Ollama base URL associated with a given username from a database. It uses the `dbusers` collection to find a document with the specified username and returns the `ollama_base_url` field if found. If no document is found, the function returns `None`. The function takes a single parameter, `username`, which is a string. The function does not handle any exceptions that may occur during database operations. The purpose of this function is to provide a way to retrieve the Ollama base URL for a given user.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to retrieve the Ollama base URL for."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the given username, or `None` if no document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The `fetch_gpt_key` function retrieves a GPT API key associated with a given username from a database. It uses the `dbusers` collection to find a document with the specified username and returns the `gpt_api_key` field if found. If no document is found, the function returns `None`. This function appears to be part of a larger system that manages user data and API keys. The function's implementation is straightforward, relying on a simple database query to retrieve the desired information.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the GPT API key."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the given username, or `None` if no key is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "The `fetch_opensrc_key` function retrieves the Open Source API key associated with a given username from the database. It uses the `dbusers` collection and filters the result to only include the `opensrc_api_key` field. If a user with the specified username is found, the function returns their Open Source API key; otherwise, it returns `None`. The function takes a single parameter, `username`, which is expected to be a string. This function appears to be part of a larger system that manages user data and API keys. It does not perform any error checking on the input username beyond what is implicitly done by the database query.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The Open Source API key associated with the given username, or `None` if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "The `fetch_opensrc_url` function retrieves the open source base URL associated with a given username from the database. It uses the `dbusers` collection to find a document with the specified username and returns the `opensrc_base_url` field if found. If no document is found, the function returns `None`. This function appears to be part of a larger system that manages user data and open source URLs. The function's implementation is straightforward, using a simple database query to retrieve the desired information.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to retrieve the open source base URL for."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str or None",
            "description": "The open source base URL associated with the given username, or `None` if no document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The `delete_user` function deletes a user from the database based on their username. It utilizes the `dbusers.delete_one` method to remove the user document from the database. The function returns the number of documents deleted, which should be 1 if the user exists and 0 if the user does not exist. This function appears to be part of a larger database management system, likely using MongoDB as the database. The function's implementation is straightforward, relying on the `delete_one` method to handle the deletion logic.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, which should be 1 if the user exists and 0 if the user does not exist."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "The `get_decrypted_api_keys` function retrieves and decrypts API keys for a given username from the database. It first finds the user document in the database using the provided username. If the user is found, it decrypts the Gemini, GPT, and OpenSrc API keys using the `decrypt_text` function. Additionally, it retrieves the Ollama base URL and OpenSrc base URL from the user document. The function returns the decrypted API keys and base URLs. If the user is not found, the function returns `None` for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to retrieve the API keys."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSrc API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSrc base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The `insert_chat` function creates a new chat entry in the database. It takes two parameters, `username` and `chat_name`, both of which are strings. The function generates a unique identifier for the chat using `uuid.uuid4()` and records the current time using `datetime.now()`. The chat data is then inserted into the database using `dbchats.insert_one()`, and the inserted ID is returned. This function appears to be part of a larger system for managing chat data, possibly in a web application or messaging platform.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted chat document."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "The `fetch_chats_by_user` function retrieves all chats defined by a specific user. It takes a `username` as input, queries the database for chats associated with this user, sorts the results by creation time in ascending order, and returns the sorted list of chats. The function utilizes the `dbchats` collection and relies on the `pymongo` library for database interactions. The purpose of this function is to fetch and organize user-specific chat data. It does not handle any exceptions that may occur during database operations.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chats associated with the specified user, sorted by creation time in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "The function `check_chat_exists` checks if a chat exists in the database for a given username and chat name. It uses the `dbchats` collection to find a document that matches the provided username and chat name. The function returns `True` if such a document exists and `False` otherwise. This function is likely used to validate the existence of a chat before performing further operations. The function's implementation is straightforward, relying on the `find_one` method of the `dbchats` collection.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose chat is being checked."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat being checked."
          }
        ],
        "returns": [
          {
            "name": "existence",
            "type": "bool",
            "description": "A boolean indicating whether the chat exists in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "The `rename_chat_fully` function renames a chat and all associated exchanges. It takes three parameters: `username`, `old_name`, and `new_name`. The function first updates the chat entry in the database using `dbchats.update_one`, and then updates all messages (exchanges) associated with the chat using `dbexchanges.update_many`. The function returns the number of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name for the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The `insert_exchange` function is designed to insert a new exchange record into a database. It takes in various parameters such as question, answer, feedback, username, and chat name, along with some optional parameters like helper used, main used, and time metrics. The function generates a unique ID for the new record, constructs a dictionary representing the exchange, and attempts to insert it into the database. If successful, it returns the new ID; otherwise, it catches any exceptions, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in the exchange."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback related to the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat where the exchange occurred."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "Optional parameter indicating if a helper was used, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "Optional parameter indicating if the main system was used, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Optional parameter for the total time taken, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Optional parameter for the time taken by the helper, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Optional parameter for the time taken by the main system, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Optional parameter for JSON tokens, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Optional parameter for Toon tokens, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Optional parameter for savings percentage, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique ID of the newly inserted exchange record, or None if the insertion fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "The `fetch_exchanges_by_user` function retrieves a list of exchanges associated with a given username from the database. It uses the `dbexchanges` collection and sorts the results by the `created_at` timestamp in ascending order. The function takes a `username` parameter of type `str` and returns a list of exchanges. The database connection is established using `pymongo`, and the `dotenv` library is used to load environment variables. The function does not perform any error handling or validation on the input `username`. The function is designed to be used in a context where the database connection is already established.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to retrieve exchanges"
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the given username, sorted by creation timestamp"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "The `fetch_exchanges_by_chat` function retrieves a list of exchanges from the database that are associated with a specific username and chat name. It uses the `dbexchanges` collection and filters the results based on the provided `username` and `chat_name`. The function returns the list of exchanges in ascending order of their creation time. This function appears to be part of a larger database interaction system, likely used in a chat or messaging application. The function's implementation is straightforward, relying on the `pymongo` library to interact with the database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the exchanges to be retrieved."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat associated with the exchanges to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the provided username and chat name, sorted in ascending order of their creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "The `update_exchange_feedback` function updates the feedback for a specific exchange in the database. It takes an `exchange_id` and a `feedback` value as input, and uses the `dbexchanges.update_one` method to update the corresponding document in the database. The function returns the number of documents modified by the update operation. The feedback value is expected to be an integer. This function appears to be part of a larger database management system, and its purpose is to allow for the updating of exchange feedback in a controlled manner.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "unknown",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The new feedback value for the exchange."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "The `update_exchange_feedback_message` function updates the feedback message for a specific exchange in the database. It takes two parameters: `exchange_id` and `feedback_message`. The function uses the `dbexchanges.update_one` method to update the document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "unknown",
            "description": "The ID of the exchange to update."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to update."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "The `delete_exchange_by_id` function deletes a document from a MongoDB database based on the provided `exchange_id`. It utilizes the `dbexchanges.delete_one` method to perform the deletion and returns the number of documents deleted. The function takes a single parameter, `exchange_id`, which is expected to be a string. The deletion operation is performed on a MongoDB collection, and the result is returned as an integer. This function appears to be part of a larger database management system, likely used to manage exchange data.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the exchange to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The `delete_full_chat` function deletes a specified chat and all associated exchanges from the database. It ensures consistency between the frontend and backend by removing all related data in two steps: first, it deletes all messages in the chat, and then it removes the chat itself from the chat list. The function takes two parameters, `username` and `chat_name`, and returns the number of chats deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of chats deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The `clean_names` function takes a list of model names as input and returns a new list with the names cleaned by splitting each name at the '/' character and keeping only the last part. This function appears to be designed to extract the final component of a path or identifier. It does not perform any error checking on the input list or its elements. The function is implemented using a list comprehension for efficiency and readability.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list",
            "description": "A list of model names to be cleaned."
          }
        ],
        "returns": [
          {
            "name": "cleaned_model_list",
            "type": "list",
            "description": "A list of cleaned model names."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The `get_filtered_models` function filters a list of models based on a selected category. It uses a dictionary `CATEGORY_KEYWORDS` to map category names to keywords. If the category is 'STANDARD', it returns only models that are in the `STANDARD_MODELS` list. Otherwise, it checks each model in the source list to see if any of the keywords for the selected category are present in the model's name. If no models match the keywords, it returns the original source list.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered_list",
            "type": "list",
            "description": "The filtered list of models."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "The `save_gemini_cb` function is designed to save a Gemini key to the database. It retrieves the new key from the session state, checks if it is not empty, and then updates the Gemini key for the current user in the database. After a successful update, it clears the session state variable holding the new key and displays a toast message indicating that the Gemini key has been saved successfully.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "The `save_ollama_cb` function is designed to save a new Ollama URL to the database. It retrieves the new URL from the session state and checks if it is not empty. If the URL is valid, it updates the Ollama URL in the database for the current user and displays a success toast message. The function appears to be part of a Streamlit application, utilizing session state and database interactions. It relies on the `database.db` module for updating the Ollama URL. The function does not take any parameters and does not return any values.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The `load_data_from_db` function loads chat and exchange data from the database for a given username. It checks if the data has already been loaded for the current user and only loads the data if it's a new user or the data hasn't been loaded yet. The function first loads the defined chats, then loads the exchanges and sorts them into their respective chats. If no chats exist, it creates a default chat. Finally, it sets the active chat if necessary.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load the chat and exchange data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "The `handle_feedback_change` function updates the feedback for an exchange in the database and triggers a re-run of the Streamlit application. It takes two parameters: `ex` and `val`, where `ex` is expected to be a dictionary containing the exchange data and `val` is the new feedback value. The function modifies the `ex` dictionary by updating the 'feedback' key with the provided `val`. It then calls the `update_exchange_feedback` function from the `database.db` module to persist this change in the database. Finally, it triggers a re-run of the Streamlit application using `st.rerun()`.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including an '_id' key for database reference."
          },
          {
            "name": "val",
            "type": "str",
            "description": "The new feedback value to be updated in the exchange data and database."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions listed in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "The `handle_delete_exchange` function is designed to delete an exchange by its ID from the database and update the session state accordingly. It takes two parameters: `chat_name` and `ex`, where `ex` is expected to be a dictionary containing an `_id` key. The function first deletes the exchange from the database using `database.db.delete_exchange_by_id`. Then, it checks if the `chat_name` exists in the session state and if the exchange `ex` is listed under that chat's exchanges. If both conditions are met, it removes the exchange from the session state. Finally, it triggers a rerun of the Streamlit application using `st.rerun()` to reflect the changes.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is being deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, containing at least an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The `handle_delete_chat` function is responsible for deleting a specified chat for a given user. It first removes the chat from the database using `database.db.delete_full_chat`, then cleans up the session state by removing the chat from the list of chats. If there are remaining chats, it sets the active chat to the first one in the list; otherwise, it creates a new empty chat and sets it as the active chat. Finally, it triggers a rerun of the Streamlit application to reflect the changes.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose chat is being deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_full_chat and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The `extract_repo_name` function takes a text input and attempts to extract a repository name from it. It does this by searching for a URL in the text, parsing the URL, and then extracting the last part of the path. If the extracted path ends with '.git', it removes this suffix. The function returns the extracted repository name or `None` if no URL is found in the text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to search for a URL and extract a repository name from."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name or `None` if no URL is found in the text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The stream_text_generator function is a generator that splits a given text into words and yields each word with a trailing space. It introduces a delay of 0.01 seconds between each word using the time.sleep function. This function appears to be designed for streaming text, possibly in a frontend application, where the delay is intended to simulate a typing or streaming effect.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be split into words and streamed."
          }
        ],
        "returns": [
          {
            "name": "word",
            "type": "str",
            "description": "Each word from the input text with a trailing space, yielded one at a time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The `render_text_with_mermaid` function is designed to render markdown text that may contain mermaid code blocks. It splits the input markdown text into parts based on mermaid code blocks and then processes each part accordingly. If a part is a mermaid code block, it attempts to render it using the `st_mermaid` function. If rendering fails, it falls back to displaying the code block as plain text. Non-mermaid parts are rendered as markdown or streamed using the `stream_text_generator` function, depending on the `should_stream` parameter.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The markdown text to be rendered, which may contain mermaid code blocks."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the non-mermaid parts of the text or render them directly."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function is responsible for rendering an exchange in a chat interface. It takes two parameters: `ex` and `current_chat_name`. The function displays the question and answer in the chat, along with various buttons for feedback, commenting, downloading, and deleting the exchange. If the answer contains an error, it displays an error message instead. The function uses Streamlit to create the UI components and interacts with the database to update feedback messages and delete exchanges.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing information about the exchange, including the question, answer, and feedback."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is a subclass of ast.NodeVisitor, designed to traverse and analyze the Abstract Syntax Tree (AST) of Python source code. It is responsible for extracting information about imports, functions, and classes from the source code and storing it in a schema. The class provides methods to visit different types of nodes in the AST, including imports, class definitions, function definitions, and asynchronous function definitions.",
        "init_method": {
          "description": "The __init__ method initializes the ASTVisitor object with the source code, file path, and project root. It sets up the schema to store information about imports, functions, and classes, and initializes the current class to None.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code to be analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The file path of the source code."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The project root directory."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "The visit_Import method is called when an import node is encountered in the AST. It extracts the names of the imported modules and adds them to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The import node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when an import node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "The visit_ImportFrom method is called when an import from node is encountered in the AST. It extracts the names of the imported modules and adds them to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The import from node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when an import from node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "The visit_ClassDef method is called when a class definition node is encountered in the AST. It extracts information about the class, including its name, docstring, and source code, and adds it to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The class definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when a class definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "The visit_FunctionDef method is called when a function definition node is encountered in the AST. It extracts information about the function, including its name, arguments, and docstring, and adds it to the schema. If the function is a method of a class, it is added to the class's method context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The function definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when a function definition node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "The visit_AsyncFunctionDef method is called when an asynchronous function definition node is encountered in the AST. It delegates to the visit_FunctionDef method to extract information about the function.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The asynchronous function definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the visit_FunctionDef method.",
                "called_by": "This method is called by the ast.NodeVisitor when an asynchronous function definition node is encountered."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ASTVisitor class depends on the backend.AST_Schema.path_to_module function.",
          "instantiated_by": "The ASTVisitor class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is designed to analyze and process Abstract Syntax Tree (AST) data from Python files. It provides methods to merge relationship data and analyze repositories. The class plays a crucial role in understanding the structure and dependencies of Python projects.",
        "init_method": {
          "description": "The constructor of the ASTAnalyzer class does not take any parameters and does not perform any initialization. It simply passes, indicating that the class's primary functionality is provided through its methods.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "The merge_relationship_data method takes in a full schema and raw relationships data, and merges the relationship data into the schema. It updates the context of functions and classes in the schema with information about outgoing and incoming calls.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema data structure that contains information about the project's files, functions, and classes."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "The raw relationships data that contains information about outgoing and incoming calls between functions and classes."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated full schema with merged relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "The analyze_repository method takes in a list of files and a GitRepository object, and analyzes the repository by parsing the Python files and extracting AST data. It returns a full schema that contains information about the project's files, functions, and classes.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects that contain information about the files in the repository."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "A GitRepository object that provides information about the repository."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema that contains information about the project's files, functions, and classes."
                }
              ],
              "usage_context": {
                "calls": "This method calls the ASTVisitor class to parse the Python files and extract AST data.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ASTAnalyzer class depends on the ASTVisitor class.",
          "instantiated_by": "The ASTAnalyzer class is not instantiated by any other classes in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve file dependencies within a repository. It utilizes the NodeVisitor class from the ast module to traverse the abstract syntax tree of Python files and identify import statements. The class provides methods to resolve relative imports, visit import statements, and track dependencies between files.",
        "init_method": {
          "description": "The __init__ method initializes the FileDependencyGraph object with a filename and a repository root. It sets the filename and repo_root attributes of the object.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to analyze."
            },
            {
              "name": "repo_root",
              "type": "str",
              "description": "The root directory of the repository."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "The _resolve_module_name method resolves relative imports of the form 'from .. import name1, name2' to their actual module or symbol names. It uses the get_all_temp_files, init_exports_symbol, and module_file_exists functions to achieve this.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import statement to resolve."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "This method calls get_all_temp_files, init_exports_symbol, and module_file_exists to resolve relative imports.",
                "called_by": "This method is called by visit_ImportFrom to resolve relative imports."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "The visit_Import method visits an import statement and adds the imported module to the import_dependencies dictionary. It takes an optional base_name parameter to specify the base name of the imported module.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "The import statement to visit."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "The base name of the imported module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by visit_ImportFrom to visit import statements."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "The visit_ImportFrom method visits an import statement of the form 'from a.b.c import d' and adds the imported module to the import_dependencies dictionary. It uses the _resolve_module_name method to resolve relative imports.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import statement to visit."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls _resolve_module_name to resolve relative imports.",
                "called_by": "This method is not called by any other methods."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The FileDependencyGraph class depends on the get_all_temp_files, init_exports_symbol, and module_file_exists functions to resolve relative imports.",
          "instantiated_by": "The FileDependencyGraph class is not instantiated by any other classes or functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class is designed to interact with Google Gemini for generating code snippet documentation. It centralizes API interaction, error handling, and validates I/O using Pydantic. The class is initialized with an API key, function prompt path, class prompt path, and model name. It provides methods to generate and validate documentation for batches of functions and classes.",
        "init_method": {
          "description": "The constructor initializes the LLMHelper object with the provided API key, function prompt path, class prompt path, and model name. It sets up the API interaction, loads the function and class system prompts, and configures the batch settings based on the model name.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for Google Gemini."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "The path to the function system prompt file."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "The path to the class system prompt file."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use for API interaction. Defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for API interaction. Defaults to None."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "This method configures the batch settings based on the model name. It sets the batch size to a specific value depending on the model name.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "The name of the model to use for API interaction."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the constructor to configure the batch settings.",
                "called_by": "The constructor calls this method to configure the batch settings."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "This method generates and validates documentation for a batch of functions. It takes a list of FunctionAnalysisInput objects as input, creates a list of JSON payloads, and sends them to the API for processing. The method returns a list of validated FunctionAnalysis objects.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of FunctionAnalysisInput objects to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "validated_functions",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated FunctionAnalysis objects."
                }
              ],
              "usage_context": {
                "calls": "This method calls the API to generate documentation for the input functions.",
                "called_by": "This method is called by external code to generate documentation for functions."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "This method generates and validates documentation for a batch of classes. It takes a list of ClassAnalysisInput objects as input, creates a list of JSON payloads, and sends them to the API for processing. The method returns a list of validated ClassAnalysis objects.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of ClassAnalysisInput objects to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "validated_classes",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated ClassAnalysis objects."
                }
              ],
              "usage_context": {
                "calls": "This method calls the API to generate documentation for the input classes.",
                "called_by": "This method is called by external code to generate documentation for classes."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The LLMHelper class does not have any external dependencies.",
          "instantiated_by": "The LLMHelper class is instantiated by external code to generate documentation for functions and classes."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class is designed to interact with a Large Language Model (LLM). It provides methods to call the LLM with user input and stream the response. The class is initialized with an API key, a prompt file path, and a model name. It supports various LLM models, including Gemini, GPT, and custom models.",
        "init_method": {
          "description": "The __init__ method initializes the MainLLM class with an API key, a prompt file path, and a model name. It checks if the API key is set and raises a ValueError if it is not. It also reads the system prompt from the prompt file path and sets up the LLM model based on the model name.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for the LLM model."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The path to the prompt file."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the LLM model. Defaults to 'gemini-2.5-pro'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the LLM model. Defaults to None."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "The call_llm method calls the LLM with the user input and returns the response. It creates a list of messages, including the system prompt and the user input, and passes them to the LLM model.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The user input to pass to the LLM model."
                }
              ],
              "returns": [
                {
                  "name": "response",
                  "type": "str",
                  "description": "The response from the LLM model."
                }
              ],
              "usage_context": {
                "calls": "The call_llm method calls the invoke method of the LLM model.",
                "called_by": "The call_llm method is not called by any other method in the class."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "The stream_llm method streams the response from the LLM model. It creates a list of messages, including the system prompt and the user input, and passes them to the LLM model.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The user input to pass to the LLM model."
                }
              ],
              "returns": [
                {
                  "name": "chunk",
                  "type": "str",
                  "description": "A chunk of the response from the LLM model."
                }
              ],
              "usage_context": {
                "calls": "The stream_llm method calls the stream method of the LLM model.",
                "called_by": "The stream_llm method is not called by any other method in the class."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The MainLLM class does not have any external dependencies.",
          "instantiated_by": "The MainLLM class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README, pyproject.toml, and requirements.txt. It initializes a structured dictionary to store the extracted information and provides methods to parse and extract relevant data from these files. The class orchestrates the extraction process, prioritizing the parsing of pyproject.toml, requirements.txt, and README files. It also handles cases where information is not found in these files, using placeholders or deriving information from the repository URL if available.",
        "init_method": {
          "description": "The constructor initializes the ProjektInfoExtractor object with a predefined structure to store project information. It sets up placeholders for project overview and installation details, which are later filled by parsing the respective project files.",
          "parameters": [
            {
              "name": "self",
              "type": "ProjektInfoExtractor",
              "description": "The instance of the ProjektInfoExtractor class."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from a given string content, which can occur due to encoding errors when reading UTF-16 as UTF-8.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjektInfoExtractor",
                  "description": "The instance of the ProjektInfoExtractor class."
                },
                {
                  "name": "content",
                  "type": "str",
                  "description": "The string content to be cleaned."
                }
              ],
              "returns": [
                {
                  "name": "cleaned_content",
                  "type": "str",
                  "description": "The cleaned string content with null bytes removed."
                }
              ],
              "usage_context": {
                "calls": "This method is called by other methods within the class to clean the content of project files before parsing.",
                "called_by": "Methods like _parse_readme, _parse_toml, and _parse_requirements call this method to ensure the content is properly cleaned before extraction."
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches for a file that matches any of the given patterns in a list of files. The search is case-insensitive.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjektInfoExtractor",
                  "description": "The instance of the ProjektInfoExtractor class."
                },
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file patterns to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to search through."
                }
              ],
              "returns": [
                {
                  "name": "found_file",
                  "type": "Optional[Any]",
                  "description": "The file that matches any of the patterns, or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "This method is used by the extrahiere_info method to find specific project files like README, pyproject.toml, and requirements.txt.",
                "called_by": "The extrahiere_info method calls this method to locate the necessary project files for information extraction."
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts a section from a Markdown content based on given keywords. It looks for the section under a Markdown header (##) that matches any of the keywords.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjektInfoExtractor",
                  "description": "The instance of the ProjektInfoExtractor class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The Markdown content to extract from."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords to match the section header."
                }
              ],
              "returns": [
                {
                  "name": "extracted_section",
                  "type": "Optional[str]",
                  "description": "The extracted section content, or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "This method is called by the _parse_readme method to extract specific sections from the README file.",
                "called_by": "The _parse_readme method uses this method to extract sections like Features, Tech Stack, and Status from the README content."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file to extract project information. It cleans the content, extracts the title, description, key features, tech stack, and status, and stores this information in the class's info dictionary.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjektInfoExtractor",
                  "description": "The instance of the ProjektInfoExtractor class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls other methods like _clean_content and _extrahiere_sektion_aus_markdown to clean and extract specific sections from the README content.",
                "called_by": "The extrahiere_info method calls this method as part of the information extraction process, after finding the README file."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file to extract project information. It cleans the content, loads the TOML data, and extracts the project name, description, and dependencies, storing this information in the class's info dictionary.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjektInfoExtractor",
                  "description": "The instance of the ProjektInfoExtractor class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _clean_content method to clean the TOML content before parsing.",
                "called_by": "The extrahiere_info method calls this method as part of the information extraction process, after finding the pyproject.toml file, and with higher priority than the README file."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file to extract project dependencies. It cleans the content, splits the lines, and stores the dependencies in the class's info dictionary, but only if dependencies have not already been found in the pyproject.toml file.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjektInfoExtractor",
                  "description": "The instance of the ProjektInfoExtractor class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the _clean_content method to clean the requirements content before parsing.",
                "called_by": "The extrahiere_info method calls this method as part of the information extraction process, after finding the requirements.txt file."
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the extraction of project information from the given files and repository URL. It finds the relevant files (pyproject.toml, requirements.txt, README), parses them in order of priority, and stores the extracted information in the class's info dictionary. If necessary, it also derives the project title from the repository URL.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjektInfoExtractor",
                  "description": "The instance of the ProjektInfoExtractor class."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to extract information from."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository, used to derive the project title if necessary."
                }
              ],
              "returns": [
                {
                  "name": "extracted_info",
                  "type": "Dict[str, Any]",
                  "description": "The extracted project information stored in the class's info dictionary."
                }
              ],
              "usage_context": {
                "calls": "This method calls other methods like _finde_datei, _parse_toml, _parse_requirements, and _parse_readme to find and parse the project files.",
                "called_by": "This method is the main entry point for extracting project information and is called from outside the class."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not have external dependencies listed in the provided context.",
          "instantiated_by": "The class is not instantiated by any other classes or methods listed in the provided context."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze and construct a call graph from a given Python source code. It utilizes the ast module to parse the source code and the networkx library to create a directed graph representing the call relationships between functions and classes. The class provides various methods to visit and process different types of nodes in the abstract syntax tree, including imports, class definitions, function definitions, and calls.",
        "init_method": {
          "description": "The __init__ method initializes the CallGraph object with a filename and sets up the necessary data structures, including a dictionary to store local definitions, a graph to represent the call relationships, and a set to keep track of visited functions.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "The _recursive_call method is a recursive function that takes an ast node as input and returns a list of name components as a dotted string. It is used to resolve the names of called functions or classes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Node",
                  "description": "The ast node being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the visit_Call method to resolve the names of called functions or classes.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "The _resolve_all_callee_names method takes a list of lists of name components and resolves them into a list of fully qualified names. It checks local definitions and import mappings to resolve the names.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists of name components."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of fully qualified names."
                }
              ],
              "usage_context": {
                "calls": "This method is called by the visit_Call method to resolve the names of called functions or classes.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "The _make_full_name method takes a basename and an optional class name and returns a fully qualified name. It is used to construct the full names of functions and classes.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The basename of the function or class."
                },
                {
                  "name": "class_name",
                  "type": "str | None",
                  "description": "The name of the class, if applicable."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The fully qualified name of the function or class."
                }
              ],
              "usage_context": {
                "calls": "This method is called by the visit_FunctionDef method to construct the full names of functions.",
                "called_by": "This method is called by the visit_FunctionDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "The _current_caller method returns the name of the current caller, which is either the current function or the filename if no function is being visited.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The name of the current caller."
                }
              ],
              "usage_context": {
                "calls": "This method is called by the visit_Call method to get the name of the current caller.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "The visit_Import method visits an import node and updates the import mapping with the imported module names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The import node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the generic_visit method to visit import nodes.",
                "called_by": "This method is called by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "The visit_ImportFrom method visits an import from node and updates the import mapping with the imported module names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The import from node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the generic_visit method to visit import from nodes.",
                "called_by": "This method is called by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "The visit_ClassDef method visits a class definition node and updates the current class name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The class definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the generic_visit method to visit class definition nodes.",
                "called_by": "This method is called by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "The visit_FunctionDef method visits a function definition node and updates the local definitions and the graph with the function name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The function definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the generic_visit method to visit function definition nodes.",
                "called_by": "This method is called by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "The visit_AsyncFunctionDef method visits an asynchronous function definition node and calls the visit_FunctionDef method to process it.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The asynchronous function definition node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the generic_visit method to visit asynchronous function definition nodes.",
                "called_by": "This method is called by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "The visit_Call method visits a call node and updates the graph with the call relationship between the caller and the callee.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The call node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the generic_visit method to visit call nodes.",
                "called_by": "This method is called by the generic_visit method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "The visit_If method visits an if node and checks if the test is a compare node with a left operand of __name__. If so, it sets the current function to <main_block> and visits the node.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The if node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the generic_visit method to visit if nodes.",
                "called_by": "This method is called by the generic_visit method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The CallGraph class depends on the ast and networkx libraries.",
          "instantiated_by": "The CallGraph class is instantiated by the backend module."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file in a Git repository. It provides lazy loading of the file's content, size, and blob object. The class has methods to analyze the file's content, such as counting the number of words. It also provides a dictionary representation of the file's metadata.",
        "init_method": {
          "description": "Initializes the RepoFile object with the file path and commit tree. The file path is stored as an instance attribute, and the commit tree is used to lazy-load the file's blob object.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "Lazy-loads the Git blob object associated with the file. If the blob object is not found in the commit tree, a FileNotFoundError is raised.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The lazy-loaded Git blob object."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the content and size properties."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "Lazy-loads and returns the decoded content of the file. The content is decoded using UTF-8 encoding and ignoring any decoding errors.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The lazy-loaded and decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "This method calls the blob property to lazy-load the blob object.",
                "called_by": "This method is called by the analyze_word_count method."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "Lazy-loads and returns the size of the file in bytes.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The lazy-loaded size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "This method calls the blob property to lazy-load the blob object.",
                "called_by": "This method is called by the to_dict method."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "Analyzes the file's content by counting the number of words. This method uses the content property to lazy-load the file's content.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The number of words in the file's content."
                }
              ],
              "usage_context": {
                "calls": "This method calls the content property to lazy-load the file's content.",
                "called_by": "This method is not called by any other method."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Returns a string representation of the RepoFile object, including the file path.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr",
                  "type": "str",
                  "description": "A string representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other method."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Returns a dictionary representation of the file's metadata, including the file path, name, size, and type. If include_content is True, the file's content is also included in the dictionary.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include the file's content in the dictionary."
                }
              ],
              "returns": [
                {
                  "name": "metadata",
                  "type": "dict",
                  "description": "A dictionary representation of the file's metadata."
                }
              ],
              "usage_context": {
                "calls": "This method calls the size property to lazy-load the file's size.",
                "called_by": "This method is not called by any other method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or method."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to the repository's files as RepoFile objects. It handles the cloning process, including error handling, and provides methods to retrieve all files in the repository and to close the temporary directory. The class also supports the context manager protocol, allowing it to be used in a with statement.",
        "init_method": {
          "description": "The __init__ method initializes the GitRepository object by cloning the specified repository into a temporary directory. It sets up the repository object, retrieves the latest commit, and initializes an empty list to store the repository's files.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "string",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "The get_all_files method retrieves a list of all files in the repository as RepoFile objects. It uses the repository's git ls-files command to get a list of file paths, creates a RepoFile object for each path, and returns the list of RepoFile objects.",
              "parameters": [],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile objects representing the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.getRepo.RepoFile class to create RepoFile objects.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "The close method deletes the temporary directory and its contents. It is called automatically when the GitRepository object is used in a with statement.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the __exit__ method when the GitRepository object is used in a with statement."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "The get_file_tree method returns a dictionary representing the file tree of the repository. It uses the get_all_files method to retrieve a list of RepoFile objects, then constructs a tree data structure from the file paths.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "boolean",
                  "description": "A flag indicating whether to include the file contents in the tree data structure."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the file tree of the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the get_all_files method to retrieve a list of RepoFile objects.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The GitRepository class depends on the backend.getRepo.RepoFile class.",
          "instantiated_by": "The GitRepository class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze a project's structure and relationships between its components. It initializes with a project root directory and provides methods to analyze the project, collect definitions, resolve calls, and retrieve raw relationships. The class utilizes various data structures such as dictionaries and sets to store information about the project's files, definitions, and call graph.",
        "init_method": {
          "description": "The __init__ method initializes the ProjectAnalyzer instance with a project root directory. It sets up the project root, definitions, call graph, file ASTs, and ignore directories. The method takes a project_root parameter, which is used to set the absolute path of the project root directory.",
          "parameters": [
            {
              "name": "project_root",
              "type": "string",
              "description": "The root directory of the project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "The analyze method is responsible for analyzing the project's structure and relationships. It finds all Python files in the project, collects definitions, and resolves calls. The method returns the call graph, which represents the relationships between the project's components.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectAnalyzer",
                  "description": "The instance of the ProjectAnalyzer class."
                }
              ],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "dict",
                  "description": "A dictionary representing the call graph of the project."
                }
              ],
              "usage_context": {
                "calls": "The analyze method calls the _find_py_files, _collect_definitions, and _resolve_calls methods to perform the analysis.",
                "called_by": "The analyze method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "The get_raw_relationships method retrieves the raw relationships between the project's components. It constructs outgoing and incoming relationships based on the call graph and returns them as a dictionary.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectAnalyzer",
                  "description": "The instance of the ProjectAnalyzer class."
                }
              ],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing the outgoing and incoming relationships between the project's components."
                }
              ],
              "usage_context": {
                "calls": "The get_raw_relationships method does not call any other methods.",
                "called_by": "The get_raw_relationships method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "The _find_py_files method finds all Python files in the project. It walks through the project directory, ignoring certain directories, and returns a list of Python file paths.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectAnalyzer",
                  "description": "The instance of the ProjectAnalyzer class."
                }
              ],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list",
                  "description": "A list of Python file paths in the project."
                }
              ],
              "usage_context": {
                "calls": "The _find_py_files method does not call any other methods.",
                "called_by": "The _find_py_files method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "The _collect_definitions method collects definitions from a Python file. It parses the file's AST, extracts function and class definitions, and stores them in the definitions dictionary.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectAnalyzer",
                  "description": "The instance of the ProjectAnalyzer class."
                },
                {
                  "name": "filepath",
                  "type": "string",
                  "description": "The path to the Python file to collect definitions from."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "The _collect_definitions method calls the path_to_module function.",
                "called_by": "The _collect_definitions method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "The _get_parent method finds the parent node of a given node in the AST. It walks through the AST and returns the parent node if found.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectAnalyzer",
                  "description": "The instance of the ProjectAnalyzer class."
                },
                {
                  "name": "tree",
                  "type": "AST",
                  "description": "The AST to search for the parent node."
                },
                {
                  "name": "node",
                  "type": "Node",
                  "description": "The node to find the parent of."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "Node",
                  "description": "The parent node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "The _get_parent method does not call any other methods.",
                "called_by": "The _get_parent method is called by the _collect_definitions method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "The _resolve_calls method resolves calls in a Python file. It uses the CallResolverVisitor to visit the file's AST and resolve calls, then updates the call graph with the resolved calls.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectAnalyzer",
                  "description": "The instance of the ProjectAnalyzer class."
                },
                {
                  "name": "filepath",
                  "type": "string",
                  "description": "The path to the Python file to resolve calls in."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "The _resolve_calls method calls the CallResolverVisitor.",
                "called_by": "The _resolve_calls method is called by the analyze method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ProjectAnalyzer class depends on the CallResolverVisitor and path_to_module functions.",
          "instantiated_by": "The ProjectAnalyzer class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is a subclass of ast.NodeVisitor, designed to analyze and resolve calls within a given Python module. It tracks the current caller, class, and module, and resolves calls to their fully qualified names. The class is responsible for maintaining a scope of imported modules and classes, as well as instance types. It provides methods to visit different types of nodes in the abstract syntax tree (AST), including ClassDef, FunctionDef, Call, Import, ImportFrom, and Assign.",
        "init_method": {
          "description": "The __init__ method initializes the CallResolverVisitor instance with the given filepath, project_root, and definitions. It sets up the module path, scope, instance types, and current caller and class names.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The path to the Python file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary of definitions for the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "The visit_ClassDef method is called when a ClassDef node is encountered in the AST. It updates the current class name and visits the node's children.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not make any calls to other methods or functions.",
                "called_by": "This method is called by the ast.NodeVisitor when a ClassDef node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "The visit_FunctionDef method is called when a FunctionDef node is encountered in the AST. It updates the current caller name and visits the node's children.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not make any calls to other methods or functions.",
                "called_by": "This method is called by the ast.NodeVisitor when a FunctionDef node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "The visit_Call method is called when a Call node is encountered in the AST. It resolves the call to its fully qualified name and updates the calls dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The Call node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not make any calls to other methods or functions.",
                "called_by": "This method is called by the ast.NodeVisitor when a Call node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "The visit_Import method is called when an Import node is encountered in the AST. It updates the scope with the imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not make any calls to other methods or functions.",
                "called_by": "This method is called by the ast.NodeVisitor when an Import node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "The visit_ImportFrom method is called when an ImportFrom node is encountered in the AST. It updates the scope with the imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not make any calls to other methods or functions.",
                "called_by": "This method is called by the ast.NodeVisitor when an ImportFrom node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "The visit_Assign method is called when an Assign node is encountered in the AST. It updates the instance types with the assigned values.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The Assign node being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not make any calls to other methods or functions.",
                "called_by": "This method is called by the ast.NodeVisitor when an Assign node is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "The _resolve_call_qname method resolves a call to its fully qualified name.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.Node",
                  "description": "The node representing the function being called."
                }
              ],
              "returns": [
                {
                  "name": "fully_qualified_name",
                  "type": "str",
                  "description": "The fully qualified name of the function being called."
                }
              ],
              "usage_context": {
                "calls": "This method does not make any calls to other methods or functions.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The CallResolverVisitor class depends on the backend.relationship_analyzer.path_to_module function.",
          "instantiated_by": "The CallResolverVisitor class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic model that represents a single parameter of a function. It encapsulates the name, type, and description of the parameter, providing a structured way to document and validate function parameters. This class is designed to be instantiated with specific parameter details, allowing for easy access and manipulation of parameter information. The class's primary responsibility is to provide a clear and concise representation of a function's parameters, making it easier to understand and work with the function's interface.",
        "init_method": {
          "description": "The ParameterDescription class is initialized with three parameters: name, type, and description. These parameters are used to set the corresponding instance attributes, which are then used to represent the parameter. The constructor does not perform any complex logic, simply assigning the provided values to the instance attributes.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A brief description of the parameter."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ParameterDescription class has no external dependencies.",
          "instantiated_by": "The ParameterDescription class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model that represents the return value of a function. It encapsulates the name, type, and description of the return value, providing a structured way to document and validate function returns.",
        "init_method": {
          "description": "The class is initialized with three parameters: name, type, and description, which are all strings. These parameters are used to set up the instance attributes of the class.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ReturnDescription class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model that describes the calling context of a function. It encapsulates information about the functions a method calls and where it is used. The class has two attributes: calls and called_by, which are both strings.",
        "init_method": {
          "description": "The class is initialized with two parameters: calls and called_by. These parameters are used to set the corresponding instance attributes.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string representing the functions a method calls."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string representing where the method is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The UsageContext class has no external dependencies.",
          "instantiated_by": "The UsageContext class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class represents a detailed analysis of a function's purpose and signature. It contains attributes for the overall description, parameters, return values, and usage context. This class is designed to provide a structured way of documenting and analyzing functions.",
        "init_method": {
          "description": "The class is initialized with attributes for overall description, parameters, return values, and usage context. The constructor does not have any explicit parameters, relying on the default initialization of the BaseModel.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionDescription class does not have any external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class represents a model for analyzing functions, encapsulating their identifier, description, and potential errors. It inherits from pydantic's BaseModel, ensuring data validation and parsing capabilities. The class is designed to provide a structured representation of function analysis data, facilitating the creation of comprehensive reports.",
        "init_method": {
          "description": "The FunctionAnalysis class is initialized with an identifier, a description of type FunctionDescription, and an optional error message. The identifier uniquely represents the function being analyzed, while the description provides detailed insights into the function's purpose and behavior. The error field allows for the capture of any errors encountered during the analysis process.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function being analyzed."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "A detailed description of the function, including its purpose, parameters, and return values."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional error message, used to capture any errors encountered during the analysis process."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionAnalysis class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is designed to describe the __init__ method of another class. It encapsulates information about the constructor's description and parameters, providing a structured way to represent and analyze class initialization.",
        "init_method": {
          "description": "The ConstructorDescription class is initialized with a description and a list of parameters. The description is a string that provides a human-readable summary of the constructor's purpose, while the parameters are a list of ParameterDescription objects that detail the constructor's arguments.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A string describing the constructor's purpose."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing the constructor's arguments."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ConstructorDescription class has no external dependencies.",
          "instantiated_by": "The ConstructorDescription class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model that describes the external dependencies and primary points of instantiation of a class. It has two attributes: dependencies and instantiated_by, which are both strings.",
        "init_method": {
          "description": "The ClassContext class is initialized with two parameters: dependencies and instantiated_by, which are both strings. These parameters are used to set the corresponding instance attributes.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the class's external dependencies."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string describing the primary points of instantiation of the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassContext class has no external dependencies.",
          "instantiated_by": "The ClassContext class is not instantiated by any other classes or functions."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to contain the detailed analysis of a class's purpose, constructor, and methods. It provides a structured way to represent the analysis of a class, including its overall purpose, constructor details, method descriptions, and usage context. This class is essential for documenting and understanding the behavior of other classes.",
        "init_method": {
          "description": "The ClassDescription class is initialized with four attributes: overall, init_method, methods, and usage_context. The overall attribute is a string that describes the class's purpose, init_method is an object of type ConstructorDescription, methods is a list of FunctionAnalysis objects, and usage_context is an object of type ClassContext.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the class's purpose."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object describing the class's constructor."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of objects describing the class's methods."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object describing the class's usage context."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassDescription class has no external dependencies.",
          "instantiated_by": "The ClassDescription class is not instantiated by any other class."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class represents the main model for the entire JSON schema for a class, encapsulating its identifier, description, and potential error information.",
        "init_method": {
          "description": "The ClassAnalysis class is initialized with an identifier, description, and an optional error message.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string representing the class identifier."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An object of type ClassDescription, containing detailed information about the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string representing an error message, defaulting to None."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassAnalysis class has no external dependencies.",
          "instantiated_by": "The ClassAnalysis class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer, capturing details such as the file, function, mode, and line number. It is designed to be used in 'called_by' and 'instantiated_by' lists, providing a structured way to track call events. This class inherits from pydantic's BaseModel, leveraging its validation capabilities. The class's primary responsibility is to provide a standardized representation of call events, facilitating analysis and documentation.",
        "init_method": {
          "description": "The CallInfo class is initialized with four parameters: file, function, mode, and line. These parameters are used to set up the instance attributes, which are then used to represent the call event. The file attribute stores the name of the file where the call occurred, the function attribute stores the name of the caller, the mode attribute stores the type of call (e.g., 'method', 'function', 'module'), and the line attribute stores the line number where the call occurred.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The name of the file where the call occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the caller."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The type of call (e.g., 'method', 'function', 'module')."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number where the call occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The CallInfo class has no external dependencies.",
          "instantiated_by": "The CallInfo class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class represents a structured context for analyzing a function, encapsulating information about the functions it calls and the entities that call it.",
        "init_method": {
          "description": "The class is initialized with two parameters: calls and called_by, which are lists of strings and CallInfo objects, respectively.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of function calls made by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the entities that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionContextInput class has no external dependencies.",
          "instantiated_by": "The FunctionContextInput class is not instantiated by any known entities."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class represents the required input to generate a FunctionAnalysis object. It inherits from pydantic's BaseModel and contains fields for mode, identifier, source code, imports, and context. The class is designed to provide a structured input for function analysis, ensuring that all necessary information is provided. The mode field is restricted to 'function_analysis', indicating the specific purpose of this input. The class's primary responsibility is to validate and structure the input data for further analysis.",
        "init_method": {
          "description": "The class is initialized with the required fields: mode, identifier, source_code, imports, and context. The mode field is set to 'function_analysis', and the identifier, source_code, and imports are set to the provided values. The context field is set to an instance of FunctionContextInput.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "The mode of the function analysis, restricted to 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The identifier of the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the function being analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the function being analyzed."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "An instance of FunctionContextInput providing additional context for the function analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionAnalysisInput class has no external dependencies.",
          "instantiated_by": "The FunctionAnalysisInput class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class represents a structured context for a class's methods, encapsulating information about the method's identifier, calls, callers, arguments, and documentation.",
        "init_method": {
          "description": "The class is initialized with attributes that provide context for a method, including its identifier, calls, callers, arguments, and documentation.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The identifier of the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of methods or functions called by the method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of callers of the method, where each caller is represented by a CallInfo object."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of argument names for the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "The documentation string for the method, if available."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions, as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class represents a structured context for analyzing a class, encapsulating dependencies, instantiation information, and method context.",
        "init_method": {
          "description": "The class is initialized with dependencies, instantiated_by, and method_context attributes, providing a foundation for class analysis.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of dependencies for the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of call information for where the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of method context inputs for the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class represents the required input to generate a ClassAnalysis object. It inherits from pydantic's BaseModel and defines the structure for class analysis inputs. The class has attributes for mode, identifier, source code, imports, and context, which are used to provide a comprehensive analysis of a given class.",
        "init_method": {
          "description": "The class is initialized with the provided mode, identifier, source code, imports, and context. The mode is restricted to 'class_analysis', and the identifier, source code, and imports are expected to be strings or lists of strings. The context is an instance of ClassContextInput.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "The mode of analysis, which is restricted to 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The identifier of the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the class being analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the class being analyzed."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "An instance of ClassContextInput providing additional context for the analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassAnalysisInput class has no external dependencies.",
          "instantiated_by": "The ClassAnalysisInput class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    }
  }
}