{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "This function converts a file path into a Python module path. It takes a file path and a project root directory as input, and returns the corresponding module path. The function handles cases where the file path is not relative to the project root. It also removes the '.py' extension and replaces directory separators with dots to form the module path.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The file path to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The module path corresponding to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies within a repository. It takes a filename, an Abstract Syntax Tree (AST), and the repository root as inputs. The function utilizes a tree visitor to traverse the AST, identifying import dependencies and adding them to the graph. The graph is then returned, encapsulating the dependency relationships between files.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which the dependency graph is being constructed."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The Abstract Syntax Tree representing the file's structure."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.FileDependencyGraph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between files in a Git repository. It iterates over all Python files in the repository, builds a dependency graph for each file using the `build_file_dependency_graph` function, and then aggregates these graphs into a single, global graph. The function returns this global graph as a networkx DiGraph object.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository for which to build the dependency graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "The aggregated dependency graph for the entire repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.build_file_dependency_graph.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves a list of all Python files within a specified directory and its subdirectories. It uses the `pathlib` module to interact with the file system. The function takes a directory path as input, resolves it to an absolute path, and then uses the `rglob` method to find all files with the `.py` extension. The results are returned as a list of `Path` objects relative to the root directory.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of `Path` objects representing all Python files found in the directory and its subdirectories, relative to the root directory."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "This function serves as a main orchestrator for testing the LLMHelper class. It defines pre-computed analyses for several methods, including 'add_item', 'check_stock', and 'generate_report'. These analyses are then used to generate documentation for the InventoryManager class.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "LLMHelper, FunctionAnalysisInput.model_validate, ClassAnalysisInput",
          "called_by": ""
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "This function generates a DOT file from a directed graph, ensuring node names are safe for use in the DOT language. It creates a mapping of original node names to safe names, relabels the graph nodes, and then writes the graph to a file in DOT format.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input directed graph to be converted."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT file will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "This function constructs a filtered call graph from a given Git repository, focusing only on functions written by the user. It iterates through all Python files in the repository, parses their abstract syntax trees (ASTs), and extracts function definitions and call relationships. The function then builds a directed graph (nx.DiGraph) representing the call relationships between user-defined functions.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "The Git repository object from which to construct the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the call relationships between user-defined functions in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls the 'backend.callgraph.CallGraph' class.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "This function takes a content string as input and wraps it in CDATA (Character Data) tags, which are used in XML to escape a block of text so that it is treated as character data, not parsed as XML. The function returns the wrapped content as a string. It does not perform any validation or transformation on the input content. The purpose of this function is to ensure that the content is properly escaped for inclusion in an XML document.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The `extract_output_content` function processes a list of output objects and extracts text or image data. It handles images by decoding Base64 strings to bytes and returns a list of text strings or placeholders. The function iterates over each output object, checks its type, and extracts relevant data. It also updates an image list with processed image data.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of output objects to be processed."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list to store processed image data."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of extracted text strings or image placeholders."
          }
        ],
        "usage_context": {
          "calls": "This function calls the `process_image` helper function with 'image/png' and 'image/jpeg' mime types.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The `process_image` function processes a given image MIME type by retrieving its base64 encoded string from a data dictionary, sanitizing the string, and adding it to a list of images. It then returns an XML placeholder for the image. If the MIME type is not found in the data or an error occurs during processing, it returns an error message or `None`.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "image_placeholder",
            "type": "str",
            "description": "An XML placeholder for the image, or an error message if processing fails."
          },
          {
            "name": "None",
            "type": "None",
            "description": "If the MIME type is not found in the data."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "This function converts a notebook file content to XML format. It reads the notebook using nbformat, processes each cell based on its type (markdown or code), and constructs XML parts accordingly. The function handles errors during JSON/Notebook parsing and returns the XML content along with any extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the notebook file to be converted."
          }
        ],
        "returns": [
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML representation of the notebook content."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of images extracted during the conversion process."
          }
        ],
        "usage_context": {
          "calls": "This function calls extract_output_content and wrap_cdata.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files, identifies Jupyter notebook files (.ipynb), converts their content to XML, and returns a dictionary with the conversion results. It logs information about the number of notebooks found and the processing of each notebook. The function utilizes an external converter function to perform the notebook-to-XML conversion.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of files in the repository, where each file is expected to have a 'path' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary where keys are the paths of the notebook files and values are dictionaries containing the XML output and a list of images."
          }
        ],
        "usage_context": {
          "calls": "This function calls the convert_notebook_to_xml function from the backend.converter module.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "This function creates a bar chart comparing JSON and TOON tokens, highlighting the savings percentage, and saves it to a specified output path. It takes four parameters: json_tokens, toon_tokens, savings_percent, and output_path. The function uses matplotlib to generate the chart with labels, values, and a grid. It displays the value of each bar above it and saves the chart to the output path.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage of savings."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function 'calculate_net_time' calculates the net time by subtracting sleep times from the total duration, considering rate limits for the 'gemini-' model. It takes into account the number of batches and the sleep count to determine the total sleep time. If the model name does not start with 'gemini-', it returns the total duration. The function handles edge cases such as zero total items and non-positive net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "datetime",
            "description": "The start time of the operation."
          },
          {
            "name": "end_time",
            "type": "datetime",
            "description": "The end time of the operation."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items processed."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The batch size for processing items."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model used, which affects rate limiting."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "int",
            "description": "The net time after subtracting sleep times, or the total duration if the model is not 'gemini-'."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is the primary entry point for the backend processing pipeline. It takes in user input, API keys, and model names, and orchestrates the analysis of a Git repository. The function performs various tasks such as cloning the repository, extracting basic project information, constructing a file tree, analyzing relationships between code elements, and generating an abstract syntax tree (AST). It then uses HelperLLM and MainLLM to analyze functions and classes, and generates a final report.",
        "parameters": [
          {
            "name": "input",
            "type": "string",
            "description": "The user input to be processed."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary containing model names for the HelperLLM and MainLLM."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "An optional callback function to update the status of the workflow."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "string",
            "description": "The final report generated by the MainLLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics about the workflow execution."
          }
        ],
        "usage_context": {
          "calls": "This function calls the following functions: backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The `update_status` function updates the status by invoking a callback function with a given message and logging the message at the info level.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be used for updating the status."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function is designed to process a repository of notebooks through a specified model (e.g., GPT or Gemini). It extracts information from the repository, generates reports for each notebook, and saves these reports to a file. The function also tracks its progress and performance metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "string",
            "description": "The input string containing a URL to a GitHub repository."
          },
          {
            "name": "api_keys",
            "type": "object",
            "description": "A dictionary of API keys for different models."
          },
          {
            "name": "model",
            "type": "string",
            "description": "The name of the model to use for processing (e.g., 'gpt-', 'gemini-', etc.)."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "An optional callback function to update the status."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "string",
            "description": "The final report generated from processing all notebooks."
          },
          {
            "name": "metrics",
            "type": "object",
            "description": "A dictionary of performance metrics."
          }
        ],
        "usage_context": {
          "calls": "This function calls the following functions: backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The `gemini_payload` function constructs a payload for the Gemini model by combining context information, notebook XML structure, and image data. It takes in basic information, a notebook path, XML content, and image data, and returns a list of payload content. The function uses regular expressions to find image placeholders in the XML content and replaces them with base64-encoded image data.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "object",
            "description": "Basic information about the project"
          },
          {
            "name": "nb_path",
            "type": "string",
            "description": "The current notebook path"
          },
          {
            "name": "xml_content",
            "type": "string",
            "description": "The XML content of the notebook"
          },
          {
            "name": "images",
            "type": "list",
            "description": "A list of image data"
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "list",
            "description": "A list of payload content, including text and image data"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "This function converts a file path into a Python module path. It takes a file path and a project root directory as input, calculates the relative path, and then transforms it into a module path by replacing directory separators with dots. The function also handles cases where the file path is absolute or the file has a .py extension.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute file path to be converted."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The module path equivalent to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "This function encrypts a given text using a cipher suite. If the input text is empty or the cipher suite is not available, it returns the original text. The function appears to be part of a larger system that handles encryption and decryption of text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text if encryption is successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "This function decrypts a given text using a cipher suite. If the input text is empty or the cipher suite is not available, it returns the original text. The function handles exceptions by returning the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text if successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The `insert_user` function creates a new user document in the database with the provided username, name, and password. The password is hashed using `stauth.Hasher.hash` before being stored. The function then inserts this user document into the database and returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password for the user, which will be hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the user document inserted into the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all users from a database collection named 'dbusers' and returns them as a list. It appears to be part of a larger database interaction system, likely using MongoDB given the 'dbusers.find()' method. The function does not take any parameters and does not include any error handling or data processing beyond the query itself.",
        "parameters": [],
        "returns": [
          {
            "name": "list_of_users",
            "type": "list",
            "description": "A list of user documents retrieved from the 'dbusers' collection."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "This function retrieves a user's data from the database based on their username. It uses the pymongo library to interact with the MongoDB database. The function takes a username as input and returns the corresponding user document from the database. If no user is found, it returns None. The function's logic is straightforward and does not perform any complex operations.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be fetched from the database."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict",
            "description": "The user document from the database, or None if no user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name of a user in the database. It takes a username and a new name as input, and modifies the 'name' field of the user document in the database. The function returns the number of documents modified.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The current username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates a user's Gemini API key in the database. It takes a username and a Gemini API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is being updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be stored for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "This function updates a user's GPT API key in the database. It takes a username and a GPT API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose GPT API key is being updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the 'ollama_base_url' field for a specified user in the database. It takes a username and a URL as input, strips any leading/trailing whitespace from the URL, and then updates the corresponding document in the database. The function returns the number of documents modified by the operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the account to update."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new URL to set for the 'ollama_base_url' field."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the Open Source API key for a given user in the database. It takes a username and an Open Source API key as input, encrypts the key, and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The new Open Source API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the open source base URL for a given user in the database. It takes a username and an open source base URL as input, strips any leading or trailing whitespace from the URL, and then updates the corresponding field in the user's document. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose open source base URL is to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new open source base URL to be set for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "This function retrieves a Gemini API key for a given username from a MongoDB database. It queries the 'dbusers' collection with the provided username and projects only the 'gemini_api_key' field. If a matching user is found, it returns the Gemini API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The Gemini API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "This function retrieves the 'ollama_base_url' for a given username from the database. It queries the 'dbusers' collection using the provided username and returns the 'ollama_base_url' if found, otherwise it returns None. The function takes a username as input and uses it to find the corresponding user document in the database. It then extracts and returns the 'ollama_base_url' from the user document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The 'ollama_base_url' associated with the given username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "This function retrieves a GPT API key for a given username from a MongoDB database. It queries the 'dbusers' collection for a document matching the provided username and projects only the 'gpt_api_key' field. If a matching document is found, it returns the GPT API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The GPT API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the Open Source API key for a given username from the database. It queries the 'dbusers' collection with the provided username and projects only the 'opensrc_api_key' field. If a matching user is found, it returns the API key; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The Open Source API key associated with the username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function retrieves the open-source base URL for a given username from a MongoDB database. It queries the 'dbusers' collection with the provided username and projects only the 'opensrc_base_url' field. If a matching user is found, it returns their open-source base URL; otherwise, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to look up in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The open-source base URL for the given username, or None if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "This function deletes a user from the database by their username. It utilizes the pymongo library to interact with the MongoDB database. The function takes a username as input, uses it to query the database, and returns the number of documents deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys for a given username from a database. It searches for a user by their username, decrypts their API keys, and returns them along with some additional information. If the user is not found, it returns None for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to retrieve and decrypt API keys."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The OLLAMA base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSRC base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "This function creates a new chat entry in the database. It generates a unique ID for the chat, records the username, chat name, and the current timestamp. The function then inserts this new chat entry into the database and returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user creating the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted chat document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "This function retrieves all chats defined for a given user from the database. It uses the pymongo library to query the database and sorts the results by creation date in ascending order. The function takes a username as input and returns a list of chats associated with that user.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chats associated with the given username."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks if a chat with a given name exists for a specific username in the database. It uses a MongoDB collection to perform the query. The function takes two parameters, a username and a chat name, and returns a boolean value indicating whether the chat exists.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to check for chat existence."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if the chat exists for the given username, False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and all associated exchanges for a given user. It updates the chat name in the database and then updates all messages (exchanges) associated with the old chat name. The function returns the number of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who owns the chat."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name for the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "This function inserts a new exchange record into the database. It creates a new document with the provided details, including question, answer, feedback, and various metrics. The function generates a unique ID for the new record and attempts to insert it into the database. If successful, it returns the new ID; otherwise, it catches the exception, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "The feedback given."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used (optional, default: '')."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main used (optional, default: '')."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "The total time (optional, default: '')."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "The helper time (optional, default: '')."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "The main time (optional, default: '')."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The JSON tokens (optional, default: 0)."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The toon tokens (optional, default: 0)."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The savings percent (optional, default: 0.0)."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The ID of the newly inserted exchange record, or None if the insertion fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves a list of exchanges associated with a given username from a database, sorted by a timestamp field 'created_at' in ascending order. The function appears to be part of a larger system that interacts with a MongoDB database using the PyMongo library. It takes a username as input and returns a list of exchanges. The purpose of this function is to fetch and return user-specific exchange data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch exchanges."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the given username."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a list of exchanges for a specific chat given a username and chat name. It queries a database collection named 'exchanges' with a filter on 'username' and 'chat_name', sorts the results by 'created_at' in ascending order, and returns the sorted list. The function appears to be part of a larger system using MongoDB for data storage.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose exchanges are being fetched."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat for which exchanges are being retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges for the specified chat and user, sorted by creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "This function updates the feedback for a specific exchange in the database. It takes an exchange ID and a feedback value as input, and returns the number of documents modified by the update operation. The function uses the PyMongo library to interact with the MongoDB database. It targets a specific document in the 'dbexchanges' collection based on the provided exchange ID and sets the 'feedback' field to the given value.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The new feedback value to be set."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message for a specific exchange in the database. It takes an exchange ID and a feedback message as input, and returns the number of documents modified by the update operation. The function uses the PyMongo library to interact with the MongoDB database. It targets a specific document in the 'dbexchanges' collection based on the provided exchange ID and updates the 'feedback_message' field with the given feedback message.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "objectId",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be stored."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes an exchange by its ID from the database and returns the number of documents deleted. It takes an exchange ID as input, uses it to query the database, and then removes the corresponding document. The function is designed to interact with a MongoDB database using the PyMongo library. It returns the count of deleted documents.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the exchange to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "This function deletes a full chat and all associated exchanges for a given username and chat name. It ensures consistency between the frontend and backend by removing all related data. The function first deletes all messages in the chat, then removes the chat itself from the chat list. It returns the number of chats deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the chat owner."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of chats deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "This function takes a list of model names, splits each name by the '/' character, and returns a list of the last part of each name. It appears to be used for cleaning or standardizing model names by extracting the final part of a potentially full path. The function uses a list comprehension to achieve this in a concise manner. It does not include any error handling or type checking for the inputs.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list",
            "description": "A list of model names or paths to be cleaned."
          }
        ],
        "returns": [
          {
            "name": "cleaned_names",
            "type": "list",
            "description": "A list of cleaned model names."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "This function filters a list of models based on a selected category. It uses predefined keywords for each category to determine which models to include in the filtered list. If the category includes the keyword 'STANDARD', it only returns models that are also in the standard models list. Otherwise, it checks if any of the category's keywords are present in the model's name.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered_list",
            "type": "list",
            "description": "The filtered list of models."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function saves a Gemini key to the database. It retrieves the key from the session state, updates the database with the new key for the current user, and then clears the session state. If successful, it displays a toast notification.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function saves a new Ollama URL to the database. It retrieves the URL from the session state, updates the database with the new URL for the current user, and displays a toast notification upon success. The function appears to be part of a Streamlit application, utilizing session state and database interactions.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The function `load_data_from_db` loads chat and exchange data consistently from the database for a given user. It checks if the user has already been loaded, and if not, it initializes the user's chat data. The function loads defined chats, then exchanges, and sorts them accordingly. It also creates a default chat if none exist and sets the active chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to load data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls `database.db.fetch_chats_by_user`, `database.db.fetch_exchanges_by_user`, and `database.db.insert_chat`.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value associated with an exchange in the database and reruns the Streamlit application. It takes an exchange object and a new feedback value as input, modifies the exchange object with the new feedback, updates the database, and then triggers a rerun of the Streamlit application.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "The exchange object containing an ID and potentially other exchange-related data."
          },
          {
            "name": "val",
            "type": "str",
            "description": "The new feedback value to be associated with the exchange."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "This function handles the deletion of an exchange from a chat session. It removes the exchange from the database and updates the chat session state accordingly. The function then triggers a rerun of the Streamlit application to reflect the changes.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session from which the exchange is being deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "The exchange to be deleted, represented as a dictionary containing an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "This function handles the deletion of a chat. It calls the database function to delete the chat, updates the session state by removing the chat and setting a new active chat if necessary. If all chats are deleted, it creates a new empty chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who owns the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_full_chat and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "This function takes a string input and attempts to extract a repository name from it by searching for a URL pattern. If a URL is found, it parses the URL to extract the path and then derives the repository name from the last part of the path. The function returns the extracted repository name or None if no URL or repository name is found.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input string to search for a URL and extract the repository name."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name or None if no URL or repository name is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "This function generates a stream of text by splitting the input text into words and yielding each word followed by a space. It introduces a delay of 10 milliseconds between each word.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be streamed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "This function renders markdown text with mermaid code blocks using Streamlit. It splits the markdown text into parts, rendering non-mermaid parts as markdown and mermaid parts as mermaid diagrams. If streaming is enabled, it streams the text; otherwise, it renders it directly.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The markdown text to be rendered, which may contain mermaid code blocks."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the text or render it directly. Defaults to False."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function is responsible for rendering a single exchange in a chat interface. It displays the user's question, the assistant's answer, and provides various interactive elements such as feedback buttons, a comment popover, a download button, and a delete button. The function handles different scenarios, including error cases, and updates the exchange's feedback message and status accordingly.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including the question, answer, feedback, and other relevant information."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls the following functions: database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is not called by any other functions in the provided context."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python source code and extract relevant information about its structure. It initializes with source code, file path, and project root, and provides methods to visit different types of nodes in the AST, such as imports, class definitions, and function definitions. The class populates a schema that includes information about imports, functions, and classes found in the source code.",
        "init_method": {
          "description": "The constructor of the ASTVisitor class initializes the object with the source code, file path, and project root. It sets up the module path from the file path and project root, and creates an empty schema to store information about imports, functions, and classes. The constructor also calls the path_to_module function to determine the module path.",
          "parameters": [
            {
              "name": "self",
              "type": "reference",
              "description": "Reference to the instance of the class."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code to be analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file containing the source code."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method is called when an Import node is encountered in the AST. It extracts the names of the imported modules and adds them to the schema's imports list.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method is called when an ImportFrom node is encountered in the AST. It extracts the module name and the names of the imported modules, and adds them to the schema's imports list.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method is called when a ClassDef node is encountered in the AST. It extracts information about the class, such as its name, docstring, and source code, and adds it to the schema's classes list.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method is called when a FunctionDef node is encountered in the AST. It extracts information about the function, such as its name, arguments, docstring, and source code, and adds it to the schema's functions list or the current class's methods list.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method is called when an AsyncFunctionDef node is encountered in the AST. It delegates to the visit_FunctionDef method for analysis.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node from the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the path_to_module function from the backend.AST_Schema module.",
          "instantiated_by": "The class is instantiated by code that needs to analyze the structure of Python source code."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is designed to analyze Abstract Syntax Tree (AST) schema data. It provides methods to merge relationship data into a full schema and to analyze a repository by parsing its Python files and extracting relevant information.",
        "init_method": {
          "description": "The constructor of the ASTAnalyzer class does not initialize any instance attributes. It is a simple constructor that does nothing.",
          "parameters": [
            {
              "name": "self",
              "type": "instance of ASTAnalyzer",
              "description": "Reference to the instance of the class."
            }
          ]
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method merges relationship data into a full schema. It updates the 'context' of each function and class in the schema with their respective calls and called_by relationships.",
              "parameters": [
                {
                  "name": "self",
                  "type": "instance of ASTAnalyzer",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema to be updated with relationship data."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "The raw relationship data to be merged into the full schema."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated full schema with merged relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method analyzes a repository by parsing its Python files and extracting relevant information. It uses the ASTVisitor class to visit each file's AST and extract schema nodes.",
              "parameters": [
                {
                  "name": "self",
                  "type": "instance of ASTAnalyzer",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects to be analyzed."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "The Git repository being analyzed."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema of the analyzed repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the ASTVisitor class to visit each file's AST.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ASTAnalyzer class depends on the ASTVisitor class.",
          "instantiated_by": "The ASTAnalyzer class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve file dependencies in a repository. It initializes with a filename and repository root, and provides methods to resolve relative imports and track import dependencies.",
        "init_method": {
          "description": "The constructor initializes the FileDependencyGraph with a filename and repository root. It sets up the filename and repository root as instance attributes.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to analyze."
            },
            {
              "name": "repo_root",
              "type": "object",
              "description": "The root directory of the repository."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "This method resolves relative imports of the form `from .. import name1, name2`. It returns a list of actual module/symbol names that exist, or raises an ImportError if none can be resolved.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The ImportFrom node to resolve."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls get_all_temp_files, init_exports_symbol, and module_file_exists to resolve the module names.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method visits an Import node and adds the imported module to the import dependencies.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "The Import node to visit."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "The base name of the module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method visits an ImportFrom node and resolves the imported module using _resolve_module_name. It then adds the imported module to the import dependencies.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The ImportFrom node to visit."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls _resolve_module_name to resolve the module names.",
                "called_by": "This method is not called by any other methods in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "module_file_exists",
            "description": {
              "overall": "This method checks if a module file exists at the given relative base path and name.",
              "parameters": [
                {
                  "name": "rel_base",
                  "type": "Path",
                  "description": "The relative base path."
                },
                {
                  "name": "name",
                  "type": "str",
                  "description": "The module name."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "init_exports_symbol",
            "description": {
              "overall": "This method checks if a symbol is exported in the __init__.py file at the given relative base path.",
              "parameters": [
                {
                  "name": "rel_base",
                  "type": "Path",
                  "description": "The relative base path."
                },
                {
                  "name": "symbol",
                  "type": "str",
                  "description": "The symbol to check."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on get_all_temp_files, init_exports_symbol, and module_file_exists to resolve module names and check for exports.",
          "instantiated_by": "The class is not instantiated by any other classes in the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class is designed to interact with Google Gemini for generating code snippet documentation. It centralizes API interaction, error handling, and validates I/O using Pydantic. The class provides methods to generate documentation for functions and classes in batches.",
        "init_method": {
          "description": "The constructor initializes the LLMHelper instance with API key, function and class prompt paths, model name, and base URL. It sets up the model configuration, batch size, and initializes the language model.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for Google Gemini."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "The path to the function system prompt file."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "The path to the class system prompt file."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use (default: 'gemini-2.0-flash-lite')."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the model (default: None)."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures the batch settings based on the model name. It sets the batch size for the model.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "The name of the model."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Generates and validates documentation for a batch of functions. It takes a list of FunctionAnalysisInput objects, creates JSON payloads, and uses the language model to generate documentation.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of FunctionAnalysisInput objects."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_functions",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of FunctionAnalysis objects or None if an error occurred."
                }
              ],
              "usage_context": {
                "calls": "The method calls the language model API in batches and waits for the responses.",
                "called_by": "This method is called by other parts of the system to generate documentation for functions."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Generates and validates documentation for a batch of classes. It takes a list of ClassAnalysisInput objects, creates JSON payloads, and uses the language model to generate documentation.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of ClassAnalysisInput objects."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_classes",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of ClassAnalysis objects or None if an error occurred."
                }
              ],
              "usage_context": {
                "calls": "The method calls the language model API in batches and waits for the responses.",
                "called_by": "This method is called by other parts of the system to generate documentation for classes."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on various external libraries and APIs, including Google Gemini, Pydantic, and Langchain.",
          "instantiated_by": "The class is instantiated by other parts of the system to generate documentation for functions and classes."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the primary interface for interacting with a Large Language Model (LLM). It initializes the LLM based on a provided API key, prompt file path, and model name, and offers methods to call the LLM and stream responses.",
        "init_method": {
          "description": "The constructor initializes the MainLLM instance by setting up the LLM based on the provided parameters. It checks for a valid API key, reads a system prompt from a file, and configures the LLM according to the specified model name.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for accessing the LLM."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the LLM model to use (defaults to 'gemini-2.5-pro')."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the LLM API (optional)."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "This method calls the LLM with a given user input and returns the response. It constructs a message with the system prompt and user input, invokes the LLM, and logs the outcome.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input provided by the user."
                }
              ],
              "returns": [
                {
                  "name": "response",
                  "type": "str",
                  "description": "The content of the LLM's response."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "This method streams the response from the LLM for a given user input. It constructs a message with the system prompt and user input, streams the LLM response, and yields the content of each chunk.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input provided by the user."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on external APIs for interacting with the LLM, such as the Google Generative AI API or OpenAI API.",
          "instantiated_by": "The class is instantiated by components that require interaction with an LLM, such as dialogue systems or content generation tools."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README, pyproject.toml, and requirements.txt. It initializes a structured information object and populates it by parsing the contents of these files.",
        "init_method": {
          "description": "The constructor initializes the class with a structured information object containing placeholders for project overview and installation information. It sets up default values for various project attributes.",
          "parameters": [
            {
              "name": "self",
              "type": "instance",
              "description": "Reference to the instance of the class"
            }
          ]
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from a given content string, which can occur due to encoding errors when reading files.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The content to be cleaned"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches for a file in a list of files that matches one of the given patterns in a case-insensitive manner.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "List of file patterns to search for"
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "List of files to search in"
                }
              ],
              "returns": [
                {
                  "name": "file",
                  "type": "Optional[Any]",
                  "description": "The found file or None if not found"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text under a Markdown heading (##) based on given keywords.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The Markdown content to search in"
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "Keywords to identify the section"
                }
              ],
              "returns": [
                {
                  "name": "section_text",
                  "type": "Optional[str]",
                  "description": "The extracted section text or None if not found"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file and extracts relevant project information such as title, description, key features, tech stack, and installation instructions.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file and extracts project information such as name, description, and dependencies.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file and extracts dependencies.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file"
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the extraction of project information from various files and returns a structured information object.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "List of files to extract information from"
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "URL of the repository"
                }
              ],
              "returns": [
                {
                  "name": "info",
                  "type": "Dict[str, Any]",
                  "description": "The extracted project information"
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the 'tomli' library for parsing pyproject.toml files.",
          "instantiated_by": "The class can be instantiated by any part of the system that needs to extract project information."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze the call structure of a given Python file. It utilizes the abstract syntax tree (AST) to traverse and understand the code's structure, identifying function definitions, class definitions, import statements, and call relationships.",
        "init_method": {
          "description": "The constructor of the CallGraph class initializes the object with a given filename. It sets up several instance variables to keep track of the current function, current class, local definitions, a graph to represent call relationships, import mappings, a set of functions, and edges in the call graph.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "This method recursively processes a given node in the AST to extract a list of name components as a dotted string, representing a call's callee in a hierarchical manner.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call | ast.Name | ast.Attribute",
                  "description": "The node in the AST to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "This method takes a list of callee nodes (lists of name steps) and resolves their names based on local definitions and import mappings.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists, where each sublist contains name steps."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved callee names."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "This method constructs a full name for a given basename and optional class name, prefixing them with the filename.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name to be used."
                },
                {
                  "name": "class_name",
                  "type": "str | None",
                  "description": "The class name if applicable."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The constructed full name."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "This method determines the current caller, which could be the current function or a representation of the global scope if no function is being processed.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The current caller."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method handles Import nodes in the AST, updating the import mapping with the names and aliases of imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method handles ImportFrom nodes in the AST, updating the import mapping with the names and aliases of imported modules from a specific module.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method handles ClassDef nodes in the AST, temporarily updating the current class during processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method handles FunctionDef nodes in the AST, updating local definitions, the graph, and the function set.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method handles AsyncFunctionDef nodes in the AST by delegating to visit_FunctionDef.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method handles Call nodes in the AST, resolving callees and updating the edges in the call graph.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The Call node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "This method handles If nodes in the AST, specifically checking for a common pattern related to the __name__ variable.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The If node to process."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on external modules such as ast and networkx for its operations.",
          "instantiated_by": "The class is instantiated with a filename to analyze the call graph of that file."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file in a Git repository. It provides lazy loading of the file content and offers various methods for analyzing and representing the file.",
        "init_method": {
          "description": "The constructor initializes the RepoFile object with a file path and a commit tree. It sets up the object's state by storing the file path and the commit tree, and initializes internal variables for lazy loading of the file's blob, content, and size.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The Tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "Lazy-loads the Git blob object associated with the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "Lazy-loads and returns the decoded content of the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "Lazy-loads and returns the size of the file in bytes.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "An example analysis method that counts the words in the file content.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The number of words in the file content."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Converts the RepoFile object to a dictionary representation.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include the file content in the dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "The dictionary representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Returns a useful string representation of the RepoFile object.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr",
                  "type": "str",
                  "description": "A string representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "",
          "instantiated_by": ""
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository, including cloning it into a temporary directory and providing RepoFile objects. It allows for listing all files in the repository and provides a file tree structure.",
        "init_method": {
          "description": "The class is initialized with a repository URL. It clones the repository into a temporary directory and sets up the repository object and its latest commit.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "string",
              "description": "The URL of the Git repository to be cloned."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "This method returns a list of all files in the repository as RepoFile objects. It achieves this by listing all files in the repository and creating RepoFile instances for each.",
              "parameters": [],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing all files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile class to create instances for each file in the repository.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "This method deletes the temporary directory and its contents.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": "This method is called by the __exit__ method and can be called directly to clean up."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "This method returns the instance of the class, allowing it to be used as a context manager.",
              "parameters": [],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": "This method is used implicitly when the class is used as a context manager."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "This method is called when exiting a context managed by the __enter__ method. It calls the close method to clean up.",
              "parameters": [
                {
                  "name": "exc_type",
                  "type": "exception type",
                  "description": "The type of exception, if any."
                },
                {
                  "name": "exc_val",
                  "type": "exception value",
                  "description": "The value of the exception, if any."
                },
                {
                  "name": "exc_tb",
                  "type": "exception traceback",
                  "description": "The traceback of the exception, if any."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the close method to ensure cleanup.",
                "called_by": "This method is called automatically when exiting a context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "This method returns a tree structure representing the files in the repository. If include_content is True, it includes the content of the files in the tree.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "boolean",
                  "description": "Whether to include the content of the files in the tree."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A dictionary representing the tree structure of the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the get_all_files method if necessary.",
                "called_by": "This method can be called directly to obtain the file tree."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the RepoFile class from the backend.getRepo module.",
          "instantiated_by": "The class is not instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze a project by traversing its directory structure, identifying Python files, and resolving function and method calls within those files. It constructs a call graph that represents the relationships between different parts of the project.",
        "init_method": {
          "description": "The constructor initializes the ProjectAnalyzer with a project root directory. It sets up instance attributes such as the project root path, definitions, call graph, file ASTs, and directories to ignore.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "This method orchestrates the analysis of the project by finding Python files, collecting definitions, resolving calls, and returning the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "dict",
                  "description": "A dictionary representing the call graph of the project."
                }
              ],
              "usage_context": {
                "calls": "This method calls _find_py_files, _collect_definitions, and _resolve_calls to perform the analysis.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "This method processes the call graph to extract raw relationships between callers and callees, organizing them into outgoing and incoming relationship sets.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing outgoing and incoming relationship sets."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "This method traverses the project directory structure to find all Python files, excluding directories that should be ignored.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list",
                  "description": "A list of paths to Python files in the project."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "This method reads Python files, parses their ASTs, and collects definitions of functions, methods, and classes.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls path_to_module to convert the file path to a module path.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "This method traverses the AST to find the parent node of a given node, useful for determining if a function is a method of a class.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.Tree",
                  "description": "The AST being traversed."
                },
                {
                  "name": "node",
                  "type": "ast.Node",
                  "description": "The node whose parent is being sought."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.Node",
                  "description": "The parent node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the _collect_definitions method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "This method uses the CallResolverVisitor to resolve function and method calls within a file and updates the call graph.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file being processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls CallResolverVisitor to perform the call resolution.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ProjectAnalyzer depends on CallResolverVisitor and path_to_module for its operations.",
          "instantiated_by": "The class is not instantiated by any part of the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python code and resolve function calls, tracking the call relationships and context.",
        "init_method": {
          "description": "The constructor initializes the visitor with a filepath, project root, and definitions. It sets up the module path, scope, instance types, and other contextual information.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The file path of the module being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary of definitions used to resolve function calls."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Visits a class definition node in the AST, updating the current class name and recursively visiting child nodes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The class definition node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Visits a function definition node, updating the current caller name and recursively visiting child nodes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The function definition node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Visits a function call node, resolving the callee's pathname and recording caller information if the callee is defined.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The function call node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Visits an import node, updating the scope with imported names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The import node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Visits an import from node, updating the scope with imported names and their full module paths.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The import from node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Visits an assignment node, tracking instance types if the assigned value is a class instantiation.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The assignment node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the full pathname of a function call node.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.Name or ast.Attribute",
                  "description": "The function node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the backend.relationship_analyzer.path_to_module function.",
          "instantiated_by": "The class is not instantiated by any known part of the system."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic model designed to describe a single parameter of a function. It captures essential information about the parameter, including its name, type, and description. This class serves as a data structure for documenting function parameters in a structured and standardized way.",
        "init_method": {
          "description": "The class is initialized with parameters for name, type, and description. These parameters are used to create an instance of ParameterDescription, which can then be used to document or describe function parameters.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the parameter."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model designed to describe the return value of a function. It encapsulates three key attributes: name, type, and description of the return value.",
        "init_method": {
          "description": "The class is initialized with parameters for name, type, and description, which are used to create an instance of ReturnDescription.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model that describes the calling context of a function. It captures information about the functions or methods that a particular function calls and is called by. This class seems to be part of a larger system for documenting or analyzing function usage and dependencies.",
        "init_method": {
          "description": "The class is initialized with two string attributes: 'calls' and 'called_by'. These attributes likely represent the functions or methods that the described function calls and is called by, respectively.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "The functions or methods called by the described function."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "The functions or methods that call the described function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information provided about where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to contain detailed analysis of a function's purpose and signature. It captures the overall description, parameters, return values, and usage context of a function.",
        "init_method": {
          "description": "The class is initialized with an overall description, parameters, returns, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "The overall description of the function."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the function."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects detailing the return values of the function."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "An object providing context about where and how the function is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class is a Pydantic model designed to represent the JSON schema for a function. It encapsulates key information about a function, including its identifier, description, and any potential errors. This model serves as a structured data representation for function analysis, enabling consistent and reliable data handling within the system.",
        "init_method": {
          "description": "The class is initialized with an identifier, description, and an optional error field. The identifier is a string representing the function's name, and the description is an instance of FunctionDescription, which provides a detailed description of the function.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The name or identifier of the function."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "A detailed description of the function."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional field to store any errors related to the function analysis. Defaults to None."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model that describes the __init__ method of a class. It contains two main fields: description and parameters. The description field provides a summary of the constructor's purpose, while the parameters field lists the parameters accepted by the constructor, along with their types and descriptions.",
        "init_method": {
          "description": "The class is initialized with two parameters: description and parameters. The description parameter is a string that summarizes the purpose of the constructor, while the parameters field is a list of ParameterDescription objects that detail each parameter of the constructor.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A string describing the purpose of the constructor."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects that describe each parameter of the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model that describes the external dependencies and primary points of instantiation for a given class. It has two main attributes: dependencies and instantiated_by, both of which are strings. This class seems to be part of a larger system for tracking and managing class dependencies and usage contexts.",
        "init_method": {
          "description": "The class is initialized with two string attributes: dependencies and instantiated_by. These attributes are defined directly in the class definition and do not require any specific setup in the constructor.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string representing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string indicating where the class is instantiated."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to hold a comprehensive analysis of a class, including its purpose, constructor details, and a list of its methods.",
        "init_method": {
          "description": "The constructor initializes a ClassDescription object with four main attributes: overall, init_method, methods, and usage_context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose of the class."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object containing details about the class constructor."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects, each describing a method of the class."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing context about how the class is used."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information on where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as a structured model to represent a comprehensive analysis of a given Python class. It encapsulates essential information such as an identifier, a detailed description, and an optional error field.",
        "init_method": {
          "description": "The constructor of ClassAnalysis initializes the object with an identifier, description, and an optional error message. It sets up the state of the object with the provided parameters.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique identifier for the class analysis."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "A detailed description of the class analysis."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional field to store any error messages encountered during analysis. Defaults to None."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other part of the system."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer. It is used in 'called_by' and 'instantiated_by' lists to provide detailed information about the call, including the file, function, mode, and line number.",
        "init_method": {
          "description": "The class is initialized with parameters for file, function, mode, and line. These parameters are used to set up the instance attributes.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file where the call event occurs."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that makes the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, e.g., 'method', 'function', 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number where the call event occurs."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to hold structured context for analyzing a function. It captures information about the functions or methods called by the function being analyzed, as well as the functions or methods that call it. This model serves as a data structure to provide comprehensive context for static or dynamic analysis of functions within a software system.",
        "init_method": {
          "description": "The class is initialized with two optional parameters: calls and called_by. The calls parameter is a list of strings representing the names of functions or methods called by the function being analyzed. The called_by parameter is a list of CallInfo objects representing the functions or methods that call the function being analyzed.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the names of functions or methods called by the function being analyzed."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions or methods that call the function being analyzed."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "There is no information provided about where this class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class is a Pydantic model designed to serve as input for generating a FunctionAnalysis object. It specifies the required structure for providing source code and contextual information about a function, ensuring that the necessary details are captured for analysis.",
        "init_method": {
          "description": "The class is initialized with parameters that define the input for function analysis, including mode, identifier, source code, imports, and context.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "Specifies the mode of analysis, which must be 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the function."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the function's source code."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "Contextual information about the function, such as dependencies and usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any part of the system."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to hold structured context information for methods in a class. It encapsulates details such as the method identifier, calls made by the method, the methods or functions that call it, argument names, and an optional docstring.",
        "init_method": {
          "description": "The class is initialized with parameters for identifier, calls, called_by, args, and docstring. These parameters are used to set up the instance attributes.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The name of the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of methods or functions called by this method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of methods or functions that call this method."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of argument names for the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "An optional docstring for the method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to hold structured context for analyzing a class. It encapsulates information about dependencies, instantiation locations, and method contexts.",
        "init_method": {
          "description": "The constructor initializes a ClassContextInput object with dependencies, instantiated_by, and method_context.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of dependencies for the class."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of call information where the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of method context inputs for the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on external types such as CallInfo and MethodContextInput.",
          "instantiated_by": "This class is not instantiated by any known locations."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class is a Pydantic model designed to serve as input for generating a ClassAnalysis object. It encapsulates essential information about a class, including its source code, identifier, and contextual dependencies. This model ensures that the input provided for class analysis is structured and valid.",
        "init_method": {
          "description": "The constructor of ClassAnalysisInput initializes an instance with the required parameters: mode, identifier, source_code, imports, and context. It sets up the instance attributes necessary for class analysis.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "Specifies the mode of analysis, which must be 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The name or identifier of the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class definition."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the class."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "Contextual information about the class, including dependencies and instantiation details."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies listed.",
          "instantiated_by": "There is no information provided on where this class is instantiated."
        }
      },
      "error": null
    }
  }
}