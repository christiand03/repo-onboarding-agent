{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function first attempts to calculate the relative path of the file with respect to the project root. If this fails, it falls back to using the file's basename. The function then removes any '.py' extension from the relative path and replaces path separators with dots to form the module path. If the resulting module path ends with '.__init__', this suffix is removed before the module path is returned.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The path to the file to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The module path corresponding to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "The `build_file_dependency_graph` function constructs a directed graph representing file dependencies within a given repository. It utilizes the `networkx` library to create a DiGraph and the `ast` module to parse the abstract syntax tree (AST) of the provided file. The function iterates over the import dependencies extracted by the `FileDependencyGraph` visitor and adds nodes and edges to the graph accordingly. The resulting graph is then returned.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file for which the dependency graph is being constructed."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree (AST) of the provided file."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.FileDependencyGraph.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "The `build_repository_graph` function constructs a directed graph representing the dependencies between files in a Git repository. It iterates over all Python files in the repository, parsing each file's abstract syntax tree (AST) to identify import relationships. These relationships are then added to a global graph, which is returned as a NetworkX DiGraph object. The function relies on the `build_file_dependency_graph` function to analyze individual files and the `GitRepository` class to access repository contents. The resulting graph can be used to visualize and analyze the dependencies between files in the repository.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "A `GitRepository` object representing the repository to analyze."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the dependencies between files in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.File_Dependency.build_file_dependency_graph`.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "The `get_all_temp_files` function retrieves a list of all Python files within a specified directory and its subdirectories. It takes a `directory` path as input, resolves it to an absolute path, and then uses a recursive glob pattern to find all files with the `.py` extension. The function returns a list of `Path` objects representing the relative paths of these files to the specified directory. This function appears to be part of a larger system for analyzing or processing Python files within a directory structure.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory in which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[pathlib.Path]",
            "description": "A list of `Path` objects representing the relative paths of all Python files found within the specified directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function appears to be a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analyses for the 'add_item', 'check_stock', and 'generate_report' functions. The function then creates a ClassAnalysisInput object for the InventoryManager class, which includes the source code and context for the class. Finally, it uses the LLMHelper class to generate documentation for the functions and classes.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, and schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The `make_safe_dot` function generates a safe representation of a directed graph and writes it to a file in DOT format. It takes a `networkx` DiGraph object and an output file path as input. The function creates a copy of the input graph, relabels its nodes to ensure they are safe for DOT format, and then writes the modified graph to the specified output file. This process involves creating a mapping of original node names to safe node names, relabeling the nodes in the graph copy, and assigning the original node names as labels to the safe nodes. The function utilizes the `networkx` library for graph manipulation and the `nx_pydot` module for writing the graph to a DOT file.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input directed graph to be made safe for DOT format."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the safe graph will be written in DOT format."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The `build_filtered_callgraph` function constructs a global call graph and filters it to include only self-written functions. It takes a `GitRepository` object as input, iterates over all Python files in the repository, and uses the `ast` module to parse the file contents. The function then builds a directed graph using `networkx` and returns the filtered call graph. The filtering process involves identifying the functions defined in each file and only including edges between functions that are part of the self-written codebase. The function ultimately returns a `nx.DiGraph` object representing the filtered call graph.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "A `GitRepository` object representing the repository to analyze."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the filtered call graph of self-written functions."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.callgraph.CallGraph`. ",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The `wrap_cdata` function is designed to wrap a given content in CDATA tags. This is typically used in XML to prevent the content from being parsed as XML. The function takes a single parameter, `content`, which is the string to be wrapped. It returns the wrapped content as a string. The function does not perform any error checking on the input content. The purpose of this function is to ensure that the content is treated as literal characters within an XML document.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The extract_output_content function is designed to extract text and handle images from a list of outputs. It iterates through each output, checking its type and content, and processes images by decoding Base64 to bytes. The function returns a list of text strings or placeholders for images. It handles different output types, including display data, execute results, streams, and errors, and extracts relevant information from each. The function also utilizes a helper function, process_image, to handle image processing. This function is part of the backend.converter module and relies on imports such as logging, nbformat, and base64 for its operations.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of output objects to be processed."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list to store image data."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of text strings or placeholders for images."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The `process_image` function processes an image based on its MIME type. It checks if the provided MIME type exists in the `data` dictionary and attempts to decode the corresponding base64-encoded string. If successful, it appends the image data to the `image_list` and returns a placeholder string for the image. If an error occurs during decoding, it returns an error message. If the MIME type is not found in the `data` dictionary, the function returns `None`.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "success",
            "type": "str",
            "description": "A placeholder string for the image if processing is successful."
          },
          {
            "name": "error",
            "type": "str",
            "description": "An error message if decoding fails."
          },
          {
            "name": "not_found",
            "type": "NoneType",
            "description": "None if the MIME type is not found in the data dictionary."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The convert_notebook_to_xml function takes a file content as input, attempts to parse it as a Jupyter Notebook, and converts it into an XML representation. If the parsing fails, it returns an error message. The function iterates over each cell in the notebook, converting markdown cells into XML and code cells into XML with their source code wrapped in CDATA. If a code cell has outputs, the function extracts the output content, wraps it in CDATA, and appends it as an XML cell. The function returns the XML representation of the notebook and a list of extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the Jupyter Notebook file to be converted."
          }
        ],
        "returns": [
          {
            "name": "xml_representation",
            "type": "str",
            "description": "The XML representation of the Jupyter Notebook."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted images from the notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.extract_output_content and backend.converter.wrap_cdata.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "The `process_repo_notebooks` function processes a list of repository files, filters out non-notebook files, and converts the notebook files to XML format. It logs the number of notebooks found and the processing of each notebook. The function returns a dictionary containing the XML output and images for each notebook. The conversion of notebooks to XML is handled by the `convert_notebook_to_xml` function. This function appears to be part of a larger system for processing and converting notebooks, likely for data analysis or documentation purposes. The logging statements suggest that the function is designed to provide feedback on its progress.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of repository files to be processed."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary containing the XML output and images for each notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The `create_savings_chart` function generates a bar chart comparing JSON and TOON tokens and saves it to a specified output path. It takes four parameters: `json_tokens`, `toon_tokens`, `savings_percent`, and `output_path`. The function uses matplotlib to create the chart, customizing its appearance with labels, colors, and a title that includes the savings percentage. The chart displays the number of tokens for each format, with values shown above the bars. Finally, the function saves the chart to the specified output path and closes the plot.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage of savings."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The `calculate_net_time` function calculates the net time spent on a task, excluding sleep times due to rate limits. It takes into account the start and end times, total items, batch size, and model name. If the model name does not start with 'gemini-', it returns the total duration. Otherwise, it calculates the number of batches, sleep count, and total sleep time, then subtracts the total sleep time from the total duration to get the net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float",
            "description": "The start time of the task."
          },
          {
            "name": "end_time",
            "type": "float",
            "description": "The end time of the task."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items being processed."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The size of each batch."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float",
            "description": "The net time spent on the task, excluding sleep times due to rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is a central component of the backend system, responsible for orchestrating the analysis of a given input. It begins by updating the status and then proceeds to extract the repository URL from the input. The function then clones the repository, extracts basic project information, constructs a file tree, and analyzes relationships within the project. It utilizes various helper functions and classes, such as the LLMHelper and MainLLM, to generate documentation and a final report. The function also estimates token savings and creates a savings chart if necessary.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input string to be analyzed."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary containing model names for the helper and main LLMs."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function for updating the status."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated by the MainLLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics such as helper time, main time, and token savings."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, and schemas.types.MethodContextInput.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The update_status function updates the status by calling the status_callback function with the provided message if it exists, and logs the message at the info level. The function takes a single parameter, msg, which is the message to be updated. The function does not return any value. It relies on the status_callback function and the logging module to perform its operations. The function's purpose is to notify about the current status. It is a simple function with a clear and specific task.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be updated."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The notebook_workflow function is a complex workflow that analyzes input data, clones a repository, extracts basic project information, and generates reports using a large language model (LLM). It takes in several parameters, including input data, API keys, a model name, and an optional status callback function. The function performs various tasks, such as URL extraction, repository cloning, and report generation, and returns a dictionary containing the final report and metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "str",
            "description": "The input data to be analyzed."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for different models."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the model to be used for report generation."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to update the status of the workflow."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated by the workflow."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics about the workflow, such as execution time and model usage."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, and backend.main.update_status.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The `gemini_payload` function generates a payload content list by processing the provided `basic_info`, `nb_path`, `xml_content`, and `images`. It first creates an intro JSON string containing the basic information and current notebook path. Then, it iterates over the XML content to find image placeholders, extracts the corresponding text segments, and appends them to the payload content list along with the image data. Finally, it returns the payload content list.",
        "parameters": [
          {
            "name": "basic_info",
            "type": "dict",
            "description": "A dictionary containing basic information about the notebook."
          },
          {
            "name": "nb_path",
            "type": "str",
            "description": "The path to the current notebook."
          },
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML content of the notebook."
          },
          {
            "name": "images",
            "type": "list",
            "description": "A list of image data, where each image is a dictionary containing the image data and other metadata."
          }
        ],
        "returns": [
          {
            "name": "payload_content",
            "type": "list",
            "description": "A list of payload content items, where each item is a dictionary containing the type and content of the item."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function attempts to calculate the relative path from the project root to the file. If this fails, it falls back to using the file's basename. The function then removes any '.py' extension, replaces path separators with dots, and removes any '__init__' suffix before returning the resulting module path.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The path to the file to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The converted module path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The `encrypt_text` function is designed to encrypt a given text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available. If either condition is true, it returns the original text. Otherwise, it encrypts the text using the cipher suite, strips any leading or trailing whitespace, encodes the text to bytes, and then decodes the encrypted bytes back to a string. The function returns the encrypted text as a string.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The `decrypt_text` function is designed to decrypt a given text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available. If either condition is true, it returns the original text. Otherwise, it attempts to decrypt the text using the cipher suite and returns the decrypted text. If an exception occurs during decryption, it catches the exception and returns the original text. The function is intended to handle text decryption securely, utilizing the cryptography library's Fernet symmetric encryption algorithm.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text if successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The `insert_user` function creates a new user document in the database. It takes in three parameters: `username`, `name`, and `password`. The function hashes the provided password using `stauth.Hasher.hash` and constructs a user dictionary with the provided information. The user dictionary is then inserted into the database using `dbusers.insert_one`, and the function returns the inserted ID of the newly created user document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique username for the new user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the new user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password for the new user, which will be hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "The `fetch_all_users` function retrieves all users from a database. It utilizes the `dbusers.find()` method to fetch all user documents and returns them as a list. The function does not take any parameters and does not include any error handling. The database connection is assumed to be established prior to calling this function. The function's purpose is to provide a simple way to retrieve all user data from the database.",
        "parameters": [],
        "returns": [
          {
            "name": "users",
            "type": "list",
            "description": "A list of all user documents in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The `fetch_user` function retrieves a user document from a database based on the provided `username`. It uses the `dbusers.find_one` method to query the database. The function takes a single parameter, `username`, which is expected to be a string. The function returns the user document if found, or `None` if no matching document exists. The database connection and `dbusers` collection are assumed to be established elsewhere in the codebase. The function does not perform any error handling or validation on the input `username`. The function's purpose is to provide a simple way to retrieve user data from the database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to retrieve from the database."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict",
            "description": "The user document retrieved from the database, or `None` if no matching document exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "The `update_user_name` function updates the name of a user in the database. It takes two parameters: `username` and `new_name`, both of which are strings. The function uses the `update_one` method of the `dbusers` collection to update the `name` field of the document with the matching `_id` (username). The function returns the number of documents modified, which should be 1 if the update is successful. The function does not handle any potential errors that may occur during the update process.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The current username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "The `update_gemini_key` function updates a user's Gemini API key in the database. It takes two parameters: `username` and `gemini_api_key`. The function first encrypts the provided API key using the `encrypt_text` function. Then, it uses the `update_one` method of the `dbusers` collection to update the user's document with the encrypted API key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "The `update_gpt_key` function updates a user's GPT API key in the database. It takes two parameters: `username` and `gpt_api_key`. The function first encrypts the provided GPT API key using the `encrypt_text` function. Then, it uses the `update_one` method of the `dbusers` collection to update the user's document with the encrypted key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose GPT API key is to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "The `update_ollama_url` function updates the `ollama_base_url` field for a user in the database. It takes two parameters: `username` and `ollama_base_url`. The function uses the `dbusers.update_one` method to update the user's document in the database. The `ollama_base_url` parameter is stripped of leading and trailing whitespace before being updated. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to update"
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new ollama base URL to update for the user"
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "The `update_opensrc_key` function updates the Open Source API key for a given user in the database. It takes two parameters: `username` and `opensrc_api_key`. The function first encrypts the provided API key using the `encrypt_text` function, then updates the user's document in the database with the encrypted key. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The new Open Source API key to be updated for the given user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "The `update_opensrc_url` function updates the `opensrc_base_url` field for a user in the database. It takes two parameters: `username` and `opensrc_base_url`. The function uses the `dbusers.update_one` method to update the user's document in the database. The `opensrc_base_url` parameter is stripped of leading and trailing whitespace before being updated. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to update"
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new opensrc base URL to update for the user"
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The `fetch_gemini_key` function retrieves a Gemini API key associated with a given username from a database. It uses the `dbusers` collection and filters the result to only include the `gemini_api_key` field. If a user with the provided username is found, the function returns their Gemini API key; otherwise, it returns `None`. The function takes a single parameter, `username`, which is expected to be a string. This function appears to be part of a larger system that manages user data and API keys. It does not handle any exceptions that might occur during database operations.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str or None",
            "description": "The Gemini API key associated with the provided username, or `None` if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The `fetch_ollama_url` function retrieves the Ollama base URL for a given username from a MongoDB database. It uses the `dbusers` collection and queries for a document with the specified username. If a matching document is found, it returns the `ollama_base_url` field; otherwise, it returns `None`. This function appears to be part of a larger system that interacts with a database to manage user data. The function's implementation is straightforward, relying on MongoDB's query capabilities to fetch the desired data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the Ollama base URL."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the given username, or `None` if no matching document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The `fetch_gpt_key` function retrieves the GPT API key associated with a given username from the database. It uses the `dbusers` collection to find a document with the specified username and returns the `gpt_api_key` field if found. If no document is found, the function returns `None`. The function takes a single parameter, `username`, which is expected to be a string. The function's purpose is to provide a way to retrieve the GPT API key for a specific user.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to retrieve the GPT API key for."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the given username, or `None` if no document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "The `fetch_opensrc_key` function retrieves the Open Source API key associated with a given username from the database. It uses the `dbusers` collection and filters the result to only include the `opensrc_api_key` field. If a user with the provided username is found, the function returns their Open Source API key; otherwise, it returns `None`. This function appears to be part of a larger system that manages user data and API keys. The function's implementation is straightforward, relying on the `find_one` method of the `dbusers` collection to retrieve the user data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The Open Source API key associated with the provided username, or `None` if no user with that username is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "The `fetch_opensrc_url` function retrieves the open source base URL associated with a given username from a database. It uses the `dbusers` collection to find a document with the specified username and returns the `opensrc_base_url` field if found. If no document is found, the function returns `None`. The function takes a single parameter, `username`, which is expected to be a string. The function's purpose is to provide a way to fetch the open source base URL for a given user. It is designed to be used in a context where the username is known and the corresponding open source base URL needs to be retrieved.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the open source base URL"
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str or None",
            "description": "The open source base URL associated with the given username, or `None` if no document is found"
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The `delete_user` function deletes a user from the database based on their username. It utilizes the `dbusers.delete_one` method to remove the user document from the collection. The function returns the number of documents deleted, which should be 1 if the user exists and 0 otherwise. This function appears to be part of a larger database management system, likely using MongoDB as the database. The function's implementation is straightforward, relying on the `delete_one` method to handle the deletion logic.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, which should be 1 if the user exists and 0 otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "The get_decrypted_api_keys function retrieves a user's decrypted API keys and base URLs from the database. It takes a username as input and returns the decrypted API keys for Gemini, Ollama, GPT, and OpenSrc, as well as the OpenSrc base URL. If the user is not found in the database, the function returns None for all values. The function uses the decrypt_text function to decrypt the API keys.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSrc API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSrc base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The `insert_chat` function creates a new chat entry in the database. It takes two parameters, `username` and `chat_name`, and uses them to construct a chat document. The function then inserts this document into the database using `dbchats.insert_one` and returns the inserted ID. The chat document includes a unique ID generated by `uuid.uuid4`, the provided username and chat name, and a timestamp for when the chat was created. This function appears to be part of a larger system for managing chat data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted chat document."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "The `fetch_chats_by_user` function retrieves all defined chats for a given user. It takes a `username` as input, queries the database to find chats associated with this user, sorts the results by creation time in ascending order, and returns the list of chats. The function utilizes the `dbchats` collection and relies on the `pymongo` library for database interactions. The sorting is done based on the `created_at` field, which implies that the chats are ordered from oldest to newest. This function is designed to provide a user's chat history in a chronological manner.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chats associated with the given username, sorted by creation time in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "The `check_chat_exists` function checks if a chat exists in the database for a given username and chat name. It uses the `dbchats.find_one` method to query the database and returns `True` if a matching document is found, and `False` otherwise. The function takes two parameters: `username` and `chat_name`, both of which are strings. The function's purpose is to verify the existence of a chat in the database. It does not create or modify any data in the database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who owns the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "existence",
            "type": "bool",
            "description": "A boolean indicating whether the chat exists in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "The `rename_chat_fully` function renames a chat and all associated exchanges for a given user. It takes three parameters: `username`, `old_name`, and `new_name`. The function first updates the chat entry in the database using the `dbchats.update_one` method, and then updates all messages (exchanges) associated with the chat using the `dbexchanges.update_many` method. The function returns the number of modified documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose chat is being renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name for the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The `insert_exchange` function is designed to insert a new exchange record into a database. It takes in various parameters such as question, answer, feedback, username, and chat name, along with optional parameters like helper used, main used, and time metrics. The function generates a unique ID for the new record and attempts to insert it into the database. If successful, it returns the new ID; otherwise, it catches any exceptions, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in the exchange."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback related to the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat where the exchange occurred."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "Optional parameter indicating if a helper was used, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "Optional parameter indicating if the main system was used, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Optional parameter for the total time taken, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Optional parameter for the time taken by the helper, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Optional parameter for the time taken by the main system, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Optional parameter for JSON tokens, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Optional parameter for Toon tokens, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Optional parameter for savings percentage, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique ID of the newly inserted exchange record, or None if the insertion fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "The `fetch_exchanges_by_user` function retrieves a list of exchanges associated with a given username from the database. It uses the `dbexchanges` collection and filters the results by the `username` field. The function sorts the exchanges in ascending order based on their `created_at` timestamp. The sorted list of exchanges is then returned by the function. This function appears to be part of a larger system that utilizes a MongoDB database, as indicated by the use of `pymongo`. The function's purpose is to fetch specific data from the database, suggesting its use in a data retrieval or display context.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to fetch exchanges."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the given username, sorted by their creation timestamp."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "The `fetch_exchanges_by_chat` function retrieves a list of exchanges from the database that are associated with a specific username and chat name. It uses the `dbexchanges` collection and filters the results based on the provided `username` and `chat_name`. The results are sorted in ascending order by the `created_at` field. The function returns a list of exchanges that match the specified criteria.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchanges by."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The chat name to filter exchanges by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges that match the specified username and chat name, sorted in ascending order by creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "The update_exchange_feedback function updates the feedback of a specific exchange in the database. It takes two parameters: exchange_id and feedback. The function uses the dbexchanges collection to update the feedback field of the document with the matching _id. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "ObjectId",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The new feedback value to be updated."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "The `update_exchange_feedback_message` function updates the feedback message for a specific exchange in the database. It takes two parameters: `exchange_id` and `feedback_message`. The function uses the `dbexchanges` collection to update the document with the matching `_id` field. The update operation sets the `feedback_message` field to the provided value. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "unknown",
            "description": "The ID of the exchange to update."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to set for the exchange."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "The `delete_exchange_by_id` function deletes a document from a MongoDB database based on the provided `exchange_id`. It utilizes the `dbexchanges` collection and returns the number of documents deleted. The function takes a single parameter, `exchange_id`, which is expected to be a string. The deletion operation is performed using the `delete_one` method, which removes the first document that matches the specified filter. The function returns the `deleted_count` attribute of the result, indicating the number of documents deleted.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The ID of the exchange to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The `delete_full_chat` function deletes a specified chat and all associated exchanges from the database. It ensures consistency between the frontend and backend by removing all relevant data. The function takes two parameters, `username` and `chat_name`, and returns the number of chats deleted. It first deletes all exchanges associated with the chat, then removes the chat itself from the chat list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user who owns the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of chats deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The clean_names function takes a list of model names as input and returns a new list with each name cleaned by splitting the string at the '/' character and keeping only the last part. This function appears to be designed to extract the final component of a path or identifier. It does not perform any error checking or handling on the input list or its elements. The function is implemented using a list comprehension for concise and efficient processing.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list",
            "description": "A list of model names that need to be cleaned."
          }
        ],
        "returns": [
          {
            "name": "cleaned_model_list",
            "type": "list",
            "description": "A list of cleaned model names where each name is the last part of the original name split by '/'."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The `get_filtered_models` function filters a list of models based on a selected category. It uses a predefined set of category keywords to determine which models to include in the filtered list. If the category is 'STANDARD', it returns only models that are also in the standard list. Otherwise, it checks each model's name for any of the category's keywords and includes it in the filtered list if a match is found. If no models match the category's keywords, the function returns the original list.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered_list",
            "type": "list",
            "description": "The filtered list of models."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "The `save_gemini_cb` function is designed to save a Gemini key to the database. It retrieves the new key from the session state, checks if it exists, and if so, updates the Gemini key in the database for the current user. After updating, it clears the session state and displays a success toast message. The function appears to be part of a Streamlit application, utilizing session state and toast notifications. It relies on the `database.db` module to interact with the database. The function does not take any parameters and does not return any values.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "The `save_ollama_cb` function is designed to save a new Ollama URL to the database. It retrieves the new URL from the session state and checks if it is not empty. If the URL is valid, it updates the Ollama URL in the database using the `database.db.update_ollama_url` function and displays a success toast message. The function appears to be part of a Streamlit application, utilizing session state and toast notifications. It does not take any parameters and does not return any values. The function's primary purpose is to persist the Ollama URL for a given user.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The `load_data_from_db` function is responsible for loading chat and exchange data from the database for a given username. It checks if the data has already been loaded for the current user and, if not, initializes the session state with the loaded data. The function first loads the defined chats, then the exchanges, and finally creates a default chat if no data exists. It also sets the active chat and updates the session state accordingly.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load the data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "The `handle_feedback_change` function updates the feedback value for a given exchange in the database and triggers a rerun of the Streamlit application. It takes two parameters, `ex` and `val`, where `ex` is expected to be a dictionary containing the exchange data and `val` is the new feedback value. The function modifies the `ex` dictionary by updating the 'feedback' key with the provided `val`. It then calls the `update_exchange_feedback` function from the `database.db` module to persist this change in the database. Finally, it invokes `st.rerun()` to refresh the application's state.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data, including an '_id' key for database reference."
          },
          {
            "name": "val",
            "type": "str",
            "description": "The new feedback value to be updated for the exchange."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "The `handle_delete_exchange` function is responsible for deleting an exchange from the database and updating the session state. It takes two parameters: `chat_name` and `ex`, where `ex` is expected to be a dictionary containing an `_id` key. The function first deletes the exchange from the database using the `delete_exchange_by_id` function from the `database.db` module. Then, it checks if the `chat_name` exists in the session state and if the exchange is present in the list of exchanges for that chat. If both conditions are met, it removes the exchange from the list. Finally, it triggers a re-run of the Streamlit application using `st.rerun()`.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is being deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing information about the exchange to be deleted, including its `_id`."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The `handle_delete_chat` function is responsible for deleting a specified chat for a given user. It first removes the chat from the database using `db.delete_full_chat`, then cleans up the session state by removing the chat from `st.session_state.chats`. If there are remaining chats, it sets the active chat to the first one in the list. If all chats are deleted, it creates a new empty chat and sets it as the active chat. Finally, it triggers a rerun of the Streamlit application using `st.rerun()`.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose chat is being deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_full_chat and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The `extract_repo_name` function takes a text input, searches for a URL, and attempts to extract the repository name from the URL's path. It uses regular expressions to find the URL and the `urlparse` function to parse the URL. If a repository name is found, it is returned; otherwise, the function returns `None`. The function appears to handle cases where the repository name ends with '.git' by removing this suffix. The purpose of this function seems to be to extract repository names from text inputs that may contain URLs.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to search for a URL and extract the repository name from."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name, or `None` if no repository name could be found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The `stream_text_generator` function is a generator that splits a given text into individual words and yields each word with a trailing space. It introduces a delay of 0.01 seconds between each word using `time.sleep(0.01)`. This function appears to be designed for streaming text, possibly in a frontend application, to create a typewriter-like effect. The function does not handle any exceptions that might occur during its execution. It relies on the `time` module for the delay and does not utilize any of the other imported modules directly within its code.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be split into words and streamed."
          }
        ],
        "returns": [
          {
            "name": "word",
            "type": "str",
            "description": "Each word from the input text followed by a space, yielded one at a time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The `render_text_with_mermaid` function is designed to render markdown text that may contain mermaid diagrams. It splits the input text into parts based on mermaid code blocks and then processes each part accordingly. If a part is a mermaid diagram, it attempts to render it using the `st_mermaid` function. If rendering fails, it falls back to displaying the mermaid code as plain text. The function also supports streaming the rendered text if the `should_stream` parameter is set to `True`.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The markdown text to be rendered, which may contain mermaid diagrams."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether the rendered text should be streamed or not. Defaults to `False`."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function is responsible for rendering an exchange in a chat interface. It takes two parameters: `ex` and `current_chat_name`. The function displays the question and answer in the chat, along with various buttons for feedback, commenting, downloading, and deleting the exchange. If an error occurs, it displays an error message with a delete button. The function uses Streamlit to create the UI and interacts with a database to update feedback messages and delete exchanges.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing information about the exchange, including the question, answer, and feedback."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse and analyze the Abstract Syntax Tree (AST) of Python source code. It inherits from ast.NodeVisitor and provides methods to visit different types of nodes in the AST, such as imports, classes, and functions. The class maintains a schema that stores information about the imports, classes, and functions encountered during the traversal.",
        "init_method": {
          "description": "The __init__ method initializes the ASTVisitor instance with the source code, file path, and project root. It sets up the schema and module path, and calls the path_to_module function to resolve the module path.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code to be analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The file path of the source code."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The project root directory."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "The visit_Import method is called when an import statement is encountered in the AST. It extracts the import names and adds them to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The import node in the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when an import statement is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "The visit_ImportFrom method is called when an import from statement is encountered in the AST. It extracts the import names and adds them to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The import from node in the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when an import from statement is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "The visit_ClassDef method is called when a class definition is encountered in the AST. It extracts the class information and adds it to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The class definition node in the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when a class definition is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "The visit_FunctionDef method is called when a function definition is encountered in the AST. It extracts the function information and adds it to the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The function definition node in the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the ast.NodeVisitor when a function definition is encountered."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "The visit_AsyncFunctionDef method is called when an asynchronous function definition is encountered in the AST. It delegates the processing to the visit_FunctionDef method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The asynchronous function definition node in the AST."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the visit_FunctionDef method.",
                "called_by": "This method is called by the ast.NodeVisitor when an asynchronous function definition is encountered."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ASTVisitor class depends on the path_to_module function from the backend.AST_Schema module.",
          "instantiated_by": "The ASTVisitor class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing the abstract syntax tree (AST) of Python files in a repository. It provides methods to merge relationship data and analyze a repository, allowing for the extraction of information about functions, classes, and their dependencies. The class utilizes the ASTVisitor class to parse the AST of individual files and construct a schema representing the repository's structure.",
        "init_method": {
          "description": "The constructor of the ASTAnalyzer class does not perform any initialization, as it does not have any parameters or attribute assignments.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method merges relationship data into the full schema of a repository. It takes a full schema and raw relationships as input, and returns the updated full schema. The method iterates over the files in the schema, updating the context of functions and classes with information about outgoing and incoming calls.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The full schema of the repository."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "The raw relationships data to be merged into the schema."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated full schema with merged relationship data."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods or functions.",
                "called_by": "This method is not called by any other methods or functions."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method analyzes a repository by parsing the AST of its Python files and constructing a schema representing the repository's structure. It takes a list of files and a GitRepository object as input, and returns the constructed schema. The method utilizes the ASTVisitor class to parse the AST of individual files.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of files to be analyzed."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "A GitRepository object representing the repository to be analyzed."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The constructed schema representing the repository's structure."
                }
              ],
              "usage_context": {
                "calls": "This method calls the ASTVisitor class to parse the AST of individual files.",
                "called_by": "This method is not called by any other methods or functions."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The ASTAnalyzer class depends on the ASTVisitor class.",
          "instantiated_by": "The ASTAnalyzer class is not instantiated by any other classes or methods."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve file dependencies within a repository. It initializes a graph with a given filename and repository root, and provides methods to resolve relative imports and visit import statements. The class utilizes the NodeVisitor class from the ast module to traverse the abstract syntax tree of the file and extract import information.",
        "init_method": {
          "description": "The __init__ method initializes the FileDependencyGraph instance with a filename and repository root. It sets the filename and repo_root attributes of the instance.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to analyze."
            },
            {
              "name": "repo_root",
              "type": "str",
              "description": "The root directory of the repository."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "The _resolve_module_name method resolves relative imports of the form `from .. import name1, name2`. It returns a list of existing module or symbol names. If no resolution is possible, it raises an ImportError.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import node to resolve."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "The method calls get_all_temp_files, init_exports_symbol, and module_file_exists to resolve the relative import.",
                "called_by": "The method is called by visit_ImportFrom to resolve relative imports."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "The visit_Import method visits an import statement and adds the imported module to the import dependencies of the file.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "The import node to visit."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "The base name of the imported module."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "The method does not call any other methods.",
                "called_by": "The method is called by visit_ImportFrom to visit import statements."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "The visit_ImportFrom method visits an import from statement and resolves the relative import using the _resolve_module_name method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The import from node to visit."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "The method calls _resolve_module_name to resolve relative imports.",
                "called_by": "The method is not called by any other method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on get_all_temp_files, init_exports_symbol, and module_file_exists to resolve relative imports.",
          "instantiated_by": "The class is not instantiated by any other class or method."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class is designed to interact with Google Gemini for generating code snippet documentation. It centralizes API interaction, error handling, and validates I/O using Pydantic. The class provides methods for generating and validating documentation for batches of functions and classes.",
        "init_method": {
          "description": "The __init__ method initializes the LLMHelper object with an API key, function prompt path, class prompt path, model name, and base URL. It sets up the API interaction, error handling, and validates I/O using Pydantic.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for Google Gemini."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "The path to the function prompt file."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "The path to the class prompt file."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use for generating documentation. Defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the API. Defaults to None."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "The _configure_batch_settings method configures the batch settings for the LLMHelper object based on the model name.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "The name of the model to use for generating documentation."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called by the __init__ method to configure the batch settings.",
                "called_by": "This method is called by the __init__ method."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "The generate_for_functions method generates and validates documentation for a batch of functions.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of FunctionAnalysisInput objects to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_functions",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated FunctionAnalysis objects."
                }
              ],
              "usage_context": {
                "calls": "This method calls the function_llm.batch method to generate documentation for the functions.",
                "called_by": "This method is not called by any other method in the class."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "The generate_for_classes method generates and validates documentation for a batch of classes.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of ClassAnalysisInput objects to generate documentation for."
                }
              ],
              "returns": [
                {
                  "name": "all_validated_classes",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated ClassAnalysis objects."
                }
              ],
              "usage_context": {
                "calls": "This method calls the class_llm.batch method to generate documentation for the classes.",
                "called_by": "This method is not called by any other method in the class."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The LLMHelper class does not have any external dependencies.",
          "instantiated_by": "The LLMHelper class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class is the primary interface for interacting with a Large Language Model (LLM). It provides methods for calling and streaming the LLM, allowing for flexible and efficient communication. The class initializes with an API key, prompt file path, and model name, and it supports various LLM models and APIs. The MainLLM class is responsible for handling LLM calls, streaming, and error handling, making it a crucial component in a larger system.",
        "init_method": {
          "description": "The MainLLM class is initialized with an API key, prompt file path, and model name. The constructor checks for the presence of the API key and reads the system prompt from the specified file path. It then sets up the LLM instance based on the model name, using either the ChatGoogleGenerativeAI, ChatOpenAI, or ChatOllama class. The constructor also logs information about the initialization process.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key for the LLM"
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt"
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the LLM model (default: 'gemini-2.5-pro')"
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "The base URL for the LLM API (default: None)"
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "The call_llm method sends a user input to the LLM and returns the response. It constructs a list of messages, including the system prompt and user input, and then invokes the LLM using the invoke method. The method logs information about the LLM call and returns the response content.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The user input to send to the LLM"
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The response content from the LLM"
                }
              ],
              "usage_context": {
                "calls": "The call_llm method calls the invoke method of the LLM instance.",
                "called_by": "The call_llm method is not explicitly called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "The stream_llm method streams the LLM response to a user input. It constructs a list of messages, including the system prompt and user input, and then streams the LLM response using the stream method. The method logs information about the LLM stream call and yields the response content.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The user input to send to the LLM"
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The response content from the LLM"
                }
              ],
              "usage_context": {
                "calls": "The stream_llm method calls the stream method of the LLM instance.",
                "called_by": "The stream_llm method is not explicitly called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The MainLLM class does not have any explicit dependencies listed in the provided context.",
          "instantiated_by": "The MainLLM class is not explicitly instantiated by any other class or method in the provided context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README, pyproject.toml, and requirements.txt. It initializes a structured information dictionary and populates it by parsing the contents of these files.",
        "init_method": {
          "description": "The constructor initializes the class with a predefined structure for project information, including placeholders for project overview and installation details.",
          "parameters": [
            {
              "name": "self",
              "type": "reference",
              "description": "Reference to the instance of the class."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from a given content string, which can occur due to encoding errors.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "content",
                  "type": "str",
                  "description": "The content string to be cleaned."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches case-insensitively for a file that matches one of the given patterns.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file patterns to search for."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to search through."
                }
              ],
              "returns": [
                {
                  "name": "file",
                  "type": "Optional[Any]",
                  "description": "The found file or None if not found."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text under a Markdown heading (##) based on given keywords.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The Markdown content to search in."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "Keywords to identify the section."
                }
              ],
              "returns": [
                {
                  "name": "section_text",
                  "type": "Optional[str]",
                  "description": "The extracted section text or None if not found."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file and extracts relevant project information.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file and extracts project information.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file and extracts dependencies.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the extraction of project information from given files and a repository URL.",
              "parameters": [
                {
                  "name": "self",
                  "type": "reference",
                  "description": "Reference to the instance of the class."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of files to extract information from."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository."
                }
              ],
              "returns": [
                {
                  "name": "project_info",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the 'tomli' library for parsing pyproject.toml files.",
          "instantiated_by": "The class can be instantiated by any part of the system that needs to extract project information."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is designed to analyze the call structure of a given Python file. It utilizes the abstract syntax tree (AST) to traverse and understand the definitions and calls within the file, constructing a directed graph that represents the call relationships between functions and methods.",
        "init_method": {
          "description": "The constructor of the CallGraph class initializes the object with a given filename. It sets up several instance variables to keep track of the current function and class being processed, as well as data structures to store local definitions, the call graph, import mappings, and function sets.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "This method recursively resolves the components of a call node in the AST, returning a list of name components as a dotted string. It handles different types of nodes such as Call, Name, and Attribute.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call | ast.Name | ast.Attribute",
                  "description": "The node in the AST to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "This method takes a list of callee nodes and resolves their names based on local definitions and import mappings. It returns a list of resolved callee names.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists representing the name components of callee nodes."
                }
              ],
              "returns": [
                {
                  "name": "resolved_callees",
                  "type": "list[str]",
                  "description": "A list of resolved callee names."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "This method constructs a full name for a given basename and optional class name, prefixing them with the filename.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name to be used."
                },
                {
                  "name": "class_name",
                  "type": "str | None",
                  "description": "The optional class name."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "The constructed full name."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "This method returns the name of the current caller, which is either the current function or a representation of the global scope if no function is being processed.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The name of the current caller."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method processes Import nodes in the AST, updating the import mapping with the names and aliases of imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The Import node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method processes ImportFrom nodes in the AST, updating the import mapping with the names and aliases of imported modules.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The ImportFrom node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method processes ClassDef nodes in the AST, temporarily updating the current class being processed and then reverting it after processing.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The ClassDef node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method processes FunctionDef nodes in the AST, updating local definitions and the call graph with the function name and its full name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The FunctionDef node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "This method processes AsyncFunctionDef nodes in the AST by delegating to the visit_FunctionDef method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "The AsyncFunctionDef node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method processes Call nodes in the AST, resolving the callee names and updating the call edges in the graph.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The Call node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "This method processes If nodes in the AST, handling a special case when the condition checks the __name__ variable.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "The If node to be processed."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the 'ast' and 'networkx' modules for its operation.",
          "instantiated_by": "The class is instantiated with a filename to analyze the call graph of that file."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file in a Git repository. It provides lazy loading of the file's content, size, and blob object. The class has methods to analyze the file's content, such as counting the number of words. It also provides a dictionary representation of the file's metadata.",
        "init_method": {
          "description": "Initializes the RepoFile object with a file path and a commit tree. The file path is stored as an instance attribute, and the commit tree is used to lazy-load the file's blob object.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "Lazy-loads and returns the Git blob object associated with the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object associated with the file."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the content and size properties."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "Lazy-loads and returns the decoded content of the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "This method calls the blob property to lazy-load the blob object.",
                "called_by": "This method is called by the analyze_word_count method."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "Lazy-loads and returns the size of the file in bytes.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "This method calls the blob property to lazy-load the blob object.",
                "called_by": "This method is called by the to_dict method."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "Analyzes the file's content by counting the number of words.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The number of words in the file's content."
                }
              ],
              "usage_context": {
                "calls": "This method calls the content property to lazy-load the file's content.",
                "called_by": "This method is not called by any other methods."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "Returns a string representation of the RepoFile object.",
              "parameters": [],
              "returns": [
                {
                  "name": "representation",
                  "type": "str",
                  "description": "A string representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is not called by any other methods."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "Returns a dictionary representation of the file's metadata.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include the file's content in the dictionary."
                }
              ],
              "returns": [
                {
                  "name": "metadata",
                  "type": "dict",
                  "description": "A dictionary representation of the file's metadata."
                }
              ],
              "usage_context": {
                "calls": "This method calls the size property to lazy-load the file's size.",
                "called_by": "This method is not called by any other methods."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not have any external dependencies.",
          "instantiated_by": "This class is not instantiated by any other classes or methods."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to the repository's files as RepoFile objects. It handles cloning, retrieving files, and cleaning up the temporary directory. The class is designed to be used as a context manager, ensuring the temporary directory is deleted after use.",
        "init_method": {
          "description": "The class is initialized with a repository URL, which is used to clone the repository into a temporary directory. The constructor also sets up the repository object and retrieves the latest commit.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "string",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "This method retrieves a list of all files in the repository as RepoFile objects. It uses the repository's git ls-files command to get the file paths and then creates RepoFile objects for each file.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile objects representing the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.getRepo.RepoFile class to create RepoFile objects.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "This method deletes the temporary directory and its contents. It is called when the context manager exits.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the __exit__ method when the context manager exits."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "This method returns a dictionary representing the file tree of the repository. It uses the get_all_files method to retrieve the files and then constructs the file tree.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "include_content",
                  "type": "boolean",
                  "description": "A flag indicating whether to include the file content in the file tree."
                }
              ],
              "returns": [
                {
                  "name": "file_tree",
                  "type": "dict",
                  "description": "A dictionary representing the file tree of the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the get_all_files method to retrieve the files.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the backend.getRepo.RepoFile class.",
          "instantiated_by": "The class is not instantiated by any other class in the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is designed to analyze a project by traversing its directory, identifying Python files, and resolving function and method calls within those files. It constructs a call graph that represents the relationships between different parts of the project.",
        "init_method": {
          "description": "The constructor initializes the ProjectAnalyzer with a project root path. It sets up instance attributes such as the project root, definitions, call graph, file ASTs, and directories to ignore.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "This method orchestrates the analysis of the project by finding Python files, collecting definitions, resolving calls, and returning the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "dict",
                  "description": "A dictionary representing the call graph of the project."
                }
              ],
              "usage_context": {
                "calls": "This method calls _find_py_files, _collect_definitions, and _resolve_calls to perform the analysis.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "This method processes the call graph to extract raw relationships between callers and callees, categorizing them into outgoing and incoming calls.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary with 'outgoing' and 'incoming' call relationships."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "This method traverses the project directory to find all Python files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list",
                  "description": "A list of paths to Python files in the project."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "This method reads Python files, parses their AST, and collects definitions of functions, methods, and classes.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file to collect definitions from."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls path_to_module to convert the file path to a module path.",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "This method finds the parent node of a given node in the AST.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.Tree",
                  "description": "The AST to search in."
                },
                {
                  "name": "node",
                  "type": "ast.Node",
                  "description": "The node to find the parent for."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.Node",
                  "description": "The parent node of the given node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "This method resolves function and method calls within a given Python file by visiting its AST.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The path to the Python file to resolve calls from."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls CallResolverVisitor to perform the call resolution.",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on CallResolverVisitor and path_to_module for its operations.",
          "instantiated_by": "The class is not instantiated by any part of the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is designed to traverse an Abstract Syntax Tree (AST) of Python code and resolve function calls, tracking the call relationships and context.",
        "init_method": {
          "description": "The constructor initializes the visitor with a filepath, project root, and definitions. It sets up the module path, scope, instance types, and other contextual information.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The file path of the module being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A dictionary of definitions used to resolve function calls."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "This method visits a class definition node in the AST, updating the current class name and recursively visiting the class body.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The class definition node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "This method visits a function definition node, updating the current caller name and recursively visiting the function body.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The function definition node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "This method visits a function call node, resolving the callee's pathname and recording the call relationship if the callee is defined.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The function call node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "This method visits an import statement, updating the scope with the imported names.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The import node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "This method visits an import from statement, updating the scope with the imported names and their full module paths.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The import from node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "This method visits an assignment node, tracking instance types if the assigned value is a class instantiation.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The assignment node."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "This method resolves the full pathname of a function call, considering names, attributes, and scopes.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.Name or ast.Attribute",
                  "description": "The function node to resolve."
                }
              ],
              "returns": [
                {
                  "name": "pathname",
                  "type": "str or None",
                  "description": "The resolved pathname or None if unresolved."
                }
              ],
              "usage_context": {
                "calls": "",
                "called_by": ""
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on the backend.relationship_analyzer.path_to_module function for resolving module paths.",
          "instantiated_by": "The class is not directly instantiated by any known part of the system."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic model that represents a single parameter of a function. It encapsulates the name, type, and description of the parameter, providing a structured way to document and validate function parameters. The class inherits from BaseModel, which is a Pydantic model that provides basic validation and serialization capabilities. The class has three attributes: name, type, and description, which are all strings. This class is likely used in the context of API documentation or function signature validation.",
        "init_method": {
          "description": "The class is initialized with three parameters: name, type, and description. These parameters are used to set the corresponding attributes of the class.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A brief description of the parameter."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model that represents the return value of a function. It encapsulates the name, type, and description of the return value, providing a structured way to document and validate function returns.",
        "init_method": {
          "description": "The class is initialized with three parameters: name, type, and description, which are all strings. These parameters are used to set up the instance attributes of the class.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ReturnDescription class has no external dependencies.",
          "instantiated_by": "There is no information available on where the ReturnDescription class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is designed to describe the calling context of a function, capturing information about the functions it calls and where it is called from. It serves as a fundamental component in understanding the interactions and dependencies within a system. The class inherits from BaseModel, indicating it leverages Pydantic for data validation and parsing. The UsageContext class encapsulates two key pieces of information: the functions it calls (represented by the 'calls' attribute) and the entities that call it (represented by the 'called_by' attribute). This class provides a structured way to represent and analyze the usage context of functions within a larger system.",
        "init_method": {
          "description": "The UsageContext class initializes with two parameters: 'calls' and 'called_by', both of which are strings. These parameters set up the instance attributes that describe the calling context of a function.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string representing the functions called by the function in question."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string representing the entities or functions that call the function in question."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The UsageContext class does not have any external dependencies beyond what is inherited from BaseModel.",
          "instantiated_by": "There is no information provided about where the UsageContext class is instantiated."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model that represents a detailed analysis of a function's purpose and signature. It contains attributes for the overall description, parameters, return values, and usage context. This class provides a structured way to document and analyze functions, making it easier to understand their behavior and interactions.",
        "init_method": {
          "description": "The FunctionDescription class is initialized with attributes for overall description, parameters, return values, and usage context. The constructor does not take any explicit parameters, relying on Pydantic's automatic generation of an __init__ method.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionDescription class has no external dependencies.",
          "instantiated_by": "The FunctionDescription class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class represents a model for analyzing functions, encapsulating their identifier, description, and potential errors. It inherits from pydantic's BaseModel, ensuring data validation and serialization capabilities. The class is designed to provide a structured representation of function analysis results, facilitating further processing and documentation generation.",
        "init_method": {
          "description": "The FunctionAnalysis class is initialized with an identifier, a description of type FunctionDescription, and an optional error message. The identifier uniquely represents the function being analyzed, while the description provides detailed information about the function's purpose and behavior. The error field is used to store any error messages that may occur during the analysis process.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function being analyzed."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "A detailed description of the function's purpose and behavior."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional error message that may occur during the analysis process."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionAnalysis class has no external dependencies.",
          "instantiated_by": "The FunctionAnalysis class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is designed to provide a structured description of a class's constructor method. It encapsulates the description and parameters of the constructor, offering a clear and standardized way to document and analyze class initialization.",
        "init_method": {
          "description": "The ConstructorDescription class is initialized with a description and a list of parameters, which are used to describe the constructor method of a class.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A string describing the constructor method."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects, each describing a parameter of the constructor method."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ConstructorDescription class has no external dependencies.",
          "instantiated_by": "The ConstructorDescription class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is designed to describe the external dependencies and primary points of instantiation for a given class. It encapsulates this information within two key attributes: dependencies and instantiated_by, providing a structured way to understand a class's integration and usage within a larger system.",
        "init_method": {
          "description": "The ClassContext class is initialized with two parameters: dependencies and instantiated_by, which are used to set up the instance attributes of the same names. These attributes are essential for tracking the dependencies and instantiation points of a class.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string representing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string indicating where the class is instantiated."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassContext class does not have any external dependencies listed.",
          "instantiated_by": "There are no recorded points of instantiation for the ClassContext class."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is designed to hold the detailed analysis of a class's purpose, constructor, and methods. It serves as a structured container for the comprehensive breakdown of a class's components, including its initialization method, individual methods, and usage context. This class plays a crucial role in documenting and understanding the behavior and interactions of classes within a larger system.",
        "init_method": {
          "description": "The ClassDescription class is initialized with four key attributes: overall, init_method, methods, and usage_context. The overall attribute is a string that provides a high-level description of the class's purpose. The init_method attribute is an instance of ConstructorDescription, which details the class's constructor. The methods attribute is a list of FunctionAnalysis objects, each representing a method within the class. The usage_context attribute is an instance of ClassContext, which outlines the class's dependencies and instantiation points.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the class's overall purpose."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An instance of ConstructorDescription detailing the class's constructor."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects, each representing a method within the class."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An instance of ClassContext outlining the class's dependencies and instantiation points."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassDescription class has no external dependencies.",
          "instantiated_by": "The ClassDescription class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class represents the main model for the entire JSON schema for a class. It contains an identifier, a description of the class, and an optional error message. The class is a Pydantic BaseModel, which provides validation and parsing capabilities for the JSON schema.",
        "init_method": {
          "description": "The ClassAnalysis class is initialized with an identifier, a description, and an optional error message. The identifier is a string that uniquely identifies the class, the description is an instance of ClassDescription, and the error message is an optional string.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string that uniquely identifies the class."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An instance of ClassDescription that provides a detailed description of the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string that represents an error message."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassAnalysis class has no external dependencies.",
          "instantiated_by": "The ClassAnalysis class is not instantiated by any other class or function in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer. It is used in 'called_by' and 'instantiated_by' lists to provide information about the caller, including the file, function, mode, and line number. This class inherits from pydantic's BaseModel, indicating it is a data model with validation capabilities. The class has four attributes: file, function, mode, and line, which are used to store the details of the call event.",
        "init_method": {
          "description": "The CallInfo class is initialized with four parameters: file, function, mode, and line. These parameters are used to set the corresponding attributes of the class, providing a way to store and manage call event information.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file where the call event occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that made the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, such as 'method', 'function', or 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number where the call event occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The CallInfo class has no external dependencies.",
          "instantiated_by": "The CallInfo class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model that represents structured context for analyzing a function. It encapsulates information about the functions a given function calls and the functions that call it. This class is designed to provide a standardized way of representing function context, facilitating analysis and processing of function relationships.",
        "init_method": {
          "description": "The FunctionContextInput class is initialized with two parameters: calls and called_by. The calls parameter is a list of strings representing the functions called by the analyzed function, while the called_by parameter is a list of CallInfo objects representing the functions that call the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionContextInput class has no external dependencies.",
          "instantiated_by": "The FunctionContextInput class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class is a Pydantic model that represents the required input to generate a FunctionAnalysis object. It encapsulates the necessary information for analyzing a function, including the mode, identifier, source code, imports, and context. The class inherits from BaseModel, which provides the foundation for building robust and validated data models.",
        "init_method": {
          "description": "The class is initialized with the mode, identifier, source code, imports, and context. The mode is restricted to 'function_analysis', and the identifier, source code, and imports are required strings and lists. The context is an instance of FunctionContextInput.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "The mode of analysis, which is restricted to 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The unique identifier of the function to be analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements required for the function analysis."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "The context in which the function is being analyzed, which includes dependencies, instantiated_by, and method_context."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The FunctionAnalysisInput class has no external dependencies.",
          "instantiated_by": "The FunctionAnalysisInput class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to hold structured context information for a class's methods. It encapsulates details such as the method's identifier, the functions it calls, the entities that call it, its arguments, and an optional docstring. This class plays a crucial role in documenting and analyzing the behavior of methods within a larger system, providing a standardized way to represent method contexts.",
        "init_method": {
          "description": "The MethodContextInput class is initialized with several parameters that define the context of a method. These include the method's identifier, calls, called_by, args, and an optional docstring. The initialization sets up the instance attributes that store this contextual information.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "The unique identifier of the method."
            },
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of functions or methods called by this method."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of entities (methods, functions, etc.) that call this method."
            },
            {
              "name": "args",
              "type": "List[str]",
              "description": "A list of argument names or types associated with the method."
            },
            {
              "name": "docstring",
              "type": "Optional[str]",
              "description": "An optional docstring that provides a description of the method's purpose and behavior."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The MethodContextInput class does not have any external dependencies listed.",
          "instantiated_by": "There are no specified entities that instantiate the MethodContextInput class."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class represents a structured context for analyzing a class, encapsulating information about dependencies, instantiation, and method contexts. It inherits from pydantic's BaseModel, ensuring data validation and serialization capabilities. The class's primary purpose is to provide a standardized format for capturing and processing class-related metadata, facilitating comprehensive analysis and documentation generation.",
        "init_method": {
          "description": "The class is initialized with three key attributes: dependencies, instantiated_by, and method_context. These attributes are defined as lists, with dependencies storing strings, instantiated_by storing CallInfo objects, and method_context storing MethodContextInput objects.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of strings representing the class's dependencies."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects indicating where the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects providing context for the class's methods."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The class has no external dependencies.",
          "instantiated_by": "The class is not instantiated by any other classes or functions."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput class represents the required input to generate a ClassAnalysis object. It encapsulates the necessary information for class analysis, including the mode, identifier, source code, imports, and context. This class is designed to provide a structured input for class analysis, ensuring that all necessary information is present and properly formatted.",
        "init_method": {
          "description": "The ClassAnalysisInput class is initialized with the mode, identifier, source code, imports, and context. The mode is set to 'class_analysis', indicating the purpose of the input. The identifier, source code, and imports are used to provide context for the class analysis. The context is an instance of ClassContextInput, which contains additional information about the class.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['class_analysis']",
              "description": "The mode of the class analysis, which is set to 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "The identifier of the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The source code of the class being analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements relevant to the class being analyzed."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "An instance of ClassContextInput, which contains additional information about the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "The ClassAnalysisInput class has no external dependencies.",
          "instantiated_by": "The ClassAnalysisInput class is not instantiated by any other classes or functions in the provided context."
        }
      },
      "error": null
    }
  }
}