{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The function 'path_to_module' converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to ensure proper module naming.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "This function constructs a directed graph representing file dependencies within a codebase. It takes a filename, an abstract syntax tree (AST), and a repository root path as inputs. It uses a custom visitor class to traverse the AST and extract import dependencies. These dependencies are then added to a NetworkX DiGraph, where nodes represent files and edges represent import relationships.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed for dependencies."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree of the file being analyzed."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository containing the file."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing file dependencies, where nodes are files and edges indicate import relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.FileDependencyGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "This function constructs a directed graph representing the dependencies between files in a Git repository. It retrieves all files from the repository, filters them based on file extension and path, parses each file's content into an abstract syntax tree (AST), and then builds a dependency graph for each file. These individual graphs are merged into a single global graph that captures the overall dependency structure of the repository.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "The Git repository object containing the files to analyze for dependencies."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the dependency relationships between files in the repository."
          }
        ],
        "usage_context": {
          "calls": "backend.File_Dependency.build_file_dependency_graph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories. It resolves the given directory path to an absolute path, then uses recursive globbing to find all .py files. Each found file is converted to a relative path with respect to the root directory. The function returns a list of these relative paths as pathlib.Path objects.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory from which to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[pathlib.Path]",
            "description": "A list of pathlib.Path objects representing the relative paths of all .py files found in the directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "The main_orchestrator function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analyses for three example functions: add_item, check_stock, and generate_report. These analyses are then used to simulate how the LLMHelper would process function inputs and generate documentation. The function sets up mock inputs, initializes an LLMHelper instance, and processes these inputs to produce a final documentation structure.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_callGraph": {
      "identifier": "backend.callgraph.build_callGraph",
      "description": {
        "overall": "This function constructs a call graph from an abstract syntax tree (AST) of Python code. It uses a custom CallGraph visitor class to traverse the AST and extract function call relationships. The resulting graph includes only those nodes and edges that correspond to functions defined within the same file or module. The function returns a NetworkX directed graph representing these intra-module call relationships.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The abstract syntax tree of the Python source code to analyze."
          },
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file from which the AST was generated, used for identification purposes."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the intra-module function call relationships extracted from the AST."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a copy of the graph and generates a safe node naming scheme by prefixing each node with 'n' followed by its index. The original node labels are preserved in the 'label' attribute of the new nodes. Finally, it writes the transformed graph to a file in DOT format using the pydot library.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph to be processed and saved."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the DOT representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The function builds a filtered call graph from a Git repository by parsing Python files and extracting function call relationships. It first collects all Python files, parses them into abstract syntax trees, and uses a custom CallGraph visitor to identify function definitions and calls. Then, it constructs a global directed graph containing only edges between functions that are considered 'own' (i.e., defined in the repository). The resulting graph includes only nodes and edges corresponding to functions written within the repository.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "A GitRepository object representing the repository whose files are analyzed to construct the call graph."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A NetworkX directed graph representing the filtered call graph, containing only functions defined in the repository and their inter-call relationships."
          }
        ],
        "usage_context": {
          "calls": "backend.callgraph.CallGraph",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The function 'wrap_cdata' takes a given content string and wraps it within CDATA (Character Data) tags, which are commonly used in XML documents to escape blocks of text that might otherwise be interpreted as markup. This ensures that special characters and markup-like content within the string are treated as literal text. The function returns the formatted string with the CDATA wrapper applied.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The input content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The function extracts content from notebook outputs, handling both text and image data. It processes outputs of different types such as display_data, execute_result, stream, and error, returning a list of text snippets or image placeholders. For images, it decodes Base64-encoded data and appends it to an image list while generating a placeholder XML string. The function prioritizes PNG over JPEG when both are present.",
        "parameters": [
          {
            "name": "outputs",
            "type": "Any",
            "description": "A collection of output objects from a notebook cell."
          },
          {
            "name": "image_list",
            "type": "List[Dict[str, Any]]",
            "description": "A mutable list to store decoded image data along with metadata."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "List[str]",
            "description": "A list of text strings or XML placeholders representing the extracted content."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The function processes an image based on its MIME type by retrieving base64-encoded data, cleaning it, and appending it to a global list of images. It then returns an XML placeholder string indicating the image's location and MIME type. If any error occurs during processing, it returns an error message. If the MIME type is not found in the data dictionary, the function returns None.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The MIME type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str or None",
            "description": "An XML placeholder string indicating the image's location and MIME type if successful, or an error message if decoding fails, or None if the MIME type is not found in the data."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The function converts a Jupyter notebook, represented as a string of JSON content, into an XML format. It parses the notebook using nbformat, iterates through each cell, and transforms markdown and code cells into XML elements. For code cells, it also extracts and includes output content if present. The function handles parsing errors gracefully by returning an error message and an empty list.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "A string containing the raw JSON content of a Jupyter notebook."
          }
        ],
        "returns": [
          {
            "name": "xml_output",
            "type": "str",
            "description": "A string representing the converted XML content of the notebook, with cells separated by double newlines."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted image data or metadata from the notebook's outputs."
          }
        ],
        "usage_context": {
          "calls": "backend.converter.extract_output_content, backend.converter.wrap_cdata",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "This function processes a list of repository files to identify and convert Jupyter notebook files (.ipynb) into XML format along with associated images. It iterates through the notebook files, logs the processing status, and returns a dictionary mapping each notebook file path to its converted XML content and image data.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "List[File]",
            "description": "A list of file objects representing the files in the repository, each expected to have a 'path' attribute and a 'content' attribute."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "Dict[str, Dict[str, Any]]",
            "description": "A dictionary where keys are the paths of the processed notebook files and values are dictionaries containing the converted XML output and associated images."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.mermaid_id": {
      "identifier": "backend.diagram_generation.emitter.mermaid_id",
      "description": {
        "overall": "The function 'mermaid_id' takes a string input named 'name' and returns a modified version of that string where all periods ('.') are replaced with underscores ('_'). This ensures compatibility with Mermaid diagram syntax, which does not allow periods in identifiers. The function performs a simple string transformation without any conditional logic or error handling.",
        "parameters": [
          {
            "name": "name",
            "type": "str",
            "description": "A string representing the identifier to be converted for use in Mermaid diagrams."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "str",
            "description": "The input string with all periods replaced by underscores."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.analyze_project": {
      "identifier": "backend.diagram_generation.generator.analyze_project",
      "description": {
        "overall": "The function 'analyze_project' processes a list of repository files to build a project index and resolve function calls within the codebase. It iterates through Python files, parses their ASTs, collects symbols, and builds a module-based structure. It then analyzes these modules to identify function calls and resolves them using a call resolver. The result is a project index and a set of resolved calls.",
        "parameters": [
          {
            "name": "all_files",
            "type": "list[RepoFile]",
            "description": "A list of repository files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index of the project modules and their symbols."
          },
          {
            "name": "resolved_calls",
            "type": "ResolvedCall",
            "description": "A mapping of resolved function calls within the project."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.main_diagram_generation": {
      "identifier": "backend.diagram_generation.generator.main_diagram_generation",
      "description": {
        "overall": "This function generates Mermaid sequence diagrams for Python functions based on their call relationships. It takes a list of Python files, analyzes them to resolve function calls, groups these calls by caller function, and then emits Mermaid sequence diagram representations for each group. The result is a dictionary mapping function names to their corresponding Mermaid sequence diagram strings.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[str]",
            "description": "A list of paths to Python source files to analyze and generate diagrams for."
          }
        ],
        "returns": [
          {
            "name": "seqs",
            "type": "dict[str, str]",
            "description": "A dictionary mapping function names to their corresponding Mermaid sequence diagram strings."
          }
        ],
        "usage_context": {
          "calls": "backend.diagram_generation.generator.analyze_project",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.enrich_report_with_diagrams": {
      "identifier": "backend.diagram_generation.generator.enrich_report_with_diagrams",
      "description": {
        "overall": "The function 'enrich_report_with_diagrams' takes a final report string and a dictionary of diagrams, then inserts the diagrams into the report at specific locations. It splits the report into lines and iterates through each line to check for markers indicating where diagrams should be inserted. When a marker is found, the corresponding diagram is appended to the enriched report. Finally, the enriched report is returned as a single string with newline characters separating the lines.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "A string representing the final report content where diagrams need to be inserted."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary mapping function names to their corresponding diagrams that should be inserted into the report."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "A string representing the final report with diagrams inserted at appropriate locations."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.analyze_project": {
      "identifier": "backend.diagram_generation.main.analyze_project",
      "description": {
        "overall": "The function 'analyze_project' processes a list of Python files to build a project index and resolve function calls within the codebase. It parses each file into an Abstract Syntax Tree (AST), collects symbols, and builds a module-based structure. Then, it traverses the ASTs to identify function calls and resolves them using a call resolver. Finally, it returns both the project index and the resolved function calls.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[RepoFile]",
            "description": "A list of RepoFile objects representing Python source files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index of the project modules, including collected symbols and metadata."
          },
          {
            "name": "resolved_calls",
            "type": "dict[str, list[ResolvedCall]]",
            "description": "A dictionary mapping module names to lists of resolved function calls identified in that module."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.construct_overview_diagram": {
      "identifier": "backend.diagram_generation.main.construct_overview_diagram",
      "description": {
        "overall": "This function constructs an overview diagram by extracting package information from a project's modules. It iterates through each module in the project, collects their overlying packages, and aggregates them into a list. The function then deduplicates these packages using a set and returns the resulting list of package lists. The function appears to be designed to prepare data for diagram generation but does not fully implement the intended deduplication or sorting logic.",
        "parameters": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "An index containing project modules and their associated metadata."
          }
        ],
        "returns": [
          {
            "name": "packages",
            "type": "list[list[str]]",
            "description": "A list of lists containing package names extracted from the project modules."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.main_diagram_generation": {
      "identifier": "backend.diagram_generation.main.main_diagram_generation",
      "description": {
        "overall": "This function generates sequence diagrams for a given Python project by analyzing its structure and resolving function calls. It initializes a Git repository, retrieves all Python files, and uses an analysis function to process them. The function then organizes these calls into groups based on their callers and emits Mermaid sequence diagrams for each group. Finally, it writes the generated diagrams to a Markdown file.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.diagram_generation.main.analyze_project",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.attach_with_parents": {
      "identifier": "backend.diagram_generation.symbol_collector.attach_with_parents",
      "description": {
        "overall": "This function traverses an Abstract Syntax Tree (AST) and assigns parent references to each node in the tree. It uses the `walk` function to iterate through all nodes and `iter_child_nodes` to access each node's children, setting the `parent` attribute of each child to point to its parent node. This allows for bidirectional navigation within the AST structure.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The root node of the Abstract Syntax Tree to process."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The function creates a bar chart comparing token counts between JSON and TOON formats, displaying the savings percentage in the title. It uses matplotlib to generate the visualization and saves it to a specified file path. The chart includes labeled axes, a grid, and value annotations on top of each bar.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of tokens in the JSON format."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of tokens in the TOON format."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage savings represented in the chart title."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The file path where the generated chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The function calculates the net time duration between a start and end time, adjusted for sleep periods caused by rate limits when using specific models. It first computes the total duration and then checks if the model name starts with 'gemini-'. If not, it returns the total duration directly. If the model is a gemini model and there are no items, it returns zero. Otherwise, it calculates the number of batches required, determines the number of sleep periods, computes the total sleep time, and subtracts it from the total duration to return the net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float or datetime",
            "description": "The starting timestamp or time value."
          },
          {
            "name": "end_time",
            "type": "float or datetime",
            "description": "The ending timestamp or time value."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items being processed."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The number of items per batch."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used, which determines whether rate limit adjustments apply."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float or int",
            "description": "The calculated net time after subtracting sleep durations due to rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The `main_workflow` function orchestrates a comprehensive code analysis pipeline for a given GitHub repository. It begins by validating and extracting API keys and model configurations, followed by cloning the repository and extracting essential information such as file trees and project metadata. The function then performs relationship analysis and builds an abstract syntax tree (AST) schema. Using helper LLMs, it analyzes individual functions and classes, generating detailed documentation. Finally, it prepares inputs for a main LLM to produce a final report, including performance metrics and visualizations.",
        "parameters": [
          {
            "name": "user_input",
            "type": "str",
            "description": "Input provided by the user, expected to contain a valid GitHub repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "Dictionary containing API keys for various models and services such as Gemini, OpenAI, and custom endpoints."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "Dictionary specifying the names of helper and main language models to be used in the workflow."
          },
          {
            "name": "status_callback",
            "type": "Callable[[str], None] | None",
            "description": "Optional callback function to report progress updates during execution."
          },
          {
            "name": "check_stop",
            "type": "Callable[[], bool] | None",
            "description": "Optional function to check if the workflow should be interrupted."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final markdown-formatted report generated by the main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing timing and token usage statistics for the workflow."
          }
        ],
        "usage_context": {
          "calls": "backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.diagram_generation.generator.main_diagram_generation, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.enrich_report_with_diagrams, backend.main.get_key_and_url, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, schemas.types.MethodContextInput",
          "called_by": "This function calls no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The function 'update_status' is designed to handle status updates within a workflow process. It first checks if a stop condition has been triggered by calling the 'check_stop' function, and if so, logs an interrupt message and raises an 'InterruptedError'. If a status callback function is defined, it invokes this callback with the provided message. Finally, it logs the message using the standard logging mechanism.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "A string message representing the status update to be logged and potentially passed to a callback function."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.get_key_and_url": {
      "identifier": "backend.main.get_key_and_url",
      "description": {
        "overall": "The function determines the appropriate API key and base URL for a given model name. It checks the model name prefix to decide which key and URL to return. For GPT models, it returns the OpenAI API key and no URL. For Gemini models, it ensures a Gemini API key is present and returns it along with no URL. For the 'llama3' model, it returns no key but the Ollama base URL. For other models, it first checks for a user-defined Open Source key and URL, falling back to system defaults if none are provided.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model for which to determine the API key and base URL."
          }
        ],
        "returns": [
          {
            "name": "key",
            "type": "Union[str, None]",
            "description": "The API key corresponding to the model, or None if not applicable."
          },
          {
            "name": "url",
            "type": "Union[str, None]",
            "description": "The base URL for the model, or None if not applicable."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.enrich_report_with_diagrams": {
      "identifier": "backend.main.enrich_report_with_diagrams",
      "description": {
        "overall": "The function `enrich_report_with_diagrams` takes a final report string and a dictionary of diagrams, then inserts diagrams into the report at specific locations. It splits the report into lines and iterates through them, appending each line to a new list. When it encounters a line containing \"#### Function:\", it checks if any filename from the diagrams dictionary is present in that line. If so, it appends the corresponding diagram to the new list. Finally, it joins all lines back into a single string and returns the enriched report.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "A string representing the final report content where diagrams need to be inserted."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary mapping filenames to diagram content that should be inserted into the report."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "A string representing the final report with diagrams inserted at appropriate locations."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function orchestrates the analysis of Jupyter notebooks within a GitHub repository. It begins by extracting a GitHub URL from the input, clones the repository, and processes all notebook files found. It then initializes an LLM based on the specified model and API keys, and sequentially analyzes each notebook using the LLM. The results are aggregated into a final report along with timing metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "Any",
            "description": "The input containing a GitHub URL to analyze."
          },
          {
            "name": "api_keys",
            "type": "Dict[str, str]",
            "description": "A dictionary mapping API key names to their respective values."
          },
          {
            "name": "model",
            "type": "str",
            "description": "The name of the language model to use for analysis."
          },
          {
            "name": "status_callback",
            "type": "Optional[Callable[[str], None]]",
            "description": "An optional callback function to report progress updates."
          },
          {
            "name": "check_stop",
            "type": "Optional[Callable[[], bool]]",
            "description": "An optional function to check if the workflow should be stopped."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "A combined report of all notebook analyses or a message indicating no notebooks were found."
          },
          {
            "name": "metrics",
            "type": "Dict[str, Union[int, float, str]]",
            "description": "Timing and model-related metrics for the entire workflow."
          }
        ],
        "usage_context": {
          "calls": "backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, backend.main.update_status",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The function `gemini_payload` constructs a structured payload for use with a Gemini API by combining basic information, a notebook path, and parsed XML content with embedded image placeholders. It processes the XML to identify image placeholders and substitutes them with base64-encoded image data from a provided list. The resulting payload is formatted as a list of dictionaries, each representing either text or image content.",
        "parameters": [
          {
            "name": "info",
            "type": "Any",
            "description": "Basic information to be included in the payload."
          },
          {
            "name": "path",
            "type": "Any",
            "description": "The current notebook path to be included in the payload."
          },
          {
            "name": "xml",
            "type": "str",
            "description": "XML content containing image placeholders to be processed."
          },
          {
            "name": "imgs",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries containing image data, indexed by position in the XML."
          }
        ],
        "returns": [
          {
            "name": "payload",
            "type": "List[Dict[str, Any]]",
            "description": "A list of dictionaries representing the structured payload, including text and image content."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The absolute or relative path to a Python file."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project used to compute the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "A dot-separated module path derived from the given file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The function encrypts a given text string using a Fernet cipher suite. It first checks if the input text is empty or if the cipher suite is not available, returning the original text in such cases. If both conditions are met, it encodes the stripped text, encrypts it, and returns the decrypted result as a string.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text string to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted version of the input text, returned as a string."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The function decrypts a given text string using a cipher suite. It first checks if the input text or the cipher suite is empty, returning the original text in such cases. If both are present, it attempts to decrypt the text by encoding it, performing the decryption, and then decoding the result back to a string. In case of any exception during decryption, it gracefully returns the original text.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The encrypted text string to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "return_value",
            "type": "str",
            "description": "The decrypted text string if decryption is successful; otherwise, the original input text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. It hashes the password using a hasher utility before storing the user information. The function also initializes several API key fields with empty strings. It returns the ID of the inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user, used as the '_id' field in the database."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The plain text password of the user, which gets hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The unique identifier of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It uses the pymongo library to perform a find operation on the collection and returns the results as a list. The function does not take any parameters and directly accesses the database collection.",
        "parameters": [],
        "returns": [
          {
            "name": "result",
            "type": "list",
            "description": "A list containing all user documents retrieved from the 'dbusers' collection in the MongoDB database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The function fetch_user retrieves a user document from a MongoDB collection based on the provided username. It uses the find_one method to query the database with a filter matching the '_id' field to the given username. The function does not perform any validation or transformation of the retrieved data before returning it.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to locate the specific user document in the database."
          }
        ],
        "returns": [
          {
            "name": "result",
            "type": "Any",
            "description": "The user document retrieved from the database, or None if no matching document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "This function updates the name field of a user in the database identified by their username. It uses MongoDB's update_one method to modify only the name field, leaving other fields unchanged. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier of the user whose name needs to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name value to set for the specified user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation. This indicates whether the update was successful."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "This function updates the Gemini API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key needs to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be stored for the user, which will be encrypted before saving."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "The function updates the GPT API key for a specified user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to store the encrypted key. The function returns the count of modified documents, indicating whether the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The GPT API key to be updated for the specified user, which will be stripped of whitespace and encrypted before storage."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and performs an update operation on the user document. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL needs to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new Ollama base URL to be set for the specified user. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. Typically 1 if the user exists and the update was applied."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "This function updates the OpenSRC API key for a given user in the database. It first encrypts the provided API key using an encryption function, then performs an update operation on the user document in the database to replace the existing API key with the encrypted version. The function returns the count of modified documents, which should be 1 if the update was successful.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose OpenSRC API key needs to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The OpenSRC API key to be updated for the specified user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "This function updates the 'opensrc_base_url' field for a user identified by their username in a MongoDB collection. It uses the 'dbusers' collection's 'update_one' method to modify the document matching the given username. The function ensures that any leading or trailing whitespace is removed from the provided URL before updating. The result of the update operation indicates how many documents were modified.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose 'opensrc_base_url' needs to be updated."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new URL to be set for the user's 'opensrc_base_url' field. Leading and trailing whitespace will be stripped."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation. This will typically be 0 if no document matches the username or 1 if exactly one document was updated."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Gemini API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "Optional[str]",
            "description": "The Gemini API key associated with the provided username, or None if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose Ollama base URL is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The function retrieves a GPT API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gpt_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose GPT API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the user, or None if the user is not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "This function retrieves the OpenSource API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'opensrc_api_key' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to look up the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The OpenSource API key if a user is found; otherwise, None."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "This function retrieves the open source base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'opensrc_base_url' field. If no matching user is found, it returns None.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) used to look up the user in the database."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str or None",
            "description": "The open source base URL associated with the user, or None if no user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The function 'delete_user' removes a user document from a MongoDB collection based on the provided username. It uses the 'delete_one' method to target a specific user identified by the '_id' field. The function returns the count of deleted documents, which will be 1 if the user was found and deleted, or 0 if no such user existed.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier (username) of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted, either 1 if the user was found and removed, or 0 if no matching user was found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "This function retrieves and decrypts API keys for a given username from a database. It fetches user data, checks for the existence of the user, and then decrypts specific API keys while returning them along with other URL values. The function handles cases where the user may not exist by returning None for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user whose API keys are to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key for the user, or an empty string if not found."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL for the user, or an empty string if not found."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSRC API key for the user, or an empty string if not found."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSRC base URL for the user, or an empty string if not found."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The function 'insert_chat' creates a new chat entry in a database collection. It generates a unique identifier using UUID, captures the username and chat name, and records the creation timestamp. The function then inserts this chat data into the database and returns the ID of the newly inserted document.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be created."
          }
        ],
        "returns": [
          {
            "name": "result.inserted_id",
            "type": "str",
            "description": "The unique identifier of the newly inserted chat document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet den Benutzernamen als Filterkriterium und sortiert die Ergebnisse nach dem Erstellungsdatum in aufsteigender Reihenfolge. Das Ergebnis ist eine Liste der Chat-Dokumente, die dem Benutzer zugeordnet sind.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "Der Benutzername, dessen Chats abgerufen werden sollen."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "Eine Liste von Chat-Dokumenten, die dem angegebenen Benutzer zugeordnet sind und nach Erstellungsdatum sortiert sind."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a lookup using MongoDB's find_one method with a query that matches both the username and chat name. The function returns a boolean value indicating the presence or absence of the chat entry.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "exists",
            "type": "bool",
            "description": "True if a chat with the specified username and chat_name exists in the database, False otherwise."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "This function renames a chat and updates all associated exchanges in the database. It first updates the chat entry in the chats collection, then updates all related exchange entries in the exchanges collection. The function returns the number of modified chat documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat to be renamed."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to assign to the chat."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of chat documents that were successfully modified during the renaming operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "This function inserts a new exchange record into a MongoDB collection. It generates a unique ID for the exchange, constructs a dictionary with all the provided details including optional fields with default values, and attempts to insert this document into the database. If the insertion is successful, it returns the generated ID; otherwise, it catches any exceptions, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in response to the question."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "Feedback associated with the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat session."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "The helper used in the exchange (optional, defaults to empty string)."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "The main component used in the exchange (optional, defaults to empty string)."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Total time taken for the exchange (optional, defaults to empty string)."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Time taken by the helper component (optional, defaults to empty string)."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Time taken by the main component (optional, defaults to empty string)."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Number of JSON tokens used (optional, defaults to 0)."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Number of Toon tokens used (optional, defaults to 0)."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Percentage saved during the exchange (optional, defaults to 0.0)."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique ID of the inserted exchange record, returned on successful insertion."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when an exception occurs during database insertion."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function retrieves all exchange records from a MongoDB collection for a given username, sorted by creation timestamp in ascending order. It queries the 'dbexchanges' collection using the provided username as a filter and sorts the results by the 'created_at' field. The function returns the list of matching exchange records.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchange records by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange records matching the provided username, sorted by creation timestamp in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with filtering criteria and orders the results by creation date in ascending order. The function returns the fetched documents as a list.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the exchanges to be retrieved."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat associated with the exchanges to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchange documents matching the provided username and chat name, sorted by creation date in ascending order."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "This function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document with the new feedback value. The function returns the count of modified documents, which indicates whether the update was successful.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The feedback value to be set in the document."
          }
        ],
        "returns": [
          {
            "name": "result.modified_count",
            "type": "int",
            "description": "The number of documents that were modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "This function updates the feedback message associated with a specific exchange document in a MongoDB collection. It takes an exchange ID and a new feedback message string, then performs an update operation on the database to set the feedback_message field. The function returns the count of modified documents, which indicates how many records were successfully updated.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "Any",
            "description": "The unique identifier of the exchange document to be updated."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be stored in the exchange document."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents that were successfully modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "This function deletes a document from the 'dbexchanges' collection in a MongoDB database based on a given exchange ID. It performs a deletion operation and returns the count of deleted documents. The function takes a single string parameter representing the exchange ID and uses it to construct a query to find and remove the matching document.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "A unique identifier for the exchange document to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents that were deleted as a result of the operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "This function deletes a chat and all associated exchanges from the database for a given username and chat name. It first removes all exchange records linked to the specified chat and then deletes the chat itself from the chat collection. The function returns the count of deleted chat documents.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "del_chat.deleted_count",
            "type": "int",
            "description": "The number of chat documents that were deleted from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The function 'clean_names' takes a list of strings representing model names and extracts the final component of each string after splitting by the '/' character. This effectively removes any path-like prefixes from the model names, leaving only the base name. It uses a list comprehension for efficient processing.",
        "parameters": [
          {
            "name": "model_list",
            "type": "List[str]",
            "description": "A list of strings where each string represents a model name, potentially including path components separated by '/'."
          }
        ],
        "returns": [
          {
            "name": "cleaned_names",
            "type": "List[str]",
            "description": "A list of strings containing only the final component of each model name after splitting by '/'."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The function filters a given list of models based on a specified category name. It retrieves keywords associated with the category and applies filtering logic depending on whether 'STANDARD' is included in those keywords. If 'STANDARD' is present, it returns only models that exist in a predefined standard list. Otherwise, it filters models whose names contain any of the retrieved keywords. If no models match the criteria, the original list is returned.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "A list of model names to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category used to determine filtering criteria."
          }
        ],
        "returns": [
          {
            "name": "filtered_models",
            "type": "list",
            "description": "A list of model names that match the filtering criteria. If no matches are found, the original source_list is returned."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_abort": {
      "identifier": "frontend.frontend.handle_abort",
      "description": {
        "overall": "The function 'handle_abort' is designed to signal an abort request within a Streamlit application. It sets a flag in the session state to indicate that an abort has been requested and displays a toast notification to the user. This function does not take any parameters and does not return any value.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "This function handles the saving of a Gemini API key entered by the user in the frontend interface. It retrieves the key from the session state, updates the database with the new key for the current user, clears the input field, and displays a success message to the user.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "This function retrieves an Ollama URL from the Streamlit session state and updates the database with the new URL for the current user. It also displays a success toast message upon completion. The function is designed to handle user input related to Ollama configuration.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_ollama_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_last_activity": {
      "identifier": "frontend.frontend.get_last_activity",
      "description": {
        "overall": "The function 'get_last_activity' determines the timestamp of the last message in a specified chat. It retrieves the chat's exchanges from the session state, checks if any exist, and extracts the datetime of the most recent exchange. If the datetime is stored as a string, it attempts to parse it into a datetime object. If no exchanges are found or parsing fails, it defaults to returning 'datetime.min'.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat for which to retrieve the last activity timestamp."
          }
        ],
        "returns": [
          {
            "name": "dt",
            "type": "datetime.datetime",
            "description": "The datetime of the last message in the chat, or datetime.min if no messages exist or parsing fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The function loads user-specific chat and exchange data from a database into the Streamlit session state. It first checks if the user data is already loaded; if not, it fetches chats and exchanges associated with the given username. It initializes session state variables for chats and exchanges, handling missing feedback values by setting them to NaN. If no chats exist, it creates an initial chat and sets it as active. Finally, it sorts chats by last activity and sets the most recent one as the active chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load chat and exchange data."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "This function updates the feedback value for a given exchange object and persists the change to the database. It also triggers a re-run of the Streamlit application to reflect the updated feedback in the UI. The function takes two arguments: an exchange dictionary and a new feedback value. It modifies the exchange dictionary in place by updating its 'feedback' key, then calls a database update function to save the change, and finally reruns the Streamlit app.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing an exchange object, expected to contain keys such as 'feedback' and '_id'."
          },
          {
            "name": "val",
            "type": "Any",
            "description": "The new feedback value to be assigned to the exchange object."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "The function handles the deletion of an exchange from the database and updates the session state to reflect the removal of the exchange from the specified chat. It first deletes the exchange by its ID using a database function, then checks if the chat and exchange exist in the session state and removes the exchange if found. Finally, it triggers a rerun of the Streamlit app to update the UI.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is to be removed."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_exchange_by_id",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The function handle_delete_chat is responsible for deleting a specified chat for a given user. It first removes the chat from the database using delete_full_chat, then cleans up the session state by removing the chat from st.session_state.chats. If there are remaining chats, it sets the first one as the active chat; otherwise, it creates a new default chat named 'Chat 1' and sets it as active. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.delete_full_chat, database.db.insert_chat",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from a URL found within that text. It uses regular expressions to find a URL pattern, parses the URL to extract the path component, and then retrieves the last segment of the path as the repository name. If the repository name ends with '.git', it removes the extension. If no URL is found or the path is empty, it returns None.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string that may contain a URL from which to extract the repository name."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str",
            "description": "The extracted repository name from the URL, with '.git' suffix removed if present."
          },
          {
            "name": "None",
            "type": "NoneType",
            "description": "Returned when no URL is found in the input text or when the URL path is empty."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The function 'stream_text_generator' takes a string input and yields each word from the string followed by a space, with a small delay between each yield. It is designed to simulate a streaming effect for text output. The function splits the input text into words based on spaces and iterates through them, yielding one word at a time with a short pause.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "A string input containing the text to be streamed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text by Mermaid code blocks and renders regular markdown content using Streamlit's markdown functionality. When a Mermaid diagram is detected, it attempts to render it using the st_mermaid component; if rendering fails, it falls back to displaying the code as a monospace block.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "A string containing markdown-formatted text that may include Mermaid diagram code blocks enclosed in triple backticks with 'mermaid' language specifier."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A boolean flag indicating whether to stream the rendered text content using Streamlit's write_stream functionality."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The function 'render_exchange' renders a chat exchange in a Streamlit interface, displaying a user's question and an assistant's response. It handles both normal responses and error messages differently, showing error messages directly with a styled error component and providing feedback options for normal responses. The function also includes UI elements for deleting exchanges, downloading responses, and adding notes to exchanges.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing the exchange data including the question, answer, and metadata such as '_id' and 'feedback'."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat session, used for handling exchange deletion."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, frontend.frontend.render_text_with_mermaid",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_provider": {
      "identifier": "frontend.frontend.get_provider",
      "description": {
        "overall": "The function 'get_provider' determines the provider name based on the given model name. It evaluates the model name against specific conditions using string matching methods such as 'startswith' and equality checks. The function returns different provider strings depending on whether the model name matches certain prefixes or exact values.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string representing the name of the model for which the provider needs to be identified."
          }
        ],
        "returns": [
          {
            "name": "provider",
            "type": "str",
            "description": "A string indicating the provider associated with the given model name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.config_provider": {
      "identifier": "frontend.frontend.config_provider",
      "description": {
        "overall": "The `config_provider` function handles the configuration interface for different AI models within a Streamlit-based frontend. It dynamically displays settings forms based on the provided `model_name` and updates corresponding database entries when users submit changes. The function checks for the existence of various keys and URLs, displaying appropriate status indicators and allowing users to modify these configurations through interactive UI elements.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "A string identifier indicating which AI model's configuration is being managed."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "database.db.update_gemini_key, database.db.update_gpt_key, database.db.update_ollama_url, database.db.update_opensrc_key, database.db.update_opensrc_url",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.check_stop_callback": {
      "identifier": "frontend.frontend.check_stop_callback",
      "description": {
        "overall": "This function is designed to check whether the user has requested to abort a process by querying the Streamlit session state. It retrieves a boolean flag indicating if the 'abort_requested' key is set to True. The function serves as a callback mechanism for the backend to determine if the user has pressed a stop button.",
        "parameters": [],
        "returns": [
          {
            "name": "return_value",
            "type": "bool",
            "description": "A boolean value indicating whether the user has requested to abort the process. Returns True if 'abort_requested' is set to True in the session state, otherwise returns False."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {
    "backend.AST_Schema.ASTVisitor": {
      "identifier": "backend.AST_Schema.ASTVisitor",
      "description": {
        "overall": "The ASTVisitor class is designed to traverse an Abstract Syntax Tree (AST) generated from Python source code. It collects information about imports, classes, and functions, organizing them into a structured schema. The visitor tracks the current class during traversal to associate methods with their respective classes. It leverages the standard `ast.NodeVisitor` base class to implement custom visitation logic for different AST node types.",
        "init_method": {
          "description": "Initializes the ASTVisitor with source code, file path, and project root. It computes the module path using a helper function and sets up an initial schema structure to store collected information including imports, functions, and classes. It also initializes a variable to track the currently visited class.",
          "parameters": [
            {
              "name": "source_code",
              "type": "str",
              "description": "The full source code string being analyzed."
            },
            {
              "name": "file_path",
              "type": "str",
              "description": "The file path of the source code being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import nodes in the AST by extracting the names of imported modules and appending them to the schema's imports list. It ensures that all import aliases are captured and added to the schema before proceeding with the generic visit.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering an import node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes import-from nodes in the AST by extracting module and alias information and appending them to the schema's imports list. It constructs full qualified names for the imports and adds them to the schema before continuing the traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST node representing an import-from statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering an import-from node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles class definition nodes in the AST by creating a structured representation of the class, including its identifier, name, docstring, source code segment, and line numbers. It appends this information to the schema's classes list and tracks the current class during traversal. After visiting child nodes, it resets the current class tracker.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering a class definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes function definition nodes in the AST. If a class is currently being visited, it associates the function with that class by creating a method context entry. Otherwise, it treats the function as a top-level function and creates a function info entry. It captures function arguments, docstrings, and source code segments, adding them to the appropriate part of the schema.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions directly.",
                "called_by": "This method is called by the AST traversal mechanism when encountering a function definition node."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles asynchronous function definition nodes in the AST by delegating the processing to the regular function definition handler. This allows async functions to be treated similarly to regular functions in terms of schema collection.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST node representing an asynchronous function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method delegates to visit_FunctionDef.",
                "called_by": "This method is called by the AST traversal mechanism when encountering an async function definition node."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.AST_Schema.path_to_module for computing module paths.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.AST_Schema.ASTAnalyzer": {
      "identifier": "backend.AST_Schema.ASTAnalyzer",
      "description": {
        "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Trees (ASTs) and building a structured schema that includes information about imports, functions, classes, and their relationships. It merges relationship data such as outgoing calls, incoming calls, dependencies, and instantiation contexts into the schema. The class also handles error cases during parsing and ensures proper handling of file paths and project roots.",
        "init_method": {
          "description": "The constructor for ASTAnalyzer does not initialize any instance variables and simply passes.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "merge_relationship_data",
            "description": {
              "overall": "This method takes a full schema and raw relationship data, then enriches the schema with contextual information such as outgoing and incoming calls for functions and classes, and tracks dependencies for class methods. It updates the schema in-place by adding call and called_by information to functions and methods, and computes class dependencies based on method calls.",
              "parameters": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary representing the full schema of the repository, including file structures and AST nodes."
                },
                {
                  "name": "raw_relationships",
                  "type": "dict",
                  "description": "A dictionary containing raw relationship data with keys 'outgoing' and 'incoming', mapping identifiers to lists of related items."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "The updated schema with enriched relationship data added to functions, classes, and methods."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_repository",
            "description": {
              "overall": "This method analyzes a list of Python files within a Git repository, parses their content into ASTs, and builds a schema representation of each file's structure. It uses an ASTVisitor to traverse the AST and extract relevant information like imports, functions, and classes. The resulting schema is returned, including only those files that are valid Python files and can be parsed without errors.",
              "parameters": [
                {
                  "name": "files",
                  "type": "list",
                  "description": "A list of file objects containing path and content information for Python files."
                },
                {
                  "name": "repo",
                  "type": "GitRepository",
                  "description": "An object representing the Git repository being analyzed."
                }
              ],
              "returns": [
                {
                  "name": "full_schema",
                  "type": "dict",
                  "description": "A dictionary containing the schema of the repository, organized by file paths and including AST node information."
                }
              ],
              "usage_context": {
                "calls": "This method calls the backend.AST_Schema.ASTVisitor class to parse and visit AST nodes.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.AST_Schema.ASTVisitor class for parsing and visiting AST nodes.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.File_Dependency.FileDependencyGraph": {
      "identifier": "backend.File_Dependency.FileDependencyGraph",
      "description": {
        "overall": "The FileDependencyGraph class is designed to analyze and resolve Python import dependencies within a repository. It extends NodeVisitor to traverse AST nodes representing import statements, distinguishing between absolute and relative imports. The class resolves relative imports by mapping them to actual module or symbol names based on the repository structure and handles various edge cases such as missing files or invalid import paths. It maintains a dictionary of import dependencies for each file.",
        "init_method": {
          "description": "Initializes the FileDependencyGraph with a filename and repository root path. Sets up the instance variables to track the current file being processed and the root directory of the repository.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the file being analyzed for dependencies."
            },
            {
              "name": "repo_root",
              "type": "Any",
              "description": "The root directory path of the repository being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_resolve_module_name",
            "description": {
              "overall": "Resolves relative import statements by analyzing the import node and determining the actual module or symbol names that correspond to the import. It checks for matching files or symbols in the repository structure and raises an ImportError if resolution fails.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a relative import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of resolved module or symbol names."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles import statements by adding the imported module names to the import dependencies dictionary. It ensures that the dependencies are tracked for the current file being analyzed.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import | ImportFrom",
                  "description": "An AST node representing an import statement."
                },
                {
                  "name": "base_name",
                  "type": "str | None",
                  "description": "Optional base name for the import."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes 'from ... import ...' style import statements. It extracts the module name and either uses it directly or resolves relative imports using the _resolve_module_name method. It updates the import dependencies accordingly.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "An AST node representing a 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is not called by any other method in the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.File_Dependency.get_all_temp_files, backend.File_Dependency.init_exports_symbol, and backend.File_Dependency.module_file_exists.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.HelperLLM.LLMHelper": {
      "identifier": "backend.HelperLLM.LLMHelper",
      "description": {
        "overall": "The LLMHelper class serves as a centralized interface for interacting with various Large Language Models (LLMs) such as Google Gemini, OpenAI, and custom APIs. It handles API configuration, prompt loading, batching logic, and structured output validation using Pydantic models. The class supports generating documentation for both functions and classes by processing inputs through configured LLMs with appropriate batch sizes and rate-limiting.",
        "init_method": {
          "description": "Initializes the LLMHelper with API credentials, prompt file paths, and model configuration. It loads system prompts from specified files, configures batch settings based on the selected model, and sets up different LLM clients depending on the model type (e.g., Google, OpenAI, Ollama). It also prepares structured output validators for function and class analysis.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "API key used to authenticate with the LLM provider."
            },
            {
              "name": "function_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for function documentation generation."
            },
            {
              "name": "class_prompt_path",
              "type": "str",
              "description": "File path to the system prompt used for class documentation generation."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "Name of the LLM model to use. Defaults to 'gemini-2.0-flash-lite'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Base URL for custom LLM endpoints. Optional."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_configure_batch_settings",
            "description": {
              "overall": "Configures the batch size for processing requests based on the selected LLM model. Different models have predefined batch sizes to optimize performance and avoid exceeding rate limits. If the model is unknown, a default conservative batch size is applied.",
              "parameters": [
                {
                  "name": "model_name",
                  "type": "str",
                  "description": "Name of the LLM model being used."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method is called internally during initialization to determine the appropriate batch size for the given model.",
                "called_by": "Called by the __init__ method of the LLMHelper class."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_functions",
            "description": {
              "overall": "Processes a batch of function inputs to generate and validate documentation using the configured LLM. It splits inputs into batches according to the configured batch size, sends them to the LLM, and collects validated results. In case of errors, it fills the result list with None values to preserve order.",
              "parameters": [
                {
                  "name": "function_inputs",
                  "type": "List[FunctionAnalysisInput]",
                  "description": "A list of function input models to process."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[FunctionAnalysis]]",
                  "description": "A list of validated function analysis outputs or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method uses internal LLM clients and performs JSON serialization of inputs before sending them to the LLM.",
                "called_by": "This method is intended to be called externally to generate documentation for functions."
              }
            },
            "error": null
          },
          {
            "identifier": "generate_for_classes",
            "description": {
              "overall": "Processes a batch of class inputs to generate and validate documentation using the configured LLM. Similar to generate_for_functions, it batches inputs, sends them to the LLM, and collects validated results. Errors result in None entries to maintain alignment with input order.",
              "parameters": [
                {
                  "name": "class_inputs",
                  "type": "List[ClassAnalysisInput]",
                  "description": "A list of class input models to process."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "List[Optional[ClassAnalysis]]",
                  "description": "A list of validated class analysis outputs or None for failed items."
                }
              ],
              "usage_context": {
                "calls": "This method uses internal LLM clients and performs JSON serialization of inputs before sending them to the LLM.",
                "called_by": "This method is intended to be called externally to generate documentation for classes."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several external libraries including langchain components for LLM integration, Pydantic models for input/output validation, and standard Python modules like os, json, logging, and time.",
          "instantiated_by": "This class is instantiated by other components within the backend.HelperLLM module but is not directly instantiated elsewhere as per the provided context."
        }
      },
      "error": null
    },
    "backend.MainLLM.MainLLM": {
      "identifier": "backend.MainLLM.MainLLM",
      "description": {
        "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs). It supports multiple model types including Google's Gemini models, OpenAI's GPT models, custom API endpoints, and local Ollama models. The class initializes with an API key, a path to a system prompt file, and optional model configuration parameters. It dynamically selects and configures the appropriate LLM client based on the specified model name and environment settings. The class provides two core functionalities: synchronous execution via 'call_llm' and streaming responses via 'stream_llm'. Both methods utilize a system prompt loaded from a file and send user input as a human message to the configured LLM.",
        "init_method": {
          "description": "Initializes the MainLLM instance by validating the API key, loading the system prompt from a file, and configuring the appropriate LLM client based on the model name and environment variables. It supports different LLM backends such as Google Generative AI, OpenAI-compatible APIs, and Ollama.",
          "parameters": [
            {
              "name": "api_key",
              "type": "str",
              "description": "The API key used for authenticating with the LLM service."
            },
            {
              "name": "prompt_file_path",
              "type": "str",
              "description": "The file path to the system prompt used for initializing the LLM."
            },
            {
              "name": "model_name",
              "type": "str",
              "description": "The name of the model to use. Defaults to 'gemini-2.5-pro'."
            },
            {
              "name": "base_url",
              "type": "str",
              "description": "Optional base URL for connecting to a custom LLM endpoint."
            }
          ]
        },
        "methods": [
          {
            "identifier": "call_llm",
            "description": {
              "overall": "Executes a synchronous call to the configured LLM with the provided user input. It constructs a message sequence including the system prompt and the user input, sends it to the LLM, and returns the content of the response. If an error occurs during the call, it logs the error and returns None.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "response_content",
                  "type": "str",
                  "description": "The content of the LLM's response, or None if an error occurred."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods directly.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "stream_llm",
            "description": {
              "overall": "Initiates a streaming call to the configured LLM with the provided user input. It constructs a message sequence including the system prompt and the user input, sends it to the LLM, and yields chunks of the response content as they become available. If an error occurs during the stream, it logs the error and yields an error message.",
              "parameters": [
                {
                  "name": "user_input",
                  "type": "str",
                  "description": "The input text provided by the user to be processed by the LLM."
                }
              ],
              "returns": [
                {
                  "name": "chunk_content",
                  "type": "str",
                  "description": "Yields content chunks from the LLM's streaming response, or an error message if an exception occurs."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods directly.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were explicitly listed in the context.",
          "instantiated_by": "No instantiation details were provided in the context."
        }
      },
      "error": null
    },
    "backend.basic_info.ProjektInfoExtractor": {
      "identifier": "backend.basic_info.ProjektInfoExtractor",
      "description": {
        "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It initializes with a structured dictionary to hold extracted information and provides methods to parse and extract data from these files. The class prioritizes information extraction from pyproject.toml, followed by requirements.txt, and finally README files. It handles encoding issues by cleaning content and supports case-insensitive file matching. The extracted information includes project overview details like title, description, status, features, and technology stack, as well as installation-related information such as dependencies, setup instructions, and quick start guides.",
        "init_method": {
          "description": "Initializes the ProjektInfoExtractor with a predefined structure for storing project information. It sets up placeholder values for various project details and defines a constant for indicating missing information.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "_clean_content",
            "description": {
              "overall": "This method removes null bytes from content, which can occur due to encoding errors when reading files as UTF-8 instead of UTF-16. It ensures that the content is clean before further processing.",
              "parameters": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The string content to be cleaned of null bytes."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "str",
                  "description": "The cleaned string with null bytes removed."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by other parsing methods within the class to clean content before processing."
              }
            },
            "error": null
          },
          {
            "identifier": "_finde_datei",
            "description": {
              "overall": "This method searches for a file among a list of files based on a set of patterns. It performs a case-insensitive search to find a file whose path ends with one of the specified patterns.",
              "parameters": [
                {
                  "name": "patterns",
                  "type": "List[str]",
                  "description": "A list of file extension patterns to match against file paths."
                },
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[Any]",
                  "description": "The matched file object or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the main extraction method to locate relevant project files such as README, pyproject.toml, and requirements.txt."
              }
            },
            "error": null
          },
          {
            "identifier": "_extrahiere_sektion_aus_markdown",
            "description": {
              "overall": "This method extracts text sections from a markdown document that appear under specific headings (marked with ##). It uses regular expressions to identify the heading and capture the subsequent content until the next heading or end of the document.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The markdown content to extract sections from."
                },
                {
                  "name": "keywords",
                  "type": "List[str]",
                  "description": "A list of keywords representing section headings to look for."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Optional[str]",
                  "description": "The extracted text content under the specified heading, or None if no match is found."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "This method is called by the README parser to extract specific sections like Features, Tech Stack, Status, Installation, and Quick Start."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_readme",
            "description": {
              "overall": "This method parses the content of a README file to extract project overview and installation information. It identifies the project title, description, key features, tech stack, current status, setup instructions, and quick start guide using regex and helper methods.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the README file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to clean the input content and _extrahiere_sektion_aus_markdown to extract specific sections.",
                "called_by": "This method is called by the main extraction method to process README files."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_toml",
            "description": {
              "overall": "This method parses the content of a pyproject.toml file to extract project metadata such as name, description, and dependencies. It checks for the availability of the tomllib module and handles potential parsing errors gracefully.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the pyproject.toml file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to clean the input content and handles exceptions related to TOML parsing.",
                "called_by": "This method is called by the main extraction method to process pyproject.toml files."
              }
            },
            "error": null
          },
          {
            "identifier": "_parse_requirements",
            "description": {
              "overall": "This method parses the content of a requirements.txt file to extract dependency information. It only populates dependencies if they haven't already been set by a previous parsing step, such as from a pyproject.toml file.",
              "parameters": [
                {
                  "name": "inhalt",
                  "type": "str",
                  "description": "The content of the requirements.txt file to parse."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "Calls _clean_content to clean the input content.",
                "called_by": "This method is called by the main extraction method to process requirements.txt files."
              }
            },
            "error": null
          },
          {
            "identifier": "extrahiere_info",
            "description": {
              "overall": "This method orchestrates the entire information extraction process. It finds relevant project files, parses them in order of priority (pyproject.toml, requirements.txt, README), formats the extracted dependencies, and derives a project title from the repository URL if needed.",
              "parameters": [
                {
                  "name": "dateien",
                  "type": "List[Any]",
                  "description": "A list of file objects to search through for project information."
                },
                {
                  "name": "repo_url",
                  "type": "str",
                  "description": "The URL of the repository, used to derive a project title if none is found."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "Dict[str, Any]",
                  "description": "A dictionary containing the extracted project information organized into project overview and installation sections."
                }
              ],
              "usage_context": {
                "calls": "Calls _finde_datei to locate relevant files, _parse_toml, _parse_requirements, and _parse_readme to process the files, and also uses os.path.basename and os.path.removesuffix for URL processing.",
                "called_by": "This method is the main interface for extracting project information and is likely called by higher-level components in the application."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class depends on standard library modules including re, os, and tomllib, as well as typing annotations from typing.List, typing.Dict, typing.Any, and typing.Optional.",
          "instantiated_by": "The class is instantiated by unknown components in the application, as indicated by an empty instantiated_by list in the context."
        }
      },
      "error": null
    },
    "backend.callgraph.CallGraph": {
      "identifier": "backend.callgraph.CallGraph",
      "description": {
        "overall": "The CallGraph class is a visitor for Python Abstract Syntax Tree (AST) nodes that builds a directed graph representing function call relationships within a Python file. It tracks local definitions, imports, and class contexts to resolve function names and construct edges between callers and callees. The class uses NetworkX to maintain the graph structure and supports both synchronous and asynchronous function definitions.",
        "init_method": {
          "description": "Initializes the CallGraph with a filename and sets up internal data structures including tracking for current function and class, local definitions, a NetworkX graph, import mappings, and a set of function names.",
          "parameters": [
            {
              "name": "filename",
              "type": "str",
              "description": "The name of the Python file being analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_recursive_call",
            "description": {
              "overall": "Recursively extracts the dotted name components from an AST node representing a function call. It traverses the AST to build a list of name parts, handling different node types like Name, Attribute, and Call.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "An AST node representing a function call or attribute access."
                }
              ],
              "returns": [
                {
                  "name": "parts",
                  "type": "list[str]",
                  "description": "A list of string components forming a dotted name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the _resolve_all_callee_names method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_all_callee_names",
            "description": {
              "overall": "Resolves a list of dotted name components into fully qualified names by checking local definitions, import mappings, and constructing appropriate names based on the current class context.",
              "parameters": [
                {
                  "name": "callee_nodes",
                  "type": "list[list[str]]",
                  "description": "A list of lists containing name components for potential callees."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "list[str]",
                  "description": "A list of fully qualified names for the callees."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "_make_full_name",
            "description": {
              "overall": "Constructs a fully qualified name for a function, optionally including a class prefix, using the filename and provided base name.",
              "parameters": [
                {
                  "name": "basename",
                  "type": "str",
                  "description": "The base name of the function."
                },
                {
                  "name": "class_name",
                  "type": "str | None",
                  "description": "Optional class name to prefix the function name."
                }
              ],
              "returns": [
                {
                  "name": "full_name",
                  "type": "str",
                  "description": "A fully qualified name constructed from the filename, class name (if provided), and base name."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_FunctionDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_current_caller",
            "description": {
              "overall": "Determines the current caller's name, either from the current function context or defaults to a global scope identifier.",
              "parameters": [],
              "returns": [
                {
                  "name": "caller",
                  "type": "str",
                  "description": "The name of the current caller."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST Import nodes by mapping aliases to their actual module names and storing them in the import mapping dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "An AST Import node representing an import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversal.",
                "called_by": "This method is called during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles AST ImportFrom nodes by mapping aliases to their respective modules and storing them in the import mapping dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "An AST ImportFrom node representing a relative or absolute import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other methods.",
                "called_by": "This method is called during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles AST ClassDef nodes by temporarily setting the current class context during traversal, allowing proper resolution of function names within class scopes.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "An AST ClassDef node representing a class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversal.",
                "called_by": "This method is called during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Handles AST FunctionDef nodes by registering the function in local definitions, adding it to the graph, and managing the current function context during traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "An AST FunctionDef node representing a function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls _make_full_name and generic_visit to continue traversal.",
                "called_by": "This method is called during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles AST AsyncFunctionDef nodes by delegating to visit_FunctionDef since async functions are treated similarly to regular functions in terms of call graph construction.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.AsyncFunctionDef",
                  "description": "An AST AsyncFunctionDef node representing an async function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls visit_FunctionDef to handle the function definition.",
                "called_by": "This method is called during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Handles AST Call nodes by identifying the caller and resolving the callee names, then adds edges to the graph representing the call relationship.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "An AST Call node representing a function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls _recursive_call, _resolve_all_callee_names, and _current_caller to determine the call relationship, and generic_visit to continue traversal.",
                "called_by": "This method is called during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_If",
            "description": {
              "overall": "Handles AST If nodes by detecting main block conditions and temporarily changing the current function context to '<main_block>' during traversal of such blocks.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.If",
                  "description": "An AST If node representing an if statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversal.",
                "called_by": "This method is called during AST traversal."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the ast module for parsing Python code and networkx for graph representation.",
          "instantiated_by": "This class is not directly instantiated by any other classes mentioned in the context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.call_resolver.CallResolver": {
      "identifier": "backend.diagram_generation.call_resolver.CallResolver",
      "description": {
        "overall": "The CallResolver class is responsible for resolving raw function calls in a project into their resolved counterparts by analyzing the call context, including direct calls, imported functions, method calls, and dynamic lookups. It uses a ProjectIndex to access module and class information to determine the actual targets of these calls.",
        "init_method": {
          "description": "Initializes the CallResolver with a ProjectIndex which provides access to modules and classes in the project for resolving function calls.",
          "parameters": [
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "An index of the project's modules and classes used to resolve function calls."
            }
          ]
        },
        "methods": [
          {
            "identifier": "resolve_all",
            "description": {
              "overall": "Processes a dictionary of raw calls grouped by module and resolves each call into a list of resolved calls. It iterates through the provided calls and accumulates resolved calls per module.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "dict[str, list[RawCall]]",
                  "description": "A mapping of module names to lists of raw call objects to be resolved."
                }
              ],
              "returns": [
                {
                  "name": "resolved",
                  "type": "dict[str, list[ResolvedCall]]",
                  "description": "A mapping of module names to lists of resolved call objects."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods within the class.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "resolved",
            "description": {
              "overall": "Resolves a single raw call by determining the type of function node (Name or Attribute) and delegating to appropriate resolution methods. If the node type is neither Name nor Attribute, it returns an unknown call type.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call object to be resolved."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved call objects based on the type of the function node."
                }
              ],
              "usage_context": {
                "calls": "This method calls the internal methods `_resolve_name` and `_resolve_attribute` depending on the type of the function node.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_name",
            "description": {
              "overall": "Resolves a raw call when the function node is an ast.Name. It checks if the name corresponds to a function in the current module or an import alias, and constructs a resolved call accordingly.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call object containing the function node."
                },
                {
                  "name": "node",
                  "type": "ast.Name",
                  "description": "The AST node representing the function name."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved call objects for direct or imported function calls."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods within the class.",
                "called_by": "This method is called by the `resolved` method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_attribute",
            "description": {
              "overall": "Resolves a raw call when the function node is an ast.Attribute. It handles method calls on 'self', imports, and dynamic lookups across all classes in the project to find matching function definitions.",
              "parameters": [
                {
                  "name": "call",
                  "type": "RawCall",
                  "description": "The raw call object containing the attribute node."
                },
                {
                  "name": "node",
                  "type": "ast.Attribute",
                  "description": "The AST node representing the attribute-based function call."
                }
              ],
              "returns": [
                {
                  "name": "resolved_calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of resolved call objects for method or imported function calls, or dynamic lookups."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods within the class.",
                "called_by": "This method is called by the `resolved` method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several data types and structures such as CallType, RawCall, ResolvedCall, and ProjectIndex.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.callgraph.TreeVisitor": {
      "identifier": "backend.diagram_generation.callgraph.TreeVisitor",
      "description": {
        "overall": "The TreeVisitor class is designed to traverse an Abstract Syntax Tree (AST) to extract call relationships between functions and methods within a Python project. It extends NodeVisitor to customize traversal behavior for ClassDef, FunctionDef, and Call nodes. During traversal, it maintains context about the current class and function being processed, enabling accurate tracking of function calls. The extracted call information is stored in a list of RawCall objects which can later be used to generate call graphs.",
        "init_method": {
          "description": "Initializes the TreeVisitor with a module symbol and a project index. It sets up internal state variables including references to the current function and class, and initializes an empty list to store call information.",
          "parameters": [
            {
              "name": "module",
              "type": "ModuleSymbol",
              "description": "The module symbol representing the current module being visited."
            },
            {
              "name": "project",
              "type": "ProjectIndex",
              "description": "The project index containing information about all modules in the project."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles the traversal of class definitions in the AST. It saves the previous class context, updates the current class to the one being visited, processes the class definition recursively, and restores the previous class context afterward.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The AST node representing the class definition being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other functions besides generic_visit.",
                "called_by": "This method is called by the AST visitor framework during tree traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Handles the traversal of function definitions in the AST. It manages the context of the current function by saving the previous function, setting the new function based on whether we're inside a class or at the module level, processes the function definition recursively, and restores the previous function context.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing the function definition being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other functions besides generic_visit.",
                "called_by": "This method is called by the AST visitor framework during tree traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Processes call expressions in the AST. It checks if there is a current function context, determines if the called function is valid (either a module-level function or a method in a class), and if so, creates a RawCall object with relevant context information and appends it to the calls list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Call",
                  "description": "The AST node representing the function call being visited."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls generic_visit to continue traversing the AST subtree and also constructs RawCall and CallContext objects.",
                "called_by": "This method is called by the AST visitor framework during tree traversal."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were specified.",
          "instantiated_by": "No instantiation locations were specified."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.FunctionSymbol": {
      "identifier": "backend.diagram_generation.data_types.FunctionSymbol",
      "description": {
        "overall": "The FunctionSymbol class is a data structure designed to represent a function symbol in a diagram generation context. It encapsulates essential metadata about a function, including its name, module, qualified name, whether it is asynchronous, input parameters, return type indicator, and line number. This class serves as a lightweight container for function-related information, likely used during static analysis or visualization processes.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, relying instead on default initialization behavior for its attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond standard Python typing and dataclass utilities.",
          "instantiated_by": "This class is not instantiated by any other components as indicated by the context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ClassSymbol": {
      "identifier": "backend.diagram_generation.data_types.ClassSymbol",
      "description": {
        "overall": "The ClassSymbol class represents a symbolic representation of a class within a diagram generation system. It encapsulates essential metadata about a class, including its name, module of origin, and a collection of its methods represented as FunctionSymbol objects. This class serves as a data carrier for class-level information used during the diagram generation process.",
        "init_method": {
          "description": "The constructor for ClassSymbol does not explicitly define any parameters beyond the default self. It relies on class variables to store the name, module, and methods of the class.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on external modules such as ast.expr, dataclasses.dataclass, enum.Enum, and typing.Optional, which are likely used for type annotations and data handling.",
          "instantiated_by": "The class is not instantiated by any other component as indicated by the empty instantiated_by list."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ModuleSymbol": {
      "identifier": "backend.diagram_generation.data_types.ModuleSymbol",
      "description": {
        "overall": "The ModuleSymbol class represents a module in a Python codebase, encapsulating metadata about the module such as its name, the packages it belongs to, and its constituent elements like functions, classes, and imports. It serves as a data structure for organizing and storing information related to modules during diagram generation processes.",
        "init_method": {
          "description": "The ModuleSymbol class does not define an explicit __init__ method. As a result, it relies on default initialization behavior, likely through dataclass decorators or similar mechanisms not visible in the provided source code.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies listed.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallContext": {
      "identifier": "backend.diagram_generation.data_types.CallContext",
      "description": {
        "overall": "The CallContext class is a data structure designed to hold symbolic references to a module, function, and optionally a class. It serves as a container for contextual information related to a call site within a codebase, particularly useful in diagram generation tools where tracking the origin and scope of function calls is essential.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, relying instead on dataclass-style attribute definitions. It initializes with three attributes: module, function, and classes, which are expected to be instances of ModuleSymbol, FunctionSymbol, and ClassSymbol respectively.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were identified for this class.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.RawCall": {
      "identifier": "backend.diagram_generation.data_types.RawCall",
      "description": {
        "overall": "The RawCall class is a data structure designed to represent a call to a function within a program, capturing essential metadata such as the caller, the function node, line number, and context. It serves as a lightweight container for storing information about function calls during diagram generation processes.",
        "init_method": {
          "description": "The RawCall class does not define an explicit __init__ method, relying instead on dataclass-style initialization based on the declared attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies beyond standard library imports including ast.expr, dataclasses.dataclass, enum.Enum, and typing.Optional.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.CallType": {
      "identifier": "backend.diagram_generation.data_types.CallType",
      "description": {
        "overall": "The CallType class is an enumeration that defines various types of method or function calls within a codebase. It provides a standardized way to categorize calls into distinct types such as direct, method, imported, dynamic, and unknown. This enum is useful for representing and differentiating call semantics in diagram generation or static analysis tools.",
        "init_method": {
          "description": "The CallType class is initialized as an Enum with predefined string values representing different call types. No explicit initialization parameters are required as the enum values are defined directly in the class body.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "DIRECT",
            "description": {
              "overall": "The DIRECT call type represents a direct call to a function or method within the same module or scope. This is typically used when analyzing code to distinguish between direct invocations and other forms of calls like method calls or imports.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods."
              }
            },
            "error": null
          },
          {
            "identifier": "METHOD",
            "description": {
              "overall": "The METHOD call type indicates a call made to a method of an object, typically represented as obj.method(). This is used to classify calls that involve object-oriented method invocation patterns.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods."
              }
            },
            "error": null
          },
          {
            "identifier": "IMPORTED",
            "description": {
              "overall": "The IMPORTED call type signifies a call to a function or method that is imported from another module or library. This helps in identifying external dependencies and cross-module interactions in code analysis.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods."
              }
            },
            "error": null
          },
          {
            "identifier": "DYNAMIC",
            "description": {
              "overall": "The DYNAMIC call type represents calls that are determined at runtime, such as those involving dynamic dispatch or reflection. These calls cannot be statically analyzed and may involve complex runtime behavior.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods."
              }
            },
            "error": null
          },
          {
            "identifier": "UNKNOWN",
            "description": {
              "overall": "The UNKNOWN call type serves as a fallback category for calls that cannot be definitively classified into one of the other categories. This is useful for handling ambiguous or unanalyzable call patterns during static analysis.",
              "parameters": [],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond standard Python enum functionality.",
          "instantiated_by": "This class is not instantiated by any other components based on the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ResolvedCall": {
      "identifier": "backend.diagram_generation.data_types.ResolvedCall",
      "description": {
        "overall": "The ResolvedCall class is a data structure designed to represent a resolved function call within a diagram generation system. It encapsulates information about the caller, the callee (if available), the type of call, and the line number where the call occurs. This class serves as a lightweight container for storing and passing around details related to function calls during the analysis and visualization process.",
        "init_method": {
          "description": "The ResolvedCall class does not define an explicit __init__ method. Instead, it relies on dataclass-style attribute definitions to initialize its fields. The constructor implicitly initializes the caller, callee, call_type, and lineno attributes based on the provided values during instantiation.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any other components."
        }
      },
      "error": null
    },
    "backend.diagram_generation.data_types.ProjectIndex": {
      "identifier": "backend.diagram_generation.data_types.ProjectIndex",
      "description": {
        "overall": "The ProjectIndex class serves as a container for managing project modules and their associated symbols, particularly focusing on retrieving all classes across the modules. It maintains a dictionary of modules indexed by their names and provides a method to flatten and collect all class symbols from these modules.",
        "init_method": {
          "description": "Initializes the ProjectIndex with a dictionary of modules. The constructor does not take any explicit parameters beyond the implicit 'self', and relies on the 'modules' attribute being set externally or through other mechanisms.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "all_classes",
            "description": {
              "overall": "The all_classes method retrieves all ClassSymbol instances from the modules stored in the ProjectIndex. It iterates over each module in the modules dictionary and then iterates over each class in the module's classes dictionary, collecting all class symbols into a flat list.",
              "parameters": [
                {
                  "name": "self",
                  "type": "ProjectIndex",
                  "description": "The instance of the ProjectIndex class."
                }
              ],
              "returns": [
                {
                  "name": "return",
                  "type": "list[ClassSymbol]",
                  "description": "A list containing all ClassSymbol instances from all modules in the ProjectIndex."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies were specified for this class.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidSequenceEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidSequenceEmitter",
      "description": {
        "overall": "The MermaidSequenceEmitter class is responsible for generating Mermaid sequence diagram representations from a list of resolved calls. It collects participants, emits call interactions, and handles responses, producing a formatted string that can be rendered as a Mermaid diagram. The class leverages helper functions like mermaid_id to format identifiers correctly.",
        "init_method": {
          "description": "The class does not define an explicit constructor (__init__ method). It relies on default initialization behavior.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a Mermaid sequence diagram by processing a list of ResolvedCall objects. It starts with a Mermaid code block header, adds participants based on collected identifiers, sorts calls by line number, and appends each call and its response if applicable. Finally, it closes the code block and returns the complete diagram as a string.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects representing function calls and their metadata."
                }
              ],
              "returns": [
                {
                  "name": "return",
                  "type": "str",
                  "description": "A string containing the complete Mermaid sequence diagram code."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_participants",
            "description": {
              "overall": "The _collect_participants method gathers unique participant identifiers from a list of ResolvedCall objects. It ensures both callers and callees are included in the participants list, using mermaid_id to format names appropriately. If a callee is missing, it appends a placeholder '?' to the list.",
              "parameters": [
                {
                  "name": "calls",
                  "type": "list[ResolvedCall]",
                  "description": "A list of ResolvedCall objects from which to extract participant identifiers."
                }
              ],
              "returns": [
                {
                  "name": "return",
                  "type": "list[str]",
                  "description": "A list of formatted participant identifiers for the Mermaid diagram."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.diagram_generation.emitter.mermaid_id to format participant names.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_response",
            "description": {
              "overall": "The _emit_response method generates a Mermaid notation line representing a return statement from a callee back to a caller. It uses mermaid_id to format both identifiers and constructs a line indicating the direction of the return message.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A ResolvedCall object representing a function call with a callee that has a return symbol."
                }
              ],
              "returns": [
                {
                  "name": "return",
                  "type": "str",
                  "description": "A formatted string representing the return message in Mermaid syntax."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.diagram_generation.emitter.mermaid_id to format the callee and caller identifiers.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_emit_call",
            "description": {
              "overall": "The _emit_call method formats a ResolvedCall object into a Mermaid sequence diagram line showing a call from a caller to a callee. It includes input parameters in the call label and handles cases where the callee is unknown by using a placeholder '?'.",
              "parameters": [
                {
                  "name": "call",
                  "type": "ResolvedCall",
                  "description": "A ResolvedCall object representing a function call with caller and callee information."
                }
              ],
              "returns": [
                {
                  "name": "return",
                  "type": "str",
                  "description": "A formatted string representing the call interaction in Mermaid syntax."
                }
              ],
              "usage_context": {
                "calls": "This method calls backend.diagram_generation.emitter.mermaid_id to format the caller and callee identifiers.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.diagram_generation.emitter.mermaid_id function for formatting identifiers.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidOverviewArchitectureEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidOverviewArchitectureEmitter",
      "description": {
        "overall": "The MermaidOverviewArchitectureEmitter class is responsible for generating a Mermaid diagram representation of the architectural overview of modules within a system. It takes a dictionary of ModuleSymbol objects and produces a string formatted in Mermaid's graph syntax, showing dependencies between modules based on their imports.",
        "init_method": {
          "description": "The class does not define an explicit constructor (__init__ method), so it inherits the default initialization behavior from the base object class.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a Mermaid graph representation of module dependencies. It iterates over the provided modules, extracts source and destination module names, and constructs directional edges representing import relationships between modules. The resulting graph is returned as a formatted string.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary mapping module names to ModuleSymbol objects, which contain information about module imports."
                }
              ],
              "returns": [
                {
                  "name": "str",
                  "type": "str",
                  "description": "A string containing the Mermaid-formatted graph representation of module dependencies."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other functions or methods according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class does not depend on any external libraries or modules beyond those specified in the imports list.",
          "instantiated_by": "This class is not instantiated by any other classes or functions according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.MermaidClassDiagramEmitter": {
      "identifier": "backend.diagram_generation.emitter.MermaidClassDiagramEmitter",
      "description": {
        "overall": "The MermaidClassDiagramEmitter class is responsible for generating a Mermaid.js class diagram representation from a collection of module symbols. It processes modules, their classes, and their methods to construct a textual diagram format suitable for visualization. The emitter also handles the representation of import relationships between modules.",
        "init_method": {
          "description": "The class does not define an explicit __init__ method, so it inherits the default initialization behavior from the base object class.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "emit",
            "description": {
              "overall": "The emit method generates a Mermaid class diagram by iterating over modules, their classes, and methods. It constructs class blocks with visibility indicators for methods and adds import relationships between modules. The method uses a helper function mermaid_id to sanitize identifiers for compatibility with Mermaid syntax.",
              "parameters": [
                {
                  "name": "modules",
                  "type": "dict[str, ModuleSymbol]",
                  "description": "A dictionary mapping module names to ModuleSymbol objects, which contain information about classes and imports."
                }
              ],
              "returns": [
                {
                  "name": "result",
                  "type": "str",
                  "description": "A string representing the complete Mermaid class diagram in text format."
                }
              ],
              "usage_context": {
                "calls": "This method calls the mermaid_id function to sanitize identifiers before including them in the diagram.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.diagram_generation.emitter.mermaid_id function for sanitizing identifiers.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.SymbolCollector": {
      "identifier": "backend.diagram_generation.symbol_collector.SymbolCollector",
      "description": {
        "overall": "The SymbolCollector class is a subclass of ast.NodeVisitor designed to traverse Python AST nodes and collect symbolic information about modules, including their imports, classes, and functions. It builds a structured representation of a module's symbols by visiting different types of AST nodes such as imports, class definitions, and function definitions. The collected information is stored in ModuleSymbol objects which contain details about functions, classes, and imports within the module.",
        "init_method": {
          "description": "Initializes the SymbolCollector with a module name and a list of packages. It creates a ModuleSymbol object to store the symbolic representation of the module being processed, including empty dictionaries for functions, classes, and imports.",
          "parameters": [
            {
              "name": "module_name",
              "type": "str",
              "description": "The name of the module being processed."
            },
            {
              "name": "packages",
              "type": "list[str]",
              "description": "A list of package names that the module belongs to."
            }
          ]
        },
        "methods": [
          {
            "identifier": "_has_return",
            "description": {
              "overall": "Checks whether a given function definition AST node contains any return statements. It iterates through the body of the function and returns True if any Return statement is found, otherwise False.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "bool",
                  "description": "True if the function has at least one return statement, False otherwise."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_ClassDef method."
              }
            },
            "error": null
          },
          {
            "identifier": "_declare_input_parameters",
            "description": {
              "overall": "Extracts the names of input parameters from a function definition AST node. It iterates through the arguments of the function and collects the names of the parameters into a list.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "list[str]",
                  "description": "A list of strings representing the names of the function's input parameters."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the visit_ClassDef and visit_AsyncFunctionDef methods."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles Import AST nodes by extracting import aliases and mapping them to their original names in the module's imports dictionary. It processes each alias in the import statement and stores the mapping between the alias and the actual module name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "Import",
                  "description": "The AST node representing an import statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the generic_visit method during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Handles ImportFrom AST nodes by processing relative imports and mapping imported names to their qualified names. It splits the module path to extract the base module name and maps each imported alias to its fully qualified name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ImportFrom",
                  "description": "The AST node representing an import from statement."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions.",
                "called_by": "This method is called by the generic_visit method during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Processes ClassDef AST nodes by creating a ClassSymbol object to represent the class and collecting information about its methods. It iterates through the class body to find function definitions and creates FunctionSymbol objects for each method, storing them in the class's methods dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ClassDef",
                  "description": "The AST node representing a class definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _has_return and _declare_input_parameters helper methods.",
                "called_by": "This method is called by the generic_visit method during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_AsyncFunctionDef",
            "description": {
              "overall": "Handles AsyncFunctionDef AST nodes by checking if the function is part of a class and skipping it if so. Otherwise, it creates a FunctionSymbol object to represent the asynchronous function and stores it in the module's functions dictionary.",
              "parameters": [
                {
                  "name": "node",
                  "type": "AsyncFunctionDef",
                  "description": "The AST node representing an asynchronous function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method calls the _has_return and _declare_input_parameters helper methods.",
                "called_by": "This method is called by the generic_visit method during AST traversal."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes FunctionDef AST nodes by delegating to the visit_AsyncFunctionDef method. This allows both regular and async functions to be handled consistently through a single visitor method.",
              "parameters": [
                {
                  "name": "node",
                  "type": "FunctionDef",
                  "description": "The AST node representing a function definition."
                }
              ],
              "returns": [
                {
                  "name": "",
                  "type": "None",
                  "description": "This method does not return any value."
                }
              ],
              "usage_context": {
                "calls": "This method calls the visit_AsyncFunctionDef method.",
                "called_by": "This method is called by the generic_visit method during AST traversal."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on several AST-related modules and data types including ast.AST, ast.FunctionDef, ast.Import, ast.ImportFrom, ast.NodeVisitor, diagram_generation.data_types.ModuleSymbol, diagram_generation.data_types.FunctionSymbol, and diagram_generation.data_types.ClassSymbol.",
          "instantiated_by": "This class is not explicitly instantiated in the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.RepoFile": {
      "identifier": "backend.getRepo.RepoFile",
      "description": {
        "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as the blob object, content, and size to optimize performance by only loading data when explicitly accessed. The class provides properties to access these lazy-loaded values and includes utility methods for word count analysis and dictionary serialization.",
        "init_method": {
          "description": "Initializes a RepoFile object with a file path and a commit tree. It sets up internal attributes to store the file path, the commit tree reference, and placeholders for the blob, content, and size which are lazily loaded upon first access.",
          "parameters": [
            {
              "name": "file_path",
              "type": "str",
              "description": "The path to the file within the repository."
            },
            {
              "name": "commit_tree",
              "type": "git.Tree",
              "description": "The tree object of the commit from which the file originates."
            }
          ]
        },
        "methods": [
          {
            "identifier": "blob",
            "description": {
              "overall": "This property lazy-loads the Git blob object associated with the file. It retrieves the blob from the commit tree based on the stored file path. If the file is not found in the tree, it raises a FileNotFoundError.",
              "parameters": [],
              "returns": [
                {
                  "name": "blob",
                  "type": "git.Blob",
                  "description": "The Git blob object representing the file."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly."
              }
            },
            "error": null
          },
          {
            "identifier": "content",
            "description": {
              "overall": "This property lazy-loads and decodes the content of the file. It uses the previously loaded blob object to read the raw data and decode it into a UTF-8 string, ignoring any encoding errors.",
              "parameters": [],
              "returns": [
                {
                  "name": "content",
                  "type": "str",
                  "description": "The decoded content of the file."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly."
              }
            },
            "error": null
          },
          {
            "identifier": "size",
            "description": {
              "overall": "This property lazy-loads and returns the size of the file in bytes. It accesses the size attribute of the blob object associated with the file.",
              "parameters": [],
              "returns": [
                {
                  "name": "size",
                  "type": "int",
                  "description": "The size of the file in bytes."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly."
              }
            },
            "error": null
          },
          {
            "identifier": "analyze_word_count",
            "description": {
              "overall": "This method performs a simple analysis by counting the number of words in the file's content. It splits the content by whitespace and returns the resulting count.",
              "parameters": [],
              "returns": [
                {
                  "name": "word_count",
                  "type": "int",
                  "description": "The total number of words in the file."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly."
              }
            },
            "error": null
          },
          {
            "identifier": "__repr__",
            "description": {
              "overall": "This special method returns a string representation of the RepoFile object, useful for debugging and logging purposes. It displays the file path of the RepoFile.",
              "parameters": [],
              "returns": [
                {
                  "name": "repr_string",
                  "type": "str",
                  "description": "A string representation of the RepoFile object."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly."
              }
            },
            "error": null
          },
          {
            "identifier": "to_dict",
            "description": {
              "overall": "This method converts the RepoFile object into a dictionary format. It includes basic file information such as path, name, size, and type. Optionally, it can also include the file's content if specified.",
              "parameters": [
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "If True, includes the file's content in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "data",
                  "type": "dict",
                  "description": "A dictionary containing file metadata and optionally the content."
                }
              ],
              "usage_context": {
                "calls": "No external functions are called by this method.",
                "called_by": "No other functions or methods call this method directly."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "The class does not depend on any other classes or modules beyond those already imported.",
          "instantiated_by": "The class is not instantiated anywhere within the provided context."
        }
      },
      "error": null
    },
    "backend.getRepo.GitRepository": {
      "identifier": "backend.getRepo.GitRepository",
      "description": {
        "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing functionality to retrieve files and construct a hierarchical file tree. It supports initialization with a repository URL, cloning, listing files as RepoFile objects, and cleaning up temporary resources upon closing. The class also implements context manager protocols (__enter__ and __exit__) to facilitate automatic resource cleanup.",
        "init_method": {
          "description": "Initializes a GitRepository instance by setting the repository URL, creating a temporary directory, and cloning the repository into that directory. It also retrieves metadata such as the latest commit and commit tree. If cloning fails, it raises a RuntimeError after cleaning up resources.",
          "parameters": [
            {
              "name": "repo_url",
              "type": "str",
              "description": "The URL of the Git repository to clone."
            }
          ]
        },
        "methods": [
          {
            "identifier": "get_all_files",
            "description": {
              "overall": "Retrieves a list of all files in the repository and converts them into RepoFile objects. It uses Git's ls-files command to obtain the file paths and constructs RepoFile instances for each path.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "files",
                  "type": "list[RepoFile]",
                  "description": "A list of RepoFile instances representing the files in the repository."
                }
              ],
              "usage_context": {
                "calls": "This method calls the RepoFile constructor for each file path retrieved from the repository.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "close",
            "description": {
              "overall": "Deletes the temporary directory and its contents associated with the repository. This method is typically invoked during cleanup to free up system resources.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__enter__",
            "description": {
              "overall": "Enables the use of the GitRepository instance in a context manager (with statement). It simply returns the instance itself.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                }
              ],
              "returns": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The GitRepository instance."
                }
              ],
              "usage_context": {
                "calls": "This method does not call any other functions or methods.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "__exit__",
            "description": {
              "overall": "Implements the exit protocol for the context manager. It ensures that the close() method is called when exiting the with block, thereby cleaning up temporary resources.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "exc_type",
                  "type": "Any",
                  "description": "Exception type if an exception occurred in the with block."
                },
                {
                  "name": "exc_val",
                  "type": "Any",
                  "description": "Exception value if an exception occurred in the with block."
                },
                {
                  "name": "exc_tb",
                  "type": "Any",
                  "description": "Exception traceback if an exception occurred in the with block."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the close() method to clean up resources.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_file_tree",
            "description": {
              "overall": "Constructs a hierarchical representation of the repository's file structure. If no files have been previously loaded, it fetches them first. Then, it iterates through the files and builds a nested dictionary structure representing directories and files.",
              "parameters": [
                {
                  "name": "self",
                  "type": "GitRepository",
                  "description": "The instance of the GitRepository class."
                },
                {
                  "name": "include_content",
                  "type": "bool",
                  "description": "Whether to include file content in the returned dictionary."
                }
              ],
              "returns": [
                {
                  "name": "tree",
                  "type": "dict",
                  "description": "A nested dictionary representing the file tree structure."
                }
              ],
              "usage_context": {
                "calls": "This method does not directly call any other functions or methods listed in the context.",
                "called_by": "This method is not called by any other method according to the provided context."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.getRepo.RepoFile class for creating file representations.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.ProjectAnalyzer": {
      "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
      "description": {
        "overall": "The ProjectAnalyzer class is responsible for analyzing Python project structures to extract and resolve relationships between functions, classes, and methods. It traverses the project directory to find Python files, parses their Abstract Syntax Trees (ASTs) to collect definitions, and resolves call relationships between these definitions. The analyzer maintains internal state including definitions, call graphs, and file ASTs during the analysis process.",
        "init_method": {
          "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including dictionaries for storing definitions, call graphs, and file ASTs, along with a set of directories to ignore during traversal.",
          "parameters": [
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory path of the Python project to be analyzed."
            }
          ]
        },
        "methods": [
          {
            "identifier": "analyze",
            "description": {
              "overall": "The main analysis method that orchestrates the process of finding Python files, collecting definitions from those files, and resolving call relationships. It iterates over the discovered Python files twice: once to collect definitions and again to resolve calls. After processing, it clears the cached ASTs to free memory and returns the constructed call graph.",
              "parameters": [],
              "returns": [
                {
                  "name": "call_graph",
                  "type": "defaultdict(list)",
                  "description": "A dictionary mapping callee identifiers to lists of caller information."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "get_raw_relationships",
            "description": {
              "overall": "Processes the collected call graph to generate a structured representation of relationships between definitions. It separates the call graph into outgoing and incoming relationships based on caller-callee pairs, returning a dictionary with sorted lists of related identifiers for each direction.",
              "parameters": [],
              "returns": [
                {
                  "name": "relationships",
                  "type": "dict",
                  "description": "A dictionary containing 'outgoing' and 'incoming' keys mapping identifiers to sorted lists of related identifiers."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods defined in the class.",
                "called_by": "This method is not called by any other methods according to the provided context."
              }
            },
            "error": null
          },
          {
            "identifier": "_find_py_files",
            "description": {
              "overall": "Recursively walks through the project root directory to find all Python (.py) files, excluding certain directories such as .git, .venv, etc. It returns a list of absolute paths to these Python files.",
              "parameters": [],
              "returns": [
                {
                  "name": "py_files",
                  "type": "list[str]",
                  "description": "A list of absolute file paths to Python files in the project."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods defined in the class.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_collect_definitions",
            "description": {
              "overall": "Parses a given Python file's content into an AST and collects definitions of functions and classes. It determines whether a function is a method based on its parent class in the AST and stores metadata about each definition including file location and type.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file whose definitions are to be collected."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls backend.relationship_analyzer.path_to_module to convert file paths into module paths.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          },
          {
            "identifier": "_get_parent",
            "description": {
              "overall": "Traverses the AST to find the parent node of a given AST node. This helper method is used to determine if a function definition is part of a class.",
              "parameters": [
                {
                  "name": "tree",
                  "type": "ast.AST",
                  "description": "The AST tree to search within."
                },
                {
                  "name": "node",
                  "type": "ast.AST",
                  "description": "The AST node for which to find the parent."
                }
              ],
              "returns": [
                {
                  "name": "parent",
                  "type": "ast.AST or None",
                  "description": "The parent AST node of the specified node, or None if not found."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods defined in the class.",
                "called_by": "This method is called by the _collect_definitions method."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_calls",
            "description": {
              "overall": "Uses a CallResolverVisitor to traverse the AST of a Python file and resolve call relationships between definitions. It extends the global call graph with the resolved calls from the visitor.",
              "parameters": [
                {
                  "name": "filepath",
                  "type": "str",
                  "description": "The absolute path to the Python file whose calls are to be resolved."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls backend.relationship_analyzer.CallResolverVisitor to resolve calls in the AST.",
                "called_by": "This method is called by the analyze method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on backend.relationship_analyzer.CallResolverVisitor and backend.relationship_analyzer.path_to_module for resolving calls and converting file paths to module paths respectively.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.CallResolverVisitor": {
      "identifier": "backend.relationship_analyzer.CallResolverVisitor",
      "description": {
        "overall": "The CallResolverVisitor class is an AST (Abstract Syntax Tree) visitor designed to analyze Python code and track function calls, class definitions, and import statements. It maintains scope information, resolves qualified names for calls, and records call relationships between functions and modules. It also tracks instance types for assignments involving class instantiation.",
        "init_method": {
          "description": "Initializes the CallResolverVisitor with a file path, project root, and definitions mapping. It sets up internal state including scope tracking, instance type mappings, and call recording structures.",
          "parameters": [
            {
              "name": "filepath",
              "type": "str",
              "description": "The path to the Python file being analyzed."
            },
            {
              "name": "project_root",
              "type": "str",
              "description": "The root directory of the project for resolving module paths."
            },
            {
              "name": "definitions",
              "type": "dict",
              "description": "A mapping of qualified names to their definitions for resolving references."
            }
          ]
        },
        "methods": [
          {
            "identifier": "visit_ClassDef",
            "description": {
              "overall": "Handles AST nodes representing class definitions. It updates the current class name in the context before visiting child nodes and restores the previous class name after traversal.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ClassDef",
                  "description": "The AST node representing the class definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_FunctionDef",
            "description": {
              "overall": "Processes AST nodes representing function definitions. It manages the caller name context by setting the full identifier for the function based on module and class scope, then visits child nodes and restores the previous caller name.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.FunctionDef",
                  "description": "The AST node representing the function definition."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Call",
            "description": {
              "overall": "Analyzes AST nodes representing function calls. It resolves the qualified name of the called function, checks if it exists in the definitions, and records the call relationship along with caller metadata such as file, line number, and caller type.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Call",
                  "description": "The AST node representing the function call."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Import",
            "description": {
              "overall": "Handles AST nodes representing import statements. It adds imported names to the scope mapping, allowing resolution of qualified names later during call analysis.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Import",
                  "description": "The AST node representing the import statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_ImportFrom",
            "description": {
              "overall": "Processes AST nodes representing 'from ... import ...' statements. It resolves module paths and maps imported names to their fully qualified names in the scope.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.ImportFrom",
                  "description": "The AST node representing the 'from ... import ...' statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "visit_Assign",
            "description": {
              "overall": "Handles AST nodes representing assignment statements. Specifically, it identifies assignments to instances of classes and records the type of the assigned instance for later use in call resolution.",
              "parameters": [
                {
                  "name": "node",
                  "type": "ast.Assign",
                  "description": "The AST node representing the assignment statement."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the AST visitor framework during traversal of the AST."
              }
            },
            "error": null
          },
          {
            "identifier": "_resolve_call_qname",
            "description": {
              "overall": "Resolves the qualified name of a function call node. It handles both direct function names and attribute access (method calls) by looking up names in the scope or instance types.",
              "parameters": [
                {
                  "name": "func_node",
                  "type": "ast.expr",
                  "description": "The AST node representing the function being called."
                }
              ],
              "returns": [
                {
                  "name": "qualified_name",
                  "type": "str or None",
                  "description": "The resolved qualified name of the function or None if not resolvable."
                }
              ],
              "usage_context": {
                "calls": "This method does not explicitly call any other methods.",
                "called_by": "This method is called by the visit_Call method."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on the backend.relationship_analyzer.path_to_module function for resolving module paths.",
          "instantiated_by": "This class is not directly instantiated by any other code listed in the context."
        }
      },
      "error": null
    },
    "schemas.enums.AnalysisMode": {
      "identifier": "schemas.enums.AnalysisMode",
      "description": {
        "overall": "The AnalysisMode class is an enumeration that defines different levels of analysis detail. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumeration. The enum includes four distinct modes: OVERVIEW, STANDARD, DETAILED, and DEEP_DIVE, each associated with a specific string identifier.",
        "init_method": {
          "description": "The class is initialized as a string-based enumeration with predefined values. No explicit initialization parameters are required since the enum values are defined directly in the class body.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__new__",
            "description": {
              "overall": "The __new__ method is responsible for creating new instances of the enum members. It ensures that each enum member is properly initialized with its corresponding string value. This method is automatically invoked during enum creation and handles the internal instantiation process.",
              "parameters": [
                {
                  "name": "cls",
                  "type": "type",
                  "description": "The class being instantiated."
                },
                {
                  "name": "value",
                  "type": "str",
                  "description": "The string value associated with the enum member."
                }
              ],
              "returns": [
                {
                  "name": "instance",
                  "type": "AnalysisMode",
                  "description": "A new instance of the AnalysisMode enum with the specified value."
                }
              ],
              "usage_context": {
                "calls": "This method internally uses the standard enum construction mechanism to create new enum instances.",
                "called_by": "This method is called by the Python enum metaclass during the creation of enum members."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not explicitly instantiated by any other component in the provided context."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramFocus": {
      "identifier": "schemas.enums.DiagramFocus",
      "description": {
        "overall": "The DiagramFocus class is an enumeration that defines different focus areas for diagram visualization. It inherits from both str and Enum, allowing each member to be used as a string value while maintaining the benefits of an enumeration. The class provides predefined constants representing various diagram focuses such as architecture, data flow, dependencies, and call graph.",
        "init_method": {
          "description": "The class is initialized as an enumeration inheriting from str and Enum. No explicit initialization parameters are required as the enumeration values are defined directly as class attributes.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules or libraries beyond the standard enum module which is already imported.",
          "instantiated_by": "This class is not instantiated by any other code components as it is designed purely as an enumeration."
        }
      },
      "error": null
    },
    "schemas.enums.DiagramType": {
      "identifier": "schemas.enums.DiagramType",
      "description": {
        "overall": "The DiagramType class is an enumeration that defines various types of Mermaid diagrams. It inherits from both str and Enum, allowing each diagram type to be represented as a string value. This class serves as a type-safe way to represent different diagram types within the application.",
        "init_method": {
          "description": "The class does not define a custom __init__ method. It relies on the default initialization inherited from the Enum base class.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class has no external dependencies.",
          "instantiated_by": "This class is not instantiated by any other component."
        }
      },
      "error": null
    },
    "schemas.enums.GraphType": {
      "identifier": "schemas.enums.GraphType",
      "description": {
        "overall": "The GraphType class is an enumeration that defines different types of input graphs used in the system. It inherits from both str and Enum, allowing it to behave like a string while providing predefined constants for graph types. The class specifies three distinct graph types: CALLGRAPH, DEPENDENCY, and COMBINED, each associated with a specific string value.",
        "init_method": {
          "description": "The GraphType class does not define a custom __init__ method. It inherits the initialization behavior from its parent classes (str and Enum). The class is initialized with predefined values for each enum member.",
          "parameters": []
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies are required for this class.",
          "instantiated_by": "This class is not instantiated by any other component based on the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ParameterDescription": {
      "identifier": "schemas.types.ParameterDescription",
      "description": {
        "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the metadata of a single function parameter. It encapsulates three core attributes: the parameter's name, its type, and a descriptive explanation. This class ensures data integrity and provides a standardized structure for parameter descriptions within the system.",
        "init_method": {
          "description": "The constructor initializes a ParameterDescription instance with three required fields: name, type, and description. These fields are defined as string types and serve to describe a function parameter comprehensively.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the function parameter."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The data type of the function parameter."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the function parameter's purpose or usage."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not directly instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ReturnDescription": {
      "identifier": "schemas.types.ReturnDescription",
      "description": {
        "overall": "The ReturnDescription class is a Pydantic model designed to represent and validate the description of a function's return value. It encapsulates three essential attributes: the name of the return value, its type, and a textual description. This class ensures data integrity and structure for return value metadata, making it suitable for use in API schemas, documentation systems, or any application requiring standardized return value definitions.",
        "init_method": {
          "description": "The class is initialized with three required string fields: 'name', 'type', and 'description'. These fields collectively define the characteristics of a function's return value.",
          "parameters": [
            {
              "name": "name",
              "type": "str",
              "description": "The name of the return value."
            },
            {
              "name": "type",
              "type": "str",
              "description": "The type of the return value."
            },
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the return value."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any other classes or modules beyond its base Pydantic model and standard typing constructs.",
          "instantiated_by": "This class is not instantiated by any other components as indicated by the context."
        }
      },
      "error": null
    },
    "schemas.types.UsageContext": {
      "identifier": "schemas.types.UsageContext",
      "description": {
        "overall": "The UsageContext class is a Pydantic model designed to encapsulate information about the calling context of a function, specifically detailing what functions are called by the current function and which function calls the current function. It serves as a structured representation of functional dependencies and call relationships within a codebase.",
        "init_method": {
          "description": "Initializes a UsageContext instance with two string fields: 'calls', describing the functions called by the current function, and 'called_by', describing the function that calls the current function.",
          "parameters": [
            {
              "name": "calls",
              "type": "str",
              "description": "A string describing the functions called by the current function."
            },
            {
              "name": "called_by",
              "type": "str",
              "description": "A string describing the function that calls the current function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionDescription": {
      "identifier": "schemas.types.FunctionDescription",
      "description": {
        "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed information about a function's purpose, parameters, return values, and usage context. It serves as a structured representation for documenting function signatures and behaviors, making it suitable for use in automated documentation systems or code analysis tools.",
        "init_method": {
          "description": "The constructor initializes a FunctionDescription instance with four required fields: overall (a string describing the function's purpose), parameters (a list of ParameterDescription objects), returns (a list of ReturnDescription objects), and usage_context (a UsageContext object).",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose and functionality of the function."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the function."
            },
            {
              "name": "returns",
              "type": "List[ReturnDescription]",
              "description": "A list of ReturnDescription objects detailing the return values of the function."
            },
            {
              "name": "usage_context",
              "type": "UsageContext",
              "description": "An object describing the usage context of the function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other class or function according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysis": {
      "identifier": "schemas.types.FunctionAnalysis",
      "description": {
        "overall": "The FunctionAnalysis class is a Pydantic model designed to represent the complete JSON schema for a function. It serves as a structured data container that includes a unique identifier, a detailed function description, and an optional error field. This class is intended to encapsulate all relevant metadata and contextual information about a function in a standardized format, making it suitable for serialization, validation, and interchange within a larger system.",
        "init_method": {
          "description": "Initializes a new instance of the FunctionAnalysis class with required fields for the identifier and description, and an optional error field.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A unique string identifier for the function."
            },
            {
              "name": "description",
              "type": "FunctionDescription",
              "description": "An object containing detailed information about the function's purpose, parameters, and behavior."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to store any error messages related to the function analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those specified in the imports list, which include standard typing utilities and Pydantic components.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ConstructorDescription": {
      "identifier": "schemas.types.ConstructorDescription",
      "description": {
        "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It encapsulates a textual description of the constructor and a list of parameter descriptions, making it suitable for representing metadata about class constructors in a structured format.",
        "init_method": {
          "description": "Initializes a ConstructorDescription instance with a description string and a list of ParameterDescription objects.",
          "parameters": [
            {
              "name": "description",
              "type": "str",
              "description": "A textual description of the constructor's purpose or behavior."
            },
            {
              "name": "parameters",
              "type": "List[ParameterDescription]",
              "description": "A list of ParameterDescription objects detailing each parameter of the constructor."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassContext": {
      "identifier": "schemas.types.ClassContext",
      "description": {
        "overall": "The ClassContext class is a Pydantic model designed to encapsulate information about a class's external dependencies and the locations where it is instantiated. It serves as a structured representation of metadata related to class usage and integration within a system.",
        "init_method": {
          "description": "Initializes a ClassContext instance with two string attributes: 'dependencies' and 'instantiated_by'. These fields store information about the class's external dependencies and the entities that instantiate it, respectively.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "str",
              "description": "A string describing the external dependencies of the class."
            },
            {
              "name": "instantiated_by",
              "type": "str",
              "description": "A string describing the entities or locations where the class is instantiated."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other components as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassDescription": {
      "identifier": "schemas.types.ClassDescription",
      "description": {
        "overall": "The ClassDescription class is a Pydantic model designed to encapsulate a comprehensive analysis of a class. It includes fields for a textual overview of the class's purpose, a detailed breakdown of its constructor, a list of its methods along with their descriptions, and contextual information about how the class is used. This structure serves as a standardized way to represent class-level documentation and analysis within a larger system.",
        "init_method": {
          "description": "Initializes an instance of the ClassDescription class with specified values for overall purpose, constructor details, methods, and usage context.",
          "parameters": [
            {
              "name": "overall",
              "type": "str",
              "description": "A string describing the overall purpose and functionality of the class being analyzed."
            },
            {
              "name": "init_method",
              "type": "ConstructorDescription",
              "description": "An object containing detailed information about the class's constructor, including its parameters and initialization logic."
            },
            {
              "name": "methods",
              "type": "List[FunctionAnalysis]",
              "description": "A list of FunctionAnalysis objects, each representing a method within the class and its associated metadata."
            },
            {
              "name": "usage_context",
              "type": "ClassContext",
              "description": "An object providing contextual information about how the class is used, such as dependencies and instantiation points."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any external modules beyond those imported at the top level.",
          "instantiated_by": "This class is not instantiated by any other components listed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysis": {
      "identifier": "schemas.types.ClassAnalysis",
      "description": {
        "overall": "The ClassAnalysis class serves as the primary data structure for representing the complete JSON schema of a class within a documentation or analysis system. It encapsulates essential metadata about the class, including its identifier, a detailed description, and an optional error field for capturing any issues during processing.",
        "init_method": {
          "description": "Initializes a new instance of the ClassAnalysis class with required fields for the identifier and description, and an optional error field set to None by default.",
          "parameters": [
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "description",
              "type": "ClassDescription",
              "description": "An instance of ClassDescription providing detailed information about the class."
            },
            {
              "name": "error",
              "type": "Optional[str]",
              "description": "An optional string field to capture any errors encountered during analysis, defaulting to None."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.CallInfo": {
      "identifier": "schemas.types.CallInfo",
      "description": {
        "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It is designed as a Pydantic BaseModel for data validation and serialization.",
        "init_method": {
          "description": "Initializes a CallInfo instance with file, function name, call mode, and line number attributes.",
          "parameters": [
            {
              "name": "file",
              "type": "str",
              "description": "The file path where the call occurred."
            },
            {
              "name": "function",
              "type": "str",
              "description": "The name of the function that made the call."
            },
            {
              "name": "mode",
              "type": "str",
              "description": "The mode of the call, such as 'method', 'function', or 'module'."
            },
            {
              "name": "line",
              "type": "int",
              "description": "The line number in the file where the call occurred."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were specified for this class.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionContextInput": {
      "identifier": "schemas.types.FunctionContextInput",
      "description": {
        "overall": "The FunctionContextInput class is a Pydantic model designed to represent structured context for analyzing a function. It encapsulates two key pieces of information: a list of function names that the analyzed function calls, and a list of CallInfo objects indicating which functions call the analyzed function. This class serves as a data transfer object to facilitate function analysis workflows by providing a standardized format for representing caller-callee relationships.",
        "init_method": {
          "description": "Initializes the FunctionContextInput with two fields: 'calls', a list of strings representing function names called by the analyzed function, and 'called_by', a list of CallInfo objects representing functions that call the analyzed function.",
          "parameters": [
            {
              "name": "calls",
              "type": "List[str]",
              "description": "A list of strings representing the names of functions called by the analyzed function."
            },
            {
              "name": "called_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects representing the functions that call the analyzed function."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other components according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.FunctionAnalysisInput": {
      "identifier": "schemas.types.FunctionAnalysisInput",
      "description": {
        "overall": "The FunctionAnalysisInput class serves as a structured input model for generating FunctionAnalysis objects. It encapsulates all necessary information including the analysis mode, identifier, source code, imports, and contextual data required for processing.",
        "init_method": {
          "description": "Initializes the FunctionAnalysisInput instance with the specified mode, identifier, source code, imports, and context. The mode is constrained to the literal value 'function_analysis', ensuring strict adherence to the intended analysis type.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal['function_analysis']",
              "description": "A literal string value that specifies the analysis mode, constrained to 'function_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the function being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the function to be analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements used in the function's source code."
            },
            {
              "name": "context",
              "type": "FunctionContextInput",
              "description": "An object containing contextual information about the function analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on pydantic.BaseModel for validation and serialization, along with several enums and other schema definitions from schemas.enums and schemas.types.",
          "instantiated_by": "This class is instantiated by components responsible for preparing input data for function analysis tasks, though specific instantiation points are not detailed in the provided context."
        }
      },
      "error": null
    },
    "schemas.types.MethodContextInput": {
      "identifier": "schemas.types.MethodContextInput",
      "description": {
        "overall": "The MethodContextInput class is a Pydantic model designed to represent structured context information for a class's methods. It encapsulates details such as the method's identifier, the methods it calls, the methods that call it, its arguments, and its docstring. This class serves as a data transfer object for method-level context in a larger analysis or documentation system.",
        "init_method": {
          "description": "The class is initialized with standard Pydantic BaseModel parameters, inheriting validation and serialization capabilities. It does not define a custom __init__ method, relying on the parent class initialization.",
          "parameters": []
        },
        "methods": [
          {
            "identifier": "__init__",
            "description": {
              "overall": "This method initializes an instance of the MethodContextInput class. It leverages the Pydantic BaseModel's built-in initialization mechanism to set up the instance with the provided values for identifier, calls, called_by, args, and docstring. The method ensures type validation and serialization support through the Pydantic framework.",
              "parameters": [
                {
                  "name": "identifier",
                  "type": "str",
                  "description": "A string identifier for the method."
                },
                {
                  "name": "calls",
                  "type": "List[str]",
                  "description": "A list of strings representing the identifiers of methods called by this method."
                },
                {
                  "name": "called_by",
                  "type": "List[CallInfo]",
                  "description": "A list of CallInfo objects representing the methods that call this method."
                },
                {
                  "name": "args",
                  "type": "List[str]",
                  "description": "A list of strings representing the argument names of the method."
                },
                {
                  "name": "docstring",
                  "type": "Optional[str]",
                  "description": "An optional string containing the docstring of the method."
                }
              ],
              "returns": [],
              "usage_context": {
                "calls": "This method calls the Pydantic BaseModel's internal initialization logic.",
                "called_by": "This method is typically called by the Pydantic framework during object instantiation."
              }
            },
            "error": null
          }
        ],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel for validation and serialization features, and uses types from typing module including List, Optional, and Literal.",
          "instantiated_by": "This class is instantiated by the documentation generation system when processing method contexts for analysis."
        }
      },
      "error": null
    },
    "schemas.types.ClassContextInput": {
      "identifier": "schemas.types.ClassContextInput",
      "description": {
        "overall": "The ClassContextInput class is a Pydantic model designed to encapsulate structured context information for analyzing a class. It holds three main pieces of data: a list of dependencies, a list of call information for instantiation, and a list of method context inputs. This class serves as a data transfer object to provide necessary metadata for class analysis workflows.",
        "init_method": {
          "description": "The constructor initializes the ClassContextInput instance with three attributes: dependencies, instantiated_by, and method_context. These attributes are expected to be lists of specific types, with instantiated_by containing CallInfo objects and method_context containing MethodContextInput objects.",
          "parameters": [
            {
              "name": "dependencies",
              "type": "List[str]",
              "description": "A list of string identifiers representing the dependencies of the class being analyzed."
            },
            {
              "name": "instantiated_by",
              "type": "List[CallInfo]",
              "description": "A list of CallInfo objects detailing how the class is instantiated."
            },
            {
              "name": "method_context",
              "type": "List[MethodContextInput]",
              "description": "A list of MethodContextInput objects providing context for each method in the class."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.ClassAnalysisInput": {
      "identifier": "schemas.types.ClassAnalysisInput",
      "description": {
        "overall": "The ClassAnalysisInput is a Pydantic model designed to encapsulate the necessary input data required for generating a ClassAnalysis object. It serves as a structured data container that defines the expected fields and types for class analysis operations, including the mode of analysis, class identifier, source code, imports, and contextual information.",
        "init_method": {
          "description": "Initializes the ClassAnalysisInput model with fields representing the mode of analysis, class identifier, source code, list of imports, and contextual input data. The model enforces strict typing and validation based on Pydantic's BaseModel features.",
          "parameters": [
            {
              "name": "mode",
              "type": "Literal[\"class_analysis\"]",
              "description": "A literal string value that specifies the mode of analysis as 'class_analysis'."
            },
            {
              "name": "identifier",
              "type": "str",
              "description": "A string identifier for the class being analyzed."
            },
            {
              "name": "source_code",
              "type": "str",
              "description": "The raw source code of the class being analyzed."
            },
            {
              "name": "imports",
              "type": "List[str]",
              "description": "A list of import statements from the source file."
            },
            {
              "name": "context",
              "type": "ClassContextInput",
              "description": "An object containing contextual information related to the class analysis."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class depends on Pydantic's BaseModel and several schema definitions from schemas.enums and schemas.types modules.",
          "instantiated_by": "This class is instantiated by components responsible for preparing input data for class analysis workflows."
        }
      },
      "error": null
    },
    "schemas.types.DiagramRequest": {
      "identifier": "schemas.types.DiagramRequest",
      "description": {
        "overall": "The DiagramRequest class is a Pydantic model designed to define the structure of input data required for requesting diagram generation. It specifies the necessary components such as nodes and edges, along with optional configuration parameters like mode and focus to control the diagram generation process.",
        "init_method": {
          "description": "Initializes the DiagramRequest model with required fields for nodes and edges, and optional fields for mode and focus with default values.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing the nodes in the diagram."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing the edges connecting nodes in the diagram."
            },
            {
              "name": "mode",
              "type": "AnalysisMode",
              "description": "The analysis mode for diagram generation, defaults to AnalysisMode.STANDARD."
            },
            {
              "name": "focus",
              "type": "DiagramFocus",
              "description": "The focus area for diagram generation, defaults to DiagramFocus.ARCHITECTURE."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were explicitly listed.",
          "instantiated_by": "This class is not instantiated by any other component according to the provided context."
        }
      },
      "error": null
    },
    "schemas.types.GraphInput": {
      "identifier": "schemas.types.GraphInput",
      "description": {
        "overall": "The GraphInput class represents a serializable form of a call graph, designed to encapsulate the structural elements of a graph including nodes, edges, graph type, and associated metadata. It inherits from pydantic.BaseModel, which provides data validation and serialization capabilities. The class is intended to serve as a standardized data structure for representing graph-based information in a structured and validated format.",
        "init_method": {
          "description": "Initializes a GraphInput instance with required fields for nodes, edges, and graph_type, along with optional metadata. The metadata field defaults to an empty dictionary if not provided.",
          "parameters": [
            {
              "name": "nodes",
              "type": "list[dict]",
              "description": "A list of dictionaries representing the nodes in the graph."
            },
            {
              "name": "edges",
              "type": "list[tuple]",
              "description": "A list of tuples representing the edges connecting nodes in the graph."
            },
            {
              "name": "graph_type",
              "type": "str",
              "description": "A string indicating the type of graph being represented."
            },
            {
              "name": "metadata",
              "type": "dict",
              "description": "An optional dictionary containing additional metadata about the graph. Defaults to an empty dictionary."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "This class does not explicitly depend on any other classes or modules beyond those imported at the top level.",
          "instantiated_by": "This class is not instantiated by any other components as indicated by the context."
        }
      },
      "error": null
    },
    "schemas.types.DiagramOutput": {
      "identifier": "schemas.types.DiagramOutput",
      "description": {
        "overall": "The DiagramOutput class is a Pydantic BaseModel designed to represent the output schema for generated diagram information. It encapsulates three key pieces of data: the type of diagram, the Mermaid code representing the diagram, and an explanation of the diagram's content. This class serves as a structured data container for diagram-related outputs, ensuring consistent formatting and validation of diagram information.",
        "init_method": {
          "description": "The class is initialized with three required fields: diagramtype, mermaid_code, and explanation. These fields define the core components of a diagram output, including its type, the Mermaid code representation, and a textual explanation.",
          "parameters": [
            {
              "name": "diagramtype",
              "type": "DiagramType",
              "description": "The type of diagram being represented."
            },
            {
              "name": "mermaid_code",
              "type": "str",
              "description": "The Mermaid code that defines the diagram."
            },
            {
              "name": "explanation",
              "type": "str",
              "description": "A textual explanation of the diagram's content."
            }
          ]
        },
        "methods": [],
        "usage_context": {
          "dependencies": "No external dependencies were identified for this class.",
          "instantiated_by": "This class is not instantiated by any other component as per the provided context."
        }
      },
      "error": null
    }
  }
}