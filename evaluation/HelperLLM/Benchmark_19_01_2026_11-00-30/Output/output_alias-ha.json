{
  "functions": {
    "backend.AST_Schema.path_to_module": {
      "identifier": "backend.AST_Schema.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function first attempts to calculate the relative path from the project root to the file. If this fails, it falls back to using the file's basename. The function then removes any '.py' extension from the relative path and replaces path separators with dots to form the module path. Finally, it checks if the module path ends with '__init__' and removes this if present, before returning the resulting module path.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The file path to be converted into a Python module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The Python module path corresponding to the input file path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_file_dependency_graph": {
      "identifier": "backend.File_Dependency.build_file_dependency_graph",
      "description": {
        "overall": "The `build_file_dependency_graph` function constructs a directed graph representing the file dependencies within a given abstract syntax tree (AST). It utilizes the `FileDependencyGraph` class to traverse the AST and identify import dependencies. The function returns a `networkx.DiGraph` object, which represents the dependency graph. The graph is built by adding nodes for each file and edges between files that have import relationships. This function is designed to work within the context of a repository, taking into account the repository root and the filename being analyzed.",
        "parameters": [
          {
            "name": "filename",
            "type": "str",
            "description": "The name of the file being analyzed."
          },
          {
            "name": "tree",
            "type": "AST",
            "description": "The abstract syntax tree (AST) of the file being analyzed."
          },
          {
            "name": "repo_root",
            "type": "str",
            "description": "The root directory of the repository containing the file being analyzed."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the file dependencies within the given AST."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.FileDependencyGraph.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.build_repository_graph": {
      "identifier": "backend.File_Dependency.build_repository_graph",
      "description": {
        "overall": "The `build_repository_graph` function constructs a directed graph representing the dependencies between files in a Git repository. It filters files based on their extension (`.py`) and path (containing `backend`), then uses the `build_file_dependency_graph` function to create a graph for each file. The function returns a combined graph of all file dependencies. The graph is built using the NetworkX library and includes nodes for each file and edges representing the dependencies between them. The function takes a `GitRepository` object as input and returns a `nx.DiGraph` object. The function's purpose is to provide a visual representation of the dependencies between files in the repository, which can be useful for understanding the structure of the codebase.",
        "parameters": [
          {
            "name": "repository",
            "type": "GitRepository",
            "description": "A GitRepository object representing the repository to analyze."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the dependencies between files in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.File_Dependency.build_file_dependency_graph.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.File_Dependency.get_all_temp_files": {
      "identifier": "backend.File_Dependency.get_all_temp_files",
      "description": {
        "overall": "The `get_all_temp_files` function retrieves a list of all Python files within a specified directory and its subdirectories. It takes a directory path as input, resolves it to an absolute path, and then uses a recursive glob pattern to find all files with the `.py` extension. The function returns a list of `Path` objects representing the relative paths of these files to the root directory. This function appears to be designed for traversing and analyzing Python files within a directory structure.",
        "parameters": [
          {
            "name": "directory",
            "type": "str",
            "description": "The path to the directory to search for Python files."
          }
        ],
        "returns": [
          {
            "name": "all_files",
            "type": "list[Path]",
            "description": "A list of `Path` objects representing the relative paths of all Python files found in the directory and its subdirectories."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.HelperLLM.main_orchestrator": {
      "identifier": "backend.HelperLLM.main_orchestrator",
      "description": {
        "overall": "This function serves as the main orchestrator for the Helper LLM. It defines pre-computed analyses for various methods, including add_item, check_stock, and generate_report, and utilizes these analyses to generate documentation for classes. The function is responsible for managing the workflow of generating documentation, including processing inputs, analyzing methods, and aggregating results.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "backend.HelperLLM.LLMHelper, schemas.types.ClassAnalysisInput, and schemas.types.ClassContextInput",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_callGraph": {
      "identifier": "backend.callgraph.build_callGraph",
      "description": {
        "overall": "The `build_callGraph` function constructs a directed graph representing the call relationships between functions within a given abstract syntax tree (AST). It utilizes the `CallGraph` visitor to traverse the AST and populate the graph with nodes and edges corresponding to function calls. The function takes an AST and a filename as input and returns a `networkx.DiGraph` object. The graph is filtered to only include nodes and edges for functions that are part of the current module. The function's purpose is to provide a visual representation of the call graph, which can be useful for analyzing and understanding the structure of the code.",
        "parameters": [
          {
            "name": "tree",
            "type": "ast.AST",
            "description": "The abstract syntax tree (AST) to be analyzed."
          },
          {
            "name": "filename",
            "type": "str",
            "description": "The filename associated with the AST."
          }
        ],
        "returns": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the call relationships between functions in the AST."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.callgraph.CallGraph.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.make_safe_dot": {
      "identifier": "backend.callgraph.make_safe_dot",
      "description": {
        "overall": "The `make_safe_dot` function generates a safe representation of a directed graph and writes it to a file in DOT format. It takes a NetworkX DiGraph object and an output file path as input. The function creates a copy of the input graph, relabels its nodes to ensure they are safe for DOT format, and then writes the modified graph to the specified output file. This process involves creating a mapping of original node names to safe names, applying this mapping to the graph, and preserving the original node labels as attributes. The function utilizes the NetworkX library for graph manipulation and the nx_pydot module for writing the graph to a DOT file.",
        "parameters": [
          {
            "name": "graph",
            "type": "nx.DiGraph",
            "description": "The input directed graph to be converted to a safe DOT format."
          },
          {
            "name": "out_path",
            "type": "str",
            "description": "The file path where the safe DOT representation of the graph will be written."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.callgraph.build_filtered_callgraph": {
      "identifier": "backend.callgraph.build_filtered_callgraph",
      "description": {
        "overall": "The `build_filtered_callgraph` function constructs a global call graph and filters it to include only self-written functions. It takes a `GitRepository` object as input and returns a directed graph representing the call relationships between the functions. The function iterates over all Python files in the repository, parses their abstract syntax trees, and identifies the functions defined in each file. It then constructs the global call graph by adding edges between functions that call each other. The function filters the graph to only include functions that are defined in the repository.",
        "parameters": [
          {
            "name": "repo",
            "type": "GitRepository",
            "description": "A `GitRepository` object representing the repository to analyze."
          }
        ],
        "returns": [
          {
            "name": "global_graph",
            "type": "nx.DiGraph",
            "description": "A directed graph representing the call relationships between the functions in the repository."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.callgraph.CallGraph`. ",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.converter.wrap_cdata": {
      "identifier": "backend.converter.wrap_cdata",
      "description": {
        "overall": "The `wrap_cdata` function takes in content and wraps it in CDATA tags. This is typically used in XML to prevent the content from being parsed as XML. The function uses an f-string to format the content within the CDATA tags. It does not perform any error checking on the input content. The function returns the wrapped content as a string.",
        "parameters": [
          {
            "name": "content",
            "type": "str",
            "description": "The content to be wrapped in CDATA tags."
          }
        ],
        "returns": [
          {
            "name": "wrapped_content",
            "type": "str",
            "description": "The content wrapped in CDATA tags."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.extract_output_content": {
      "identifier": "backend.converter.extract_output_content",
      "description": {
        "overall": "The `extract_output_content` function is designed to extract text and handle images from a list of outputs. It iterates over each output, checks its type, and processes the data accordingly. For display data and execute results, it decodes Base64 encoded images and appends them to a list. For stream outputs, it directly appends the text. For error outputs, it appends the error name and value. The function returns a list of extracted text strings or placeholders for images.",
        "parameters": [
          {
            "name": "outputs",
            "type": "list",
            "description": "A list of output objects to be processed."
          },
          {
            "name": "image_list",
            "type": "list",
            "description": "A list to store image data."
          }
        ],
        "returns": [
          {
            "name": "extracted_xml_snippets",
            "type": "list",
            "description": "A list of extracted text strings or placeholders for images."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.process_image.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_image": {
      "identifier": "backend.converter.process_image",
      "description": {
        "overall": "The `process_image` function takes a `mime_type` as input and checks if it exists in the `data` dictionary. If it does, the function attempts to process the corresponding base64-encoded image string, removes any newline characters, and appends it to the `image_list`. The function then returns a formatted string containing an image placeholder with the image index and mime type. If any exception occurs during processing, the function returns an error message. If the `mime_type` is not found in the `data` dictionary, the function returns `None`.",
        "parameters": [
          {
            "name": "mime_type",
            "type": "str",
            "description": "The mime type of the image to be processed."
          }
        ],
        "returns": [
          {
            "name": "success",
            "type": "str",
            "description": "A formatted string containing an image placeholder with the image index and mime type."
          },
          {
            "name": "error",
            "type": "str",
            "description": "An error message if any exception occurs during processing."
          },
          {
            "name": "not_found",
            "type": "NoneType",
            "description": "None if the mime type is not found in the data dictionary."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.convert_notebook_to_xml": {
      "identifier": "backend.converter.convert_notebook_to_xml",
      "description": {
        "overall": "The `convert_notebook_to_xml` function takes a notebook file content as input, attempts to parse it as a JSON notebook, and then converts its cells into XML format. If the parsing fails, it returns an error message. The function handles two types of cells: markdown and code. For markdown cells, it directly converts the source into XML. For code cells, it wraps the source code in CDATA and converts it into XML, and if the cell has outputs, it extracts the output content, wraps it in CDATA, and appends it as an output cell in XML. The function returns the XML representation of the notebook and a list of extracted images.",
        "parameters": [
          {
            "name": "file_content",
            "type": "str",
            "description": "The content of the notebook file to be converted."
          }
        ],
        "returns": [
          {
            "name": "xml_content",
            "type": "str",
            "description": "The XML representation of the notebook."
          },
          {
            "name": "extracted_images",
            "type": "list",
            "description": "A list of extracted images from the notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.extract_output_content and backend.converter.wrap_cdata.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.converter.process_repo_notebooks": {
      "identifier": "backend.converter.process_repo_notebooks",
      "description": {
        "overall": "The `process_repo_notebooks` function processes a list of repository files, identifies notebooks with the '.ipynb' extension, and converts them into XML format along with extracting images. It logs the number of notebooks found and the processing of each notebook. The function returns a dictionary where each key is the path of a notebook file and the value is another dictionary containing the XML output and images for that notebook. This function utilizes the `convert_notebook_to_xml` function to perform the conversion of individual notebooks. The logging module is used for informational messages about the processing progress.",
        "parameters": [
          {
            "name": "repo_files",
            "type": "list",
            "description": "A list of repository files to be processed for notebooks."
          }
        ],
        "returns": [
          {
            "name": "results",
            "type": "dict",
            "description": "A dictionary where each key is the path of a notebook file and the value is another dictionary containing the XML output and images for that notebook."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.converter.convert_notebook_to_xml.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.emitter.mermaid_id": {
      "identifier": "backend.diagram_generation.emitter.mermaid_id",
      "description": {
        "overall": "The `mermaid_id` function takes a string input `name` and returns a modified string where all periods (.) are replaced with underscores (_). This is done to ensure that the resulting string is a valid Mermaid identifier, as Mermaid identifiers cannot contain periods in their names. The function uses the `replace` method of the string class to achieve this. It does not perform any error checking on the input. The purpose of this function is to sanitize the input string for use in Mermaid diagrams.",
        "parameters": [
          {
            "name": "name",
            "type": "str",
            "description": "The input string to be modified."
          }
        ],
        "returns": [
          {
            "name": "modified_name",
            "type": "str",
            "description": "The input string with all periods replaced with underscores."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.analyze_project": {
      "identifier": "backend.diagram_generation.generator.analyze_project",
      "description": {
        "overall": "The analyze_project function is responsible for analyzing a list of repository files, specifically Python files, to generate a project index and resolve function calls. It iterates through the files, parsing their abstract syntax trees (ASTs) and collecting symbols. The function then resolves calls between modules and returns the project index and resolved calls. This process is crucial for generating diagrams that represent the project's structure and dependencies. The function utilizes various classes and functions from the diagram_generation module, such as SymbolCollector, TreeVisitor, and CallResolver, to achieve its purpose. By analyzing the project's codebase, this function provides valuable insights into the project's organization and interactions between its components.",
        "parameters": [
          {
            "name": "all_files",
            "type": "list[RepoFile]",
            "description": "A list of repository files to be analyzed."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "The generated project index."
          },
          {
            "name": "resolved_calls",
            "type": "dict",
            "description": "A dictionary of resolved function calls."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.main_diagram_generation": {
      "identifier": "backend.diagram_generation.generator.main_diagram_generation",
      "description": {
        "overall": "The `main_diagram_generation` function generates diagrams for a given list of Python files. It analyzes the project structure, resolves function calls, and emits class, component, and sequence diagrams using Mermaid emitters. The function returns a tuple containing sequence diagrams, class diagrams, and a component diagram. It relies on various modules and classes, including `analyze_project`, `MermaidClassDiagramEmitter`, `MermaidOverviewEmitter`, and `MermaidSequenceEmitter`, to perform its tasks.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[str]",
            "description": "A list of Python file paths to be analyzed for diagram generation."
          }
        ],
        "returns": [
          {
            "name": "seqs",
            "type": "dict[str, str]",
            "description": "A dictionary of sequence diagrams, where each key is a function name and the value is the corresponding sequence diagram."
          },
          {
            "name": "class_diagrams",
            "type": "dict",
            "description": "A dictionary of class diagrams, representing the project's class structure."
          },
          {
            "name": "component_diagram",
            "type": "str",
            "description": "A string representing the component diagram, which provides an overview of the project's components."
          }
        ],
        "usage_context": {
          "calls": "This function calls `backend.diagram_generation.generator.analyze_project`.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.generator.enrich_report_with_diagrams": {
      "identifier": "backend.diagram_generation.generator.enrich_report_with_diagrams",
      "description": {
        "overall": "The `enrich_report_with_diagrams` function enriches a given report by embedding diagrams from a provided dictionary. It iterates over each line of the report, checking for specific keywords to determine where to insert sequence diagrams, component diagrams, and class diagrams. The function returns the enriched report as a string.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "The initial report to be enriched with diagrams."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary containing sequence diagrams to be embedded in the report."
          },
          {
            "name": "component_diagram",
            "type": "str",
            "description": "A component diagram to be embedded in the report."
          },
          {
            "name": "class_diagrams",
            "type": "dict",
            "description": "A dictionary containing class diagrams to be embedded in the report."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "The report enriched with embedded diagrams."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.analyze_project": {
      "identifier": "backend.diagram_generation.main.analyze_project",
      "description": {
        "overall": "The `analyze_project` function is designed to analyze a list of Python files and generate a project index. It utilizes the `ast` module to parse the files, and then employs a `SymbolCollector` to collect symbols from each module. The function also resolves calls between modules using a `CallResolver`. The ultimate goal of this function appears to be the generation of a project index and resolved calls, which can be used for further analysis or visualization.",
        "parameters": [
          {
            "name": "py_files",
            "type": "list[RepoFile]",
            "description": "A list of Python files to be analyzed, where each file is an instance of `RepoFile`."
          }
        ],
        "returns": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "A project index containing information about the modules in the project."
          },
          {
            "name": "resolved_calls",
            "type": "ResolvedCall",
            "description": "A collection of resolved calls between modules in the project."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.construct_overview_diagram": {
      "identifier": "backend.diagram_generation.main.construct_overview_diagram",
      "description": {
        "overall": "The `construct_overview_diagram` function generates a list of lists containing strings, representing an overview diagram for a given project. It takes a `ProjectIndex` object as input and iterates over its modules to extract overlying packages. The function then constructs a set of unique overlying packages and returns a list of lists containing these packages. The purpose of this function appears to be related to diagram generation, possibly for visualizing project dependencies or structure.",
        "parameters": [
          {
            "name": "project",
            "type": "ProjectIndex",
            "description": "A `ProjectIndex` object representing the project for which the overview diagram is being generated."
          }
        ],
        "returns": [
          {
            "name": "packages",
            "type": "list[list[str]]",
            "description": "A list of lists containing strings, representing the overlying packages in the project."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.main.main_diagram_generation": {
      "identifier": "backend.diagram_generation.main.main_diagram_generation",
      "description": {
        "overall": "The `main_diagram_generation` function is responsible for generating sequence diagrams for a given GitHub repository. It achieves this by first retrieving all Python files from the repository, analyzing the project structure, and then resolving function calls within the project. The resolved calls are then used to generate sequence diagrams using the MermaidSequenceEmitter. The generated diagrams are appended to a file named `SequenceDiagrams_Flask_3.md`. The function appears to be designed to work with the Flask repository, but it can potentially be adapted for other repositories.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls backend.diagram_generation.main.analyze_project.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.diagram_generation.symbol_collector.attach_with_parents": {
      "identifier": "backend.diagram_generation.symbol_collector.attach_with_parents",
      "description": {
        "overall": "The `attach_with_parents` function is designed to traverse an Abstract Syntax Tree (AST) and establish parent-child relationships between nodes. It iterates over each parent node in the tree and then over each child node of the parent, setting the child's parent attribute to the current parent node. This process effectively constructs a hierarchical structure within the AST, facilitating further analysis or manipulation of the tree's components. The function operates on an input tree of type `AST` and does not return any value, indicating its purpose is to modify the tree in-place. The function's implementation relies on the `walk` and `iter_child_nodes` functions from the `ast` module to traverse the tree. By establishing these relationships, the function enables more sophisticated analysis or visualization of the code structure represented by the AST.",
        "parameters": [
          {
            "name": "tree",
            "type": "AST",
            "description": "The Abstract Syntax Tree to be processed."
          }
        ],
        "returns": [
          {
            "name": "None",
            "type": "NoneType",
            "description": "The function does not return any value, as it modifies the input tree in-place."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.create_savings_chart": {
      "identifier": "backend.main.create_savings_chart",
      "description": {
        "overall": "The `create_savings_chart` function generates a bar chart comparing JSON and TOON tokens, displaying the number of tokens and the percentage of savings. It uses matplotlib to create the chart and saves it to a specified output path. The function takes four parameters: `json_tokens`, `toon_tokens`, `savings_percent`, and `output_path`. The chart includes labels, colors, and grid lines for better readability. The function also annotates the bars with the number of tokens. Finally, the chart is saved to the specified output path and the plot is closed.",
        "parameters": [
          {
            "name": "json_tokens",
            "type": "int",
            "description": "The number of JSON tokens."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "The number of TOON tokens."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "The percentage of savings."
          },
          {
            "name": "output_path",
            "type": "str",
            "description": "The path where the chart will be saved."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.calculate_net_time": {
      "identifier": "backend.main.calculate_net_time",
      "description": {
        "overall": "The calculate_net_time function calculates the net time taken for a process, excluding sleep times due to rate limits. It takes into account the start and end times, total items, batch size, and model name. If the model name does not start with 'gemini-', it returns the total duration. Otherwise, it calculates the number of batches, sleep count, and total sleep time, then subtracts the total sleep time from the total duration to get the net time.",
        "parameters": [
          {
            "name": "start_time",
            "type": "float",
            "description": "The start time of the process."
          },
          {
            "name": "end_time",
            "type": "float",
            "description": "The end time of the process."
          },
          {
            "name": "total_items",
            "type": "int",
            "description": "The total number of items being processed."
          },
          {
            "name": "batch_size",
            "type": "int",
            "description": "The size of each batch."
          },
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model being used."
          }
        ],
        "returns": [
          {
            "name": "net_time",
            "type": "float",
            "description": "The net time taken for the process, excluding sleep times due to rate limits."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.main_workflow": {
      "identifier": "backend.main.main_workflow",
      "description": {
        "overall": "The main_workflow function is responsible for orchestrating the analysis of a given repository. It extracts API keys, model names, and other necessary information from the input, clones the repository, and then uses various helper functions to analyze the code, generate documentation, and create diagrams. The function also handles errors, logs information, and returns a report with metrics.",
        "parameters": [
          {
            "name": "user_input",
            "type": "str",
            "description": "The input provided by the user, which contains the repository URL."
          },
          {
            "name": "api_keys",
            "type": "dict",
            "description": "A dictionary containing API keys for various services."
          },
          {
            "name": "model_names",
            "type": "dict",
            "description": "A dictionary containing model names for the helper and main LLMs."
          },
          {
            "name": "status_callback",
            "type": "callable",
            "description": "An optional callback function to update the status."
          },
          {
            "name": "check_stop",
            "type": "callable",
            "description": "An optional function to check if the analysis should be stopped."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "str",
            "description": "The final report generated by the main LLM."
          },
          {
            "name": "metrics",
            "type": "dict",
            "description": "A dictionary containing metrics about the analysis, such as time taken and token usage."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.AST_Schema.ASTAnalyzer, backend.AST_Schema.ASTAnalyzer.analyze_repository, backend.AST_Schema.ASTAnalyzer.merge_relationship_data, backend.HelperLLM.LLMHelper, backend.HelperLLM.LLMHelper.generate_for_classes, backend.HelperLLM.LLMHelper.generate_for_functions, backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.diagram_generation.generator.main_diagram_generation, backend.getRepo.GitRepository, backend.main.calculate_net_time, backend.main.create_savings_chart, backend.main.enrich_report_with_diagrams, backend.main.get_key_and_url, backend.main.update_status, backend.relationship_analyzer.ProjectAnalyzer, backend.relationship_analyzer.ProjectAnalyzer.analyze, backend.relationship_analyzer.ProjectAnalyzer.get_raw_relationships, schemas.types.ClassAnalysisInput, schemas.types.ClassContextInput, schemas.types.FunctionAnalysisInput, schemas.types.FunctionContextInput, and schemas.types.MethodContextInput.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "backend.main.update_status": {
      "identifier": "backend.main.update_status",
      "description": {
        "overall": "The `update_status` function is designed to update the status of a process by logging a message and optionally calling a status callback function. It first checks if an interrupt has been triggered and raises an `InterruptedError` if so. If a status callback function is provided, it calls this function with the message. Finally, it logs the message at the info level.",
        "parameters": [
          {
            "name": "msg",
            "type": "str",
            "description": "The message to be logged and potentially passed to the status callback function."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.get_key_and_url": {
      "identifier": "backend.main.get_key_and_url",
      "description": {
        "overall": "The function `get_key_and_url` determines the correct API key and base URL for a given model name. It checks the model name against specific prefixes and returns the corresponding API key and URL. If the model name does not match any known prefixes, it falls back to using a system-defined API key and URL. The function also considers user-provided API keys and URLs for open-source models.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model for which to determine the API key and base URL."
          }
        ],
        "returns": [
          {
            "name": "API key and URL",
            "type": "tuple",
            "description": "A tuple containing the API key and base URL for the given model name. The API key may be None if no key is required for the model."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.enrich_report_with_diagrams": {
      "identifier": "backend.main.enrich_report_with_diagrams",
      "description": {
        "overall": "The `enrich_report_with_diagrams` function enriches a given report by inserting diagrams from a provided dictionary. It iterates through each line of the report, checking for specific keywords to determine where to insert the diagrams. The function supports the insertion of sequence diagrams, component diagrams, and class diagrams. It returns the enriched report as a string.",
        "parameters": [
          {
            "name": "final_report",
            "type": "str",
            "description": "The initial report to be enriched with diagrams."
          },
          {
            "name": "diagrams",
            "type": "dict",
            "description": "A dictionary containing sequence diagrams to be inserted into the report."
          },
          {
            "name": "component_diagram",
            "type": "str",
            "description": "A component diagram to be inserted into the report."
          },
          {
            "name": "class_diagrams",
            "type": "dict",
            "description": "A dictionary containing class diagrams to be inserted into the report."
          }
        ],
        "returns": [
          {
            "name": "enriched_report",
            "type": "str",
            "description": "The report enriched with the provided diagrams."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.notebook_workflow": {
      "identifier": "backend.main.notebook_workflow",
      "description": {
        "overall": "The `notebook_workflow` function is a complex workflow that analyzes input data, extracts information from GitHub repositories, and generates reports using various models. It starts by checking the input data and extracting the repository URL. It then clones the repository, extracts basic information, and processes the notebooks. The function uses different models, such as Gemini and LLaMA, to generate reports. It also handles errors and exceptions, and returns a final report with metrics.",
        "parameters": [
          {
            "name": "input",
            "type": "string",
            "description": "The input data to be analyzed."
          },
          {
            "name": "api_keys",
            "type": "dictionary",
            "description": "A dictionary containing API keys for different models."
          },
          {
            "name": "model",
            "type": "string",
            "description": "The model to be used for analysis."
          },
          {
            "name": "status_callback",
            "type": "function",
            "description": "A callback function to update the status."
          },
          {
            "name": "check_stop",
            "type": "function",
            "description": "A function to check if the workflow should be stopped."
          }
        ],
        "returns": [
          {
            "name": "report",
            "type": "string",
            "description": "The final report generated by the workflow."
          },
          {
            "name": "metrics",
            "type": "dictionary",
            "description": "A dictionary containing metrics about the workflow, such as time taken and models used."
          }
        ],
        "usage_context": {
          "calls": "This function calls backend.MainLLM.MainLLM, backend.MainLLM.MainLLM.call_llm, backend.basic_info.ProjektInfoExtractor, backend.basic_info.ProjektInfoExtractor.extrahiere_info, backend.converter.process_repo_notebooks, backend.getRepo.GitRepository, backend.main.gemini_payload, and backend.main.update_status.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.main.gemini_payload": {
      "identifier": "backend.main.gemini_payload",
      "description": {
        "overall": "The gemini_payload function generates a payload for a Gemini model based on the provided information, path, XML structure, and images. It first creates a JSON string containing the basic information and current notebook path. Then, it iterates over the XML structure to find image placeholders and appends the corresponding image URLs to the payload. Finally, it returns the constructed payload. The function appears to be designed for processing and preparing data for a specific AI model, likely for tasks such as image analysis or generation. The XML structure and image placeholders suggest a focus on visual data. The function's logic is well-structured, and its purpose is clear from the provided source code.",
        "parameters": [
          {
            "name": "info",
            "type": "dict",
            "description": "A dictionary containing basic information."
          },
          {
            "name": "path",
            "type": "str",
            "description": "The current notebook path."
          },
          {
            "name": "xml",
            "type": "str",
            "description": "The XML structure of the notebook."
          },
          {
            "name": "imgs",
            "type": "list",
            "description": "A list of images, where each image is a dictionary containing the image data."
          }
        ],
        "returns": [
          {
            "name": "payload",
            "type": "list",
            "description": "A list of dictionaries, where each dictionary represents a payload item, either text or an image URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "backend.relationship_analyzer.path_to_module": {
      "identifier": "backend.relationship_analyzer.path_to_module",
      "description": {
        "overall": "The `path_to_module` function converts a file path into a Python module path. It takes two parameters: `filepath` and `project_root`. The function attempts to calculate the relative path from the project root to the file. If this fails, it falls back to using the file's basename. The function then removes any '.py' extension from the path and replaces directory separators with dots to form the module path. If the resulting module path ends with '__init__', this suffix is removed before the path is returned.",
        "parameters": [
          {
            "name": "filepath",
            "type": "str",
            "description": "The path to the file to be converted into a module path."
          },
          {
            "name": "project_root",
            "type": "str",
            "description": "The root directory of the project, used as a reference point for calculating the relative path."
          }
        ],
        "returns": [
          {
            "name": "module_path",
            "type": "str",
            "description": "The file path converted into a Python module path."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.encrypt_text": {
      "identifier": "database.db.encrypt_text",
      "description": {
        "overall": "The `encrypt_text` function is designed to encrypt a given text using a cipher suite. It first checks if the input text is empty or if the cipher suite is not available. If either condition is true, it returns the original text. Otherwise, it encrypts the text using the cipher suite, strips any leading or trailing whitespace, encodes the text, and then decodes the encrypted result before returning it. The function is intended to secure sensitive information by converting it into an unreadable format. The encryption process relies on the `cryptography.fernet.Fernet` module, which is a symmetric encryption method. The function's purpose is to protect data from unauthorized access.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be encrypted."
          }
        ],
        "returns": [
          {
            "name": "encrypted_text",
            "type": "str",
            "description": "The encrypted text if the input is valid and the cipher suite is available; otherwise, the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.decrypt_text": {
      "identifier": "database.db.decrypt_text",
      "description": {
        "overall": "The `decrypt_text` function is designed to decrypt a given text using a cipher suite. It first checks if the input text or the cipher suite is empty or not defined. If either condition is true, it returns the original text. Otherwise, it attempts to decrypt the text using the cipher suite and returns the decrypted text. If an exception occurs during the decryption process, it catches the exception and returns the original text. The function is intended to handle potential decryption failures gracefully by returning the original text in case of an error.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The text to be decrypted."
          }
        ],
        "returns": [
          {
            "name": "decrypted_text",
            "type": "str",
            "description": "The decrypted text if decryption is successful, otherwise the original text."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_user": {
      "identifier": "database.db.insert_user",
      "description": {
        "overall": "The `insert_user` function creates a new user document in the database. It takes in three parameters: `username`, `name`, and `password`. The function hashes the provided password using `stauth.Hasher.hash` and constructs a user dictionary with the provided information, along with some default empty fields for API keys and base URLs. The function then inserts this user document into the database using `dbusers.insert_one` and returns the inserted ID.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The unique identifier for the user."
          },
          {
            "name": "name",
            "type": "str",
            "description": "The full name of the user."
          },
          {
            "name": "password",
            "type": "str",
            "description": "The password for the user, which will be hashed before storage."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted user document in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_all_users": {
      "identifier": "database.db.fetch_all_users",
      "description": {
        "overall": "The `fetch_all_users` function retrieves all users from a database. It utilizes the `dbusers.find()` method to fetch all user documents and returns them as a list. The function does not take any parameters and relies on an external database connection established elsewhere in the application. The return value is a list of user documents, which can be used for further processing or analysis. The function's simplicity suggests it is intended for use in a larger data access or business logic layer.",
        "parameters": [],
        "returns": [
          {
            "name": "users",
            "type": "list",
            "description": "A list of user documents retrieved from the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_user": {
      "identifier": "database.db.fetch_user",
      "description": {
        "overall": "The `fetch_user` function retrieves a user document from a database based on the provided `username`. It uses the `dbusers.find_one` method to query the database. The function takes a single parameter, `username`, which is expected to be a string. The function returns the user document if found, or `None` if no matching document exists. The database interaction is facilitated by the `pymongo` library, which is imported but not explicitly used in this function. The function's purpose is to provide a simple interface for fetching user data by username.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to fetch from the database."
          }
        ],
        "returns": [
          {
            "name": "user_document",
            "type": "dict or None",
            "description": "The user document retrieved from the database, or `None` if no matching document exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_user_name": {
      "identifier": "database.db.update_user_name",
      "description": {
        "overall": "The `update_user_name` function updates the name of a user in the database. It takes two parameters: `username` and `new_name`, both of which are strings. The function uses the `update_one` method from the `dbusers` collection to update the `name` field of the user document with the matching `_id` (which is set to the `username`). The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be updated."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name to be assigned to the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gemini_key": {
      "identifier": "database.db.update_gemini_key",
      "description": {
        "overall": "The `update_gemini_key` function updates a user's Gemini API key in the database. It takes two parameters: `username` and `gemini_api_key`, both of which are strings. The function encrypts the provided API key using the `encrypt_text` function and then updates the corresponding user document in the database. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Gemini API key is to be updated."
          },
          {
            "name": "gemini_api_key",
            "type": "str",
            "description": "The new Gemini API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_gpt_key": {
      "identifier": "database.db.update_gpt_key",
      "description": {
        "overall": "The `update_gpt_key` function updates a user's GPT API key in the database. It takes two parameters, `username` and `gpt_api_key`, and returns the number of documents modified. The function first encrypts the provided GPT API key using the `encrypt_text` function, then uses the `update_one` method of the `dbusers` collection to update the user's document with the encrypted key. The function is designed to securely store sensitive information, such as API keys, in the database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose GPT API key is being updated."
          },
          {
            "name": "gpt_api_key",
            "type": "str",
            "description": "The new GPT API key to be stored for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_ollama_url": {
      "identifier": "database.db.update_ollama_url",
      "description": {
        "overall": "The `update_ollama_url` function updates the `ollama_base_url` field for a given `username` in the database. It uses the `dbusers.update_one` method to perform the update. The function returns the number of documents modified by the update operation. The `ollama_base_url` is stripped of leading and trailing whitespace before being updated in the database. This function appears to be part of a larger database management system, likely used to store and manage user-specific URLs.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose `ollama_base_url` is to be updated."
          },
          {
            "name": "ollama_base_url",
            "type": "str",
            "description": "The new `ollama_base_url` to be updated for the given `username`."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_key": {
      "identifier": "database.db.update_opensrc_key",
      "description": {
        "overall": "The `update_opensrc_key` function updates the Open Source API key for a given user in the database. It takes two parameters: `username` and `opensrc_api_key`. The function first encrypts the provided API key using the `encrypt_text` function. Then, it uses the `update_one` method of the `dbusers` collection to update the `opensrc_api_key` field for the specified user. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be updated."
          },
          {
            "name": "opensrc_api_key",
            "type": "str",
            "description": "The new Open Source API key to be updated for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.encrypt_text.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_opensrc_url": {
      "identifier": "database.db.update_opensrc_url",
      "description": {
        "overall": "The `update_opensrc_url` function updates the `opensrc_base_url` field for a user in the database. It takes two parameters: `username` and `opensrc_base_url`. The function uses the `dbusers.update_one` method to update the user's document in the database. The `opensrc_base_url` is stripped of any leading or trailing whitespace before being updated. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to update."
          },
          {
            "name": "opensrc_base_url",
            "type": "str",
            "description": "The new opensrc base URL to update for the user."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gemini_key": {
      "identifier": "database.db.fetch_gemini_key",
      "description": {
        "overall": "The `fetch_gemini_key` function retrieves a Gemini API key associated with a given username from a MongoDB database. It uses the `dbusers` collection and filters the result to only include the `gemini_api_key` field. If a user with the provided username is found, the function returns their Gemini API key; otherwise, it returns `None`. This function appears to be part of a larger system that manages user data and API keys. The function's implementation is straightforward, relying on MongoDB's query capabilities to fetch the desired data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the Gemini API key."
          }
        ],
        "returns": [
          {
            "name": "gemini_api_key",
            "type": "str or None",
            "description": "The Gemini API key associated with the provided username, or `None` if no user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_ollama_url": {
      "identifier": "database.db.fetch_ollama_url",
      "description": {
        "overall": "The `fetch_ollama_url` function retrieves the Ollama base URL for a given username from a database. It uses the `dbusers` collection to find a document with the specified username and returns the `ollama_base_url` field if found. If no document is found, the function returns `None`. The function takes a single parameter, `username`, which is expected to be a string. The function does not perform any error handling beyond checking if a document is found. The database connection and collection are assumed to be established elsewhere in the codebase.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to retrieve the Ollama base URL for."
          }
        ],
        "returns": [
          {
            "name": "ollama_base_url",
            "type": "str or None",
            "description": "The Ollama base URL for the given username, or `None` if no document is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_gpt_key": {
      "identifier": "database.db.fetch_gpt_key",
      "description": {
        "overall": "The `fetch_gpt_key` function retrieves the GPT API key associated with a given username from a database. It uses the `dbusers` collection and filters the result to only include the `gpt_api_key` field. If a user with the specified username is found, the function returns their GPT API key; otherwise, it returns `None`. The function takes a single parameter, `username`, which is expected to be a string. This function appears to be part of a larger system that utilizes a MongoDB database and handles user authentication. The function's logic is straightforward, relying on the `find_one` method of the `dbusers` collection to retrieve the desired data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the GPT API key."
          }
        ],
        "returns": [
          {
            "name": "gpt_api_key",
            "type": "str or None",
            "description": "The GPT API key associated with the specified username, or `None` if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_key": {
      "identifier": "database.db.fetch_opensrc_key",
      "description": {
        "overall": "The `fetch_opensrc_key` function retrieves the Open Source API key associated with a given username from the database. It uses the `dbusers` collection and filters the results to include only the `opensrc_api_key` field. If a user with the specified username is found, the function returns their Open Source API key; otherwise, it returns `None`. This function appears to be part of a larger system that manages user data and API keys. The function's implementation is straightforward, relying on a simple database query to fetch the required information.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose Open Source API key is to be retrieved."
          }
        ],
        "returns": [
          {
            "name": "opensrc_api_key",
            "type": "str or None",
            "description": "The Open Source API key associated with the given username, or `None` if no such user exists."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_opensrc_url": {
      "identifier": "database.db.fetch_opensrc_url",
      "description": {
        "overall": "The `fetch_opensrc_url` function retrieves the open source base URL associated with a given username from the database. It uses the `dbusers` collection and filters the result to only include the `opensrc_base_url` field. If a user with the specified username is found, the function returns the `opensrc_base_url`; otherwise, it returns `None`. This function appears to be part of a larger system that manages user data and open source URLs. The function's implementation is straightforward, using a simple database query to retrieve the desired information.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve the open source base URL."
          }
        ],
        "returns": [
          {
            "name": "opensrc_base_url",
            "type": "str or None",
            "description": "The open source base URL associated with the given username, or `None` if no user is found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_user": {
      "identifier": "database.db.delete_user",
      "description": {
        "overall": "The `delete_user` function is designed to delete a user from the database based on their username. It utilizes the `dbusers.delete_one` method to remove the user document from the database. The function returns the number of documents deleted, which should be 1 if the user exists and 0 if the user does not exist. This function appears to be part of a larger database management system, likely using MongoDB as the database. The function's implementation is straightforward, relying on the `delete_one` method to handle the deletion logic.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user to be deleted from the database."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted from the database, which should be 1 if the user exists and 0 if the user does not exist."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.get_decrypted_api_keys": {
      "identifier": "database.db.get_decrypted_api_keys",
      "description": {
        "overall": "The `get_decrypted_api_keys` function retrieves and decrypts API keys for a given user. It queries the database for a user with the provided `username`, and if found, decrypts the stored API keys using the `decrypt_text` function. The function returns the decrypted API keys for Gemini, Ollama, GPT, and OpenSrc, along with the OpenSrc base URL. If the user is not found, the function returns `None` for all values.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to retrieve API keys."
          }
        ],
        "returns": [
          {
            "name": "gemini_plain",
            "type": "str",
            "description": "The decrypted Gemini API key."
          },
          {
            "name": "ollama_plain",
            "type": "str",
            "description": "The Ollama base URL."
          },
          {
            "name": "gpt_plain",
            "type": "str",
            "description": "The decrypted GPT API key."
          },
          {
            "name": "opensrc_plain",
            "type": "str",
            "description": "The decrypted OpenSrc API key."
          },
          {
            "name": "opensrc_url",
            "type": "str",
            "description": "The OpenSrc base URL."
          }
        ],
        "usage_context": {
          "calls": "This function calls database.db.decrypt_text.",
          "called_by": "This function is called by no other functions."
        }
      },
      "error": null
    },
    "database.db.insert_chat": {
      "identifier": "database.db.insert_chat",
      "description": {
        "overall": "The `insert_chat` function creates a new chat entry in the database. It takes two parameters, `username` and `chat_name`, and generates a unique identifier for the chat using `uuid.uuid4()`. The function then inserts a new document into the database with the provided information and returns the inserted ID. The chat entry includes the username, chat name, and a timestamp for when it was created. This function appears to be part of a larger system for managing chat data.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat."
          }
        ],
        "returns": [
          {
            "name": "inserted_id",
            "type": "ObjectId",
            "description": "The ID of the newly inserted chat document."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_chats_by_user": {
      "identifier": "database.db.fetch_chats_by_user",
      "description": {
        "overall": "The `fetch_chats_by_user` function retrieves all chats defined by a specific user. It queries a database using the provided `username` and returns the results sorted by creation time. The function utilizes a MongoDB database, as indicated by the `dbchats.find` method. The results are returned as a list of chat objects. This function appears to be part of a larger system that manages user interactions and chat history.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user for whom to fetch chats."
          }
        ],
        "returns": [
          {
            "name": "chats",
            "type": "list",
            "description": "A list of chat objects associated with the provided username, sorted by creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.check_chat_exists": {
      "identifier": "database.db.check_chat_exists",
      "description": {
        "overall": "The `check_chat_exists` function checks if a chat exists in the database for a given username and chat name. It uses the `dbchats.find_one` method to query the database. If a document matching the username and chat name is found, the function returns `True`, indicating the chat exists. Otherwise, it returns `False`. This function relies on the `dbchats` collection being properly configured and connected. The function takes two parameters, `username` and `chat_name`, both of which are strings.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to check for the chat existence."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to check for existence."
          }
        ],
        "returns": [
          {
            "name": "existence",
            "type": "bool",
            "description": "A boolean indicating whether the chat exists for the given username and chat name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.rename_chat_fully": {
      "identifier": "database.db.rename_chat_fully",
      "description": {
        "overall": "The `rename_chat_fully` function renames a chat and all associated exchanges for a given user. It takes three parameters: `username`, `old_name`, and `new_name`, and returns the number of documents modified in the database. The function first updates the chat entry with the new name, and then updates all messages (exchanges) associated with the chat. The function uses MongoDB to perform these updates.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user whose chat is being renamed."
          },
          {
            "name": "old_name",
            "type": "str",
            "description": "The current name of the chat."
          },
          {
            "name": "new_name",
            "type": "str",
            "description": "The new name for the chat."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified in the database."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.insert_exchange": {
      "identifier": "database.db.insert_exchange",
      "description": {
        "overall": "The `insert_exchange` function is designed to insert a new exchange record into a database. It takes in various parameters such as question, answer, feedback, username, and chat name, along with optional parameters like helper used, main used, total time, and more. The function generates a unique ID for the new exchange and attempts to insert it into the database. If successful, it returns the new ID; otherwise, it catches any exceptions, prints an error message, and returns None.",
        "parameters": [
          {
            "name": "question",
            "type": "str",
            "description": "The question being asked in the exchange."
          },
          {
            "name": "answer",
            "type": "str",
            "description": "The answer provided in the exchange."
          },
          {
            "name": "feedback",
            "type": "str",
            "description": "The feedback given in the exchange."
          },
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user involved in the exchange."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat where the exchange occurred."
          },
          {
            "name": "helper_used",
            "type": "str",
            "description": "Optional parameter indicating the helper used, defaults to an empty string."
          },
          {
            "name": "main_used",
            "type": "str",
            "description": "Optional parameter indicating the main used, defaults to an empty string."
          },
          {
            "name": "total_time",
            "type": "str",
            "description": "Optional parameter for the total time, defaults to an empty string."
          },
          {
            "name": "helper_time",
            "type": "str",
            "description": "Optional parameter for the helper time, defaults to an empty string."
          },
          {
            "name": "main_time",
            "type": "str",
            "description": "Optional parameter for the main time, defaults to an empty string."
          },
          {
            "name": "json_tokens",
            "type": "int",
            "description": "Optional parameter for JSON tokens, defaults to 0."
          },
          {
            "name": "toon_tokens",
            "type": "int",
            "description": "Optional parameter for Toon tokens, defaults to 0."
          },
          {
            "name": "savings_percent",
            "type": "float",
            "description": "Optional parameter for savings percentage, defaults to 0.0."
          }
        ],
        "returns": [
          {
            "name": "new_id",
            "type": "str",
            "description": "The unique ID of the newly inserted exchange, or None if the insertion fails."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_user": {
      "identifier": "database.db.fetch_exchanges_by_user",
      "description": {
        "overall": "This function, `fetch_exchanges_by_user`, retrieves a list of exchanges associated with a given username from a database. It uses the `dbexchanges` collection and sorts the results by the `created_at` timestamp in ascending order. The function takes a `username` as input and returns a list of exchanges. The sorting is crucial for the proper display of the exchanges. The function utilizes the `pymongo` library to interact with the database.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to retrieve exchanges."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges associated with the given username, sorted by creation timestamp."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.fetch_exchanges_by_chat": {
      "identifier": "database.db.fetch_exchanges_by_chat",
      "description": {
        "overall": "The `fetch_exchanges_by_chat` function retrieves a list of exchanges from the database that match the specified `username` and `chat_name`. It uses the `dbexchanges` collection and sorts the results by the `created_at` field in ascending order. The function returns a list of exchanges that meet the specified criteria. This function appears to be part of a larger system that interacts with a MongoDB database. The purpose of this function is to fetch specific data from the database based on user and chat identifiers.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username to filter exchanges by."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The chat name to filter exchanges by."
          }
        ],
        "returns": [
          {
            "name": "exchanges",
            "type": "list",
            "description": "A list of exchanges that match the specified username and chat name, sorted by creation time."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback": {
      "identifier": "database.db.update_exchange_feedback",
      "description": {
        "overall": "The update_exchange_feedback function updates the feedback field of a document in a MongoDB database. It takes two parameters: exchange_id and feedback. The function uses the dbexchanges collection and updates the document with the specified exchange_id by setting its feedback field to the provided feedback value. The function returns the number of documents modified by the update operation. This function appears to be part of a larger system that interacts with a MongoDB database, possibly for storing and managing exchange-related data.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "unknown",
            "description": "The ID of the exchange to be updated."
          },
          {
            "name": "feedback",
            "type": "int",
            "description": "The feedback value to be set for the specified exchange."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.update_exchange_feedback_message": {
      "identifier": "database.db.update_exchange_feedback_message",
      "description": {
        "overall": "The update_exchange_feedback_message function updates the feedback message for a given exchange in the database. It takes two parameters: exchange_id and feedback_message. The function uses the dbexchanges collection to update the feedback message. The function returns the number of documents modified by the update operation.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "unknown",
            "description": "The ID of the exchange to update."
          },
          {
            "name": "feedback_message",
            "type": "str",
            "description": "The new feedback message to be updated."
          }
        ],
        "returns": [
          {
            "name": "modified_count",
            "type": "int",
            "description": "The number of documents modified by the update operation."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_exchange_by_id": {
      "identifier": "database.db.delete_exchange_by_id",
      "description": {
        "overall": "The `delete_exchange_by_id` function deletes a single exchange document from the database based on its unique identifier. It uses the `dbexchanges.delete_one` method to perform the deletion. The function returns the number of documents deleted, which should be either 0 (if no document was found) or 1 (if a document was successfully deleted). This function appears to be part of a larger database management system, utilizing the `pymongo` library to interact with a MongoDB database. The function's logic is straightforward, with no conditional statements or loops, making it a simple yet effective tool for removing exchanges by their ID.",
        "parameters": [
          {
            "name": "exchange_id",
            "type": "str",
            "description": "The unique identifier of the exchange to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of documents deleted, which should be either 0 or 1."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "database.db.delete_full_chat": {
      "identifier": "database.db.delete_full_chat",
      "description": {
        "overall": "The `delete_full_chat` function deletes a full chat and all associated exchanges from the database. It ensures consistency between the frontend and backend by removing all related data in two steps: first, it deletes all messages in the specified chat, and then it removes the chat itself from the chat list. The function takes two parameters, `username` and `chat_name`, and returns the number of chats deleted.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username associated with the chat to be deleted."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [
          {
            "name": "deleted_count",
            "type": "int",
            "description": "The number of chats deleted."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.clean_names": {
      "identifier": "frontend.frontend.clean_names",
      "description": {
        "overall": "The `clean_names` function takes a list of model names as input and returns a new list with the names cleaned by removing any path prefixes. It uses a list comprehension to split each name by the '/' character and keeps only the last part. This function appears to be designed to extract the base name of a model from a potentially full path or identifier.",
        "parameters": [
          {
            "name": "model_list",
            "type": "list",
            "description": "A list of model names that may contain path prefixes."
          }
        ],
        "returns": [
          {
            "name": "cleaned_model_list",
            "type": "list",
            "description": "A list of cleaned model names with path prefixes removed."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_filtered_models": {
      "identifier": "frontend.frontend.get_filtered_models",
      "description": {
        "overall": "The `get_filtered_models` function filters a list of models based on a selected category. It uses a dictionary `CATEGORY_KEYWORDS` to map category names to keywords. If the category is 'STANDARD', it returns a list of standard models. Otherwise, it filters the list by checking if any keyword is present in the model name. If no models match the filter, it returns the original list.",
        "parameters": [
          {
            "name": "source_list",
            "type": "list",
            "description": "The list of models to be filtered."
          },
          {
            "name": "category_name",
            "type": "str",
            "description": "The name of the category to filter by."
          }
        ],
        "returns": [
          {
            "name": "filtered_list",
            "type": "list",
            "description": "The filtered list of models."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_abort": {
      "identifier": "frontend.frontend.handle_abort",
      "description": {
        "overall": "The `handle_abort` function is designed to handle an abort request. It sets the `abort_requested` attribute in the `st.session_state` object to `True` and displays a toast message indicating that the abort is being processed. This function appears to be part of a Streamlit application, given the use of `st.session_state` and `st.toast`. The toast message is a Unicode character representing a warning sign, followed by the text 'Abbruch wird verarbeitet...'. The function does not take any parameters and does not return any value.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_gemini_cb": {
      "identifier": "frontend.frontend.save_gemini_cb",
      "description": {
        "overall": "The `save_gemini_cb` function is designed to save a Gemini key to the database. It retrieves the new key from the session state, checks if it exists, and if so, updates the Gemini key in the database for the current user. After updating, it clears the session state variable and displays a success toast message.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.save_ollama_cb": {
      "identifier": "frontend.frontend.save_ollama_cb",
      "description": {
        "overall": "The `save_ollama_cb` function is designed to save a new Ollama URL to the database. It retrieves the new URL from the session state and checks if it is not empty. If the URL is valid, it updates the Ollama URL in the database for the current user and displays a toast message indicating that the URL has been saved successfully. The function appears to be part of a Streamlit application, utilizing session state and database interactions. It relies on the `database.db` module for updating the Ollama URL. The function does not take any parameters and does not return any values.",
        "parameters": [],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_ollama_url.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_last_activity": {
      "identifier": "frontend.frontend.get_last_activity",
      "description": {
        "overall": "The `get_last_activity` function determines the timestamp of the last message in a specified chat. It retrieves chat data from the session state, checks for any exchanges, and returns the creation date if no exchanges are found. Otherwise, it extracts the datetime from the last exchange and attempts to parse it from a string if necessary. The function returns the datetime object representing the last activity in the chat.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat for which to retrieve the last activity timestamp."
          }
        ],
        "returns": [
          {
            "name": "datetime",
            "type": "datetime.datetime",
            "description": "The timestamp of the last message in the specified chat, or the creation date if no messages are found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.load_data_from_db": {
      "identifier": "frontend.frontend.load_data_from_db",
      "description": {
        "overall": "The `load_data_from_db` function is responsible for loading data from the database for a given username. It checks if the user's data has already been loaded and if not, it fetches the user's chats and exchanges from the database, populates the session state with this data, and sets the active chat. If no chats are found, it creates an initial chat and sets it as the active chat.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username for which to load data from the database."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.fetch_chats_by_user, database.db.fetch_exchanges_by_user, and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_feedback_change": {
      "identifier": "frontend.frontend.handle_feedback_change",
      "description": {
        "overall": "The `handle_feedback_change` function updates the feedback for an exchange in the database and triggers a rerun of the Streamlit application. It takes two parameters, `ex` and `val`, where `ex` is expected to be a dictionary containing an `_id` key and `val` is the new feedback value. The function modifies the `ex` dictionary in-place by updating the `feedback` key with the provided `val`. It then calls the `update_exchange_feedback` function from the `database.db` module to persist this change in the database. Finally, it triggers a rerun of the Streamlit application using `st.rerun()` to reflect the updated feedback.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing an `_id` key, representing the exchange to be updated."
          },
          {
            "name": "val",
            "type": "str",
            "description": "The new feedback value to be updated for the exchange."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_exchange": {
      "identifier": "frontend.frontend.handle_delete_exchange",
      "description": {
        "overall": "The `handle_delete_exchange` function is responsible for deleting an exchange from the database and updating the session state accordingly. It takes two parameters: `chat_name` and `ex`, where `ex` is expected to be a dictionary containing an `_id` key. The function first deletes the exchange from the database using the `database.db.delete_exchange_by_id` function. Then, it checks if the `chat_name` exists in the session state and if the exchange is present in the list of exchanges for that chat. If both conditions are met, it removes the exchange from the list. Finally, the function triggers a rerun of the Streamlit application using `st.rerun()`. This function appears to be part of a larger application that manages chat exchanges and updates the UI dynamically.",
        "parameters": [
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat from which the exchange is being deleted."
          },
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary representing the exchange to be deleted, containing an '_id' key."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_exchange_by_id.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.handle_delete_chat": {
      "identifier": "frontend.frontend.handle_delete_chat",
      "description": {
        "overall": "The `handle_delete_chat` function is responsible for deleting a specified chat from the database and updating the session state accordingly. It takes two parameters: `username` and `chat_name`. The function first deletes the full chat from the database using the `db.delete_full_chat` method. Then, it removes the chat from the session state if it exists. If there are remaining chats in the session state, it sets the first chat as the active one. Otherwise, it creates a new chat, inserts it into the database, and updates the session state. Finally, the function triggers a rerun of the Streamlit application using `st.rerun()`.",
        "parameters": [
          {
            "name": "username",
            "type": "str",
            "description": "The username of the user deleting the chat."
          },
          {
            "name": "chat_name",
            "type": "str",
            "description": "The name of the chat to be deleted."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.delete_full_chat and database.db.insert_chat.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.extract_repo_name": {
      "identifier": "frontend.frontend.extract_repo_name",
      "description": {
        "overall": "The `extract_repo_name` function takes a text input and attempts to extract a repository name from it. It uses regular expressions to find a URL within the text, then parses the URL to extract the path. The function splits the path by '/' and takes the last part as the potential repository name. If the name ends with '.git', it removes this suffix before returning the repository name. If no URL is found in the text or if the path is empty, the function returns None.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text from which to extract the repository name."
          }
        ],
        "returns": [
          {
            "name": "repo_name",
            "type": "str or None",
            "description": "The extracted repository name, or None if no repository name could be found."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.stream_text_generator": {
      "identifier": "frontend.frontend.stream_text_generator",
      "description": {
        "overall": "The stream_text_generator function takes a string of text as input and generates a stream of words from the text, pausing for 0.01 seconds between each word. This function is designed to simulate a streaming effect, where words are yielded one at a time. The function uses a generator to produce the stream of words, allowing it to be used in a loop or other context where an iterable is expected. The function does not perform any error checking on the input text, so it assumes that the input will be a string. The function also does not handle any exceptions that may occur during execution, such as a KeyboardInterrupt if the user interrupts the program.",
        "parameters": [
          {
            "name": "text",
            "type": "str",
            "description": "The input text to be streamed."
          }
        ],
        "returns": [
          {
            "name": "word",
            "type": "str",
            "description": "A word from the input text, followed by a space."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_text_with_mermaid": {
      "identifier": "frontend.frontend.render_text_with_mermaid",
      "description": {
        "overall": "The `render_text_with_mermaid` function is designed to render markdown text that may contain mermaid diagrams. It splits the input text into parts based on mermaid code blocks and then renders each part accordingly. If the `should_stream` parameter is `True`, it uses the `stream_text_generator` function to stream the text; otherwise, it uses `st.markdown` to render the text. For mermaid code blocks, it attempts to render them using `st_mermaid` and falls back to `st.code` if rendering fails.",
        "parameters": [
          {
            "name": "markdown_text",
            "type": "str",
            "description": "The markdown text to be rendered, which may contain mermaid diagrams."
          },
          {
            "name": "should_stream",
            "type": "bool",
            "description": "A flag indicating whether to stream the text using `stream_text_generator` or render it directly using `st.markdown`. Defaults to `False`."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls frontend.frontend.stream_text_generator.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_exchange": {
      "identifier": "frontend.frontend.render_exchange",
      "description": {
        "overall": "The `render_exchange` function is responsible for rendering an exchange between a user and an assistant in a chat interface. It takes two parameters: `ex` and `current_chat_name`. The function first writes the user's question to the chat, then checks if the answer is an error message. If it is, the function displays the error message and provides a button to delete the error message. If the answer is not an error message, the function displays the answer and provides buttons for feedback, including upvoting, downvoting, and saving a note. The function also includes a download button for the answer and a delete button for the exchange.",
        "parameters": [
          {
            "name": "ex",
            "type": "dict",
            "description": "A dictionary containing information about the exchange, including the question, answer, and feedback."
          },
          {
            "name": "current_chat_name",
            "type": "str",
            "description": "The name of the current chat."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_exchange_feedback_message, frontend.frontend.handle_delete_exchange, frontend.frontend.handle_feedback_change, and frontend.frontend.render_text_with_mermaid.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.get_provider": {
      "identifier": "frontend.frontend.get_provider",
      "description": {
        "overall": "The get_provider function takes a model_name as input and returns the corresponding provider name. It checks if the model_name is empty or 'None', in which case it returns None. Otherwise, it checks the model_name against specific prefixes or values and returns the corresponding provider name. If no match is found, it defaults to 'Open Source LLM'. The function appears to be used for mapping model names to their respective providers.",
        "parameters": [
          {
            "name": "model_name",
            "type": "str",
            "description": "The name of the model to get the provider for."
          }
        ],
        "returns": [
          {
            "name": "provider_name",
            "type": "str",
            "description": "The name of the provider corresponding to the model_name."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.render_config_form": {
      "identifier": "frontend.frontend.render_config_form",
      "description": {
        "overall": "The `render_config_form` function is responsible for rendering a configuration form based on the provided `model_name`. It determines the provider for the given model and then displays a form to update the corresponding configuration, such as Gemini Key, Llama URL, GPT Key, or Open Source Key and URL. The function uses Streamlit to create the form and handle user input, and it updates the configuration in the database using the `database.db` module. The function also handles errors and provides feedback to the user through success messages and reruns the application after updating the configuration.",
        "parameters": [
          {
            "name": "model_name",
            "type": "string",
            "description": "The name of the model for which the configuration form is being rendered."
          }
        ],
        "returns": [],
        "usage_context": {
          "calls": "This function calls database.db.update_gemini_key, database.db.update_gpt_key, database.db.update_ollama_url, database.db.update_opensrc_key, database.db.update_opensrc_url, and frontend.frontend.get_provider.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    },
    "frontend.frontend.check_stop_callback": {
      "identifier": "frontend.frontend.check_stop_callback",
      "description": {
        "overall": "The `check_stop_callback` function checks if the user has requested to stop or abort a process. It does this by retrieving the value of 'abort_requested' from the session state, defaulting to False if the key is not present. This function appears to be part of a larger system that utilizes Streamlit for the frontend and potentially interacts with a backend service.",
        "parameters": [],
        "returns": [
          {
            "name": "abort_requested",
            "type": "bool",
            "description": "A boolean indicating whether the user has requested to stop or abort a process."
          }
        ],
        "usage_context": {
          "calls": "This function calls no other functions.",
          "called_by": "This function is not called by any other functions."
        }
      },
      "error": null
    }
  },
  "classes": {}
}