{
    "functions": {
        "backend.AST_Schema.path_to_module": {
            "identifier": "backend.AST_Schema.path_to_module",
            "description": {
                "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '.__init__', it removes the trailing part to correctly represent the module.",
                "parameters": [
                    {
                        "name": "filepath",
                        "type": "str",
                        "description": "The absolute or relative path to a Python file."
                    },
                    {
                        "name": "project_root",
                        "type": "str",
                        "description": "The root directory of the project used to compute the relative path."
                    }
                ],
                "returns": [
                    {
                        "name": "module_path",
                        "type": "str",
                        "description": "A dot-separated module path derived from the given file path."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the __init__ method in AST_Schema.py at line 31."
                }
            },
            "error": null
        },
        "backend.File_Dependency.build_file_dependency_graph": {
            "identifier": "backend.File_Dependency.build_file_dependency_graph",
            "description": {
                "overall": "This function constructs a directed graph representing file dependencies within a repository. It takes an AST representation of a file and uses a custom visitor to extract import dependencies. The resulting graph captures relationships between files based on their import statements. Each node in the graph represents a file, and edges represent dependency relationships from importer to imported files.",
                "parameters": [
                    {
                        "name": "filename",
                        "type": "str",
                        "description": "The name of the file being analyzed for dependencies."
                    },
                    {
                        "name": "tree",
                        "type": "AST",
                        "description": "The abstract syntax tree representation of the file's source code."
                    },
                    {
                        "name": "repo_root",
                        "type": "str",
                        "description": "The root directory path of the repository being analyzed."
                    }
                ],
                "returns": [
                    {
                        "name": "graph",
                        "type": "nx.DiGraph",
                        "description": "A directed graph where nodes represent files and edges represent import dependencies."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not directly call other functions from the provided context.",
                    "called_by": "This function is called by the build_repository_graph function in File_Dependency.py at line 177."
                }
            },
            "error": null
        },
        "backend.File_Dependency.build_repository_graph": {
            "identifier": "backend.File_Dependency.build_repository_graph",
            "description": {
                "overall": "This function constructs a dependency graph for all Python files within a given Git repository. It iterates through each Python file, parses its content into an abstract syntax tree (AST), and builds a file-level dependency graph. These individual graphs are then merged into a single global directed graph that represents dependencies across the entire repository. The function ensures that nodes and edges from each file's dependency graph are properly added to the global graph.",
                "parameters": [
                    {
                        "name": "repository",
                        "type": "GitRepository",
                        "description": "The Git repository object containing the files to analyze for dependencies."
                    }
                ],
                "returns": [
                    {
                        "name": "global_graph",
                        "type": "nx.DiGraph",
                        "description": "A NetworkX directed graph representing the dependency relationships between Python files in the repository."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not directly call any other user-defined functions; it relies on imported utilities such as ast.parse, networkx.DiGraph, and build_file_dependency_graph.",
                    "called_by": "This function is called by the module backend.File_Dependency at line 233 in File_Dependency.py."
                }
            },
            "error": null
        },
        "backend.File_Dependency.get_all_temp_files": {
            "identifier": "backend.File_Dependency.get_all_temp_files",
            "description": {
                "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories, returning them as relative paths from the given directory. It resolves the input directory to an absolute path to ensure consistent behavior. The function uses the `rglob` method to recursively find all matching files and constructs relative paths using the `relative_to` method.",
                "parameters": [
                    {
                        "name": "directory",
                        "type": "str",
                        "description": "The path to the directory from which to search for Python files."
                    }
                ],
                "returns": [
                    {
                        "name": "all_files",
                        "type": "list[Path]",
                        "description": "A list of pathlib.Path objects representing the relative paths of all .py files found in the directory and its subdirectories."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by _resolve_module_name in File_Dependency.py at line 43."
                }
            },
            "error": null
        },
        "backend.File_Dependency.nx_to_mermaid_with_folders": {
            "identifier": "backend.File_Dependency.nx_to_mermaid_with_folders",
            "description": {
                "overall": "This function converts a NetworkX directed graph representing file dependencies into a Mermaid.js graph visualization format. It organizes nodes into folders and root-level files, creating subgraphs for each folder and rendering edges between nodes. The function processes nodes by splitting their paths to determine folder structures and maps them accordingly.",
                "parameters": [
                    {
                        "name": "G",
                        "type": "nx.DiGraph",
                        "description": "A NetworkX directed graph where nodes represent file paths and edges represent dependencies between files."
                    }
                ],
                "returns": [
                    {
                        "name": "mermaid_output",
                        "type": "str",
                        "description": "A string containing the Mermaid.js formatted graph representation with subgraphs for folders and direct edges between nodes."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses collections.defaultdict to manage folder mappings but does not call any other external functions.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "backend.HelperLLM.main_orchestrator": {
            "identifier": "backend.HelperLLM.main_orchestrator",
            "description": {
                "overall": "The main_orchestrator function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analyses for three example functions: add_item, check_stock, and generate_report. These analyses are then passed to the LLMHelper to simulate documentation generation for these functions. The function also includes logic to process and display the final documentation results.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it uses the LLMHelper class to perform operations.",
                    "called_by": "Called by backend.HelperLLM (line 419 in HelperLLM.py)"
                }
            },
            "error": null
        },
        "backend.callgraph.make_safe_dot": {
            "identifier": "backend.callgraph.make_safe_dot",
            "description": {
                "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a safe version of the graph by relabeling all nodes with unique identifiers prefixed by 'n', ensuring node names are safe for use in graph visualization tools like Graphviz. The original node labels are preserved in the 'label' attribute of the new nodes. Finally, it writes the transformed graph to a DOT file at the specified output path.",
                "parameters": [
                    {
                        "name": "graph",
                        "type": "nx.DiGraph",
                        "description": "A NetworkX directed graph to be processed and saved as a DOT file."
                    },
                    {
                        "name": "out_path",
                        "type": "str",
                        "description": "The file path where the DOT representation of the graph will be written."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the function 'backend.callgraph' in the file 'callgraph.py' at line 252."
                }
            },
            "error": null
        },
        "backend.callgraph.build_filtered_callgraph": {
            "identifier": "backend.callgraph.build_filtered_callgraph",
            "description": {
                "overall": "Die Funktion erstellt einen globalen Call-Graphen basierend auf allen Python-Dateien eines Git-Repositories und filtert diesen anschließend auf Funktionen, die vom Benutzer selbst geschrieben wurden. Sie durchläuft alle Dateien, parst deren Inhalt mit dem Abstract Syntax Tree (AST), extrahiert Funktionsaufrufe und baut einen gerichteten Graphen auf, wobei nur Kanten zwischen eigenen Funktionen erhalten bleiben. Der resultierende Graph enthält Knoten für Funktionen und gerichtete Kanten für Aufrufe zwischen diesen.",
                "parameters": [
                    {
                        "name": "repo",
                        "type": "GitRepository",
                        "description": "Ein Objekt, das Informationen über ein Git-Repository bereitstellt, insbesondere die Liste aller Dateien im Repository."
                    }
                ],
                "returns": [
                    {
                        "name": "global_graph",
                        "type": "nx.DiGraph",
                        "description": "Ein gerichteter Graph (DiGraph) von NetworkX, der die Aufrufbeziehungen zwischen selbstgeschriebenen Funktionen darstellt."
                    }
                ],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes direkt auf, sondern verwendet externe Klassen und Module wie 'ast', 'networkx' und 'CallGraph'.",
                    "called_by": "Diese Funktion wird von 'analyze_repository' in 'AST_Schema.py' und von 'backend.callgraph' in 'callgraph.py' aufgerufen."
                }
            },
            "error": null
        },
        "backend.main.create_savings_chart": {
            "identifier": "backend.main.create_savings_chart",
            "description": {
                "overall": "Die Funktion erstellt ein Balkendiagramm zur Visualisierung des Token-Vergleichs zwischen JSON und TOON-Formaten und speichert das Diagramm in einer Datei. Sie verwendet matplotlib zur Erstellung des Diagramms und zeigt die Anzahl der Token sowie den Prozentsatz der Einsparung im Titel an. Die Balken sind farblich unterschiedlich gekennzeichnet, und die Werte werden über den Balken angezeigt.",
                "parameters": [
                    {
                        "name": "json_tokens",
                        "type": "int",
                        "description": "Die Anzahl der Token im JSON-Format."
                    },
                    {
                        "name": "toon_tokens",
                        "type": "int",
                        "description": "Die Anzahl der Token im TOON-Format."
                    },
                    {
                        "name": "savings_percent",
                        "type": "float",
                        "description": "Der Prozentsatz der Einsparung zwischen den beiden Formaten."
                    },
                    {
                        "name": "output_path",
                        "type": "str",
                        "description": "Der Dateipfad, unter dem das generierte Diagramm gespeichert wird."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes auf.",
                    "called_by": "Die Funktion wird von der Funktion 'main_workflow' in der Datei 'main.py' aufgerufen."
                }
            },
            "error": null
        },
        "backend.main.calculate_net_time": {
            "identifier": "backend.main.calculate_net_time",
            "description": {
                "overall": "The function calculates the net time duration by subtracting sleep times related to rate limits from the total time elapsed between a start and end time. It specifically handles cases where the model name starts with 'gemini-' and adjusts the calculation based on the number of batches and item count. If the model is not a gemini model, it returns the total duration directly. For zero items, it returns zero. Otherwise, it computes the sleep time based on batch count and subtracts it from the total duration.",
                "parameters": [
                    {
                        "name": "start_time",
                        "type": "float or datetime",
                        "description": "The starting timestamp or time value."
                    },
                    {
                        "name": "end_time",
                        "type": "float or datetime",
                        "description": "The ending timestamp or time value."
                    },
                    {
                        "name": "total_items",
                        "type": "int",
                        "description": "The total number of items processed."
                    },
                    {
                        "name": "batch_size",
                        "type": "int",
                        "description": "The size of each batch of items."
                    },
                    {
                        "name": "model_name",
                        "type": "str",
                        "description": "The name of the model being used, which determines whether rate limit adjustments apply."
                    }
                ],
                "returns": [
                    {
                        "name": "net_time",
                        "type": "float or int",
                        "description": "The calculated net time after subtracting sleep durations from the total duration."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions internally.",
                    "called_by": "This function is called by the evaluation function in evaluation.py at lines 252 and 281, and by the main_workflow function in main.py at lines 304 and 335."
                }
            },
            "error": null
        },
        "backend.main.main_workflow": {
            "identifier": "backend.main.main_workflow",
            "description": {
                "overall": "The `main_workflow` function orchestrates a comprehensive code analysis pipeline for a given GitHub repository. It begins by validating and extracting API keys and model configurations, then clones the repository and retrieves all its files. The function proceeds to extract basic project information, construct a file tree, and perform relationship analysis on the codebase. It generates an Abstract Syntax Tree (AST) schema and enriches it with relationship data. Subsequently, it prepares inputs for a Helper LLM to analyze individual functions and classes, and then calls the Helper LLM to generate documentation for them. Finally, it prepares a main input for a Main LLM, which produces a final markdown report based on the collected analysis results.",
                "parameters": [
                    {
                        "name": "input",
                        "type": "Any",
                        "description": "The input provided to the workflow, typically a string containing a GitHub repository URL."
                    },
                    {
                        "name": "api_keys",
                        "type": "dict",
                        "description": "A dictionary containing API keys for various services such as Gemini, OpenAI, and SCADsLLM."
                    },
                    {
                        "name": "model_names",
                        "type": "dict",
                        "description": "A dictionary specifying the names of the models to be used for helper and main LLM tasks."
                    },
                    {
                        "name": "status_callback",
                        "type": "Callable[[str], None]",
                        "description": "An optional callback function to report the progress of the workflow."
                    }
                ],
                "returns": [
                    {
                        "name": "report",
                        "type": "str",
                        "description": "The final markdown report generated by the Main LLM."
                    },
                    {
                        "name": "metrics",
                        "type": "dict",
                        "description": "A dictionary containing timing metrics for the helper and main LLM processes."
                    }
                ],
                "usage_context": {
                    "calls": "This function internally calls several components including GitRepository for cloning repositories, ProjektInfoExtractor for extracting project information, ProjectAnalyzer for analyzing relationships, ASTAnalyzer for generating AST schemas, LLMHelper for function and class analysis, and MainLLM for generating the final report.",
                    "called_by": "This function is called by the frontend module in 'Frontend.py' at line 489 and by the backend.main module in 'main.py' at line 469."
                }
            },
            "error": null
        },
        "backend.main.update_status": {
            "identifier": "backend.main.update_status",
            "description": {
                "overall": "The function 'update_status' takes a message as input and conditionally invokes a callback function named 'status_callback' if it is defined. It also logs the message using the standard logging module. This function serves as a centralized mechanism for reporting status updates throughout the application.",
                "parameters": [
                    {
                        "name": "msg",
                        "type": "Any",
                        "description": "The message to be passed to the status callback and logged."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function internally calls the 'status_callback' function if it exists, and uses the 'logging.info' function to log the provided message.",
                    "called_by": "This function is invoked multiple times by the 'main_workflow' function located in 'main.py', specifically at lines 80, 127, 151, 160, 168, 178, 188, 198, 294, 326, 329, 402, and 405."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.path_to_module": {
            "identifier": "backend.relationship_analyzer.path_to_module",
            "description": {
                "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles edge cases where the filepath is not under the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
                "parameters": [
                    {
                        "name": "filepath",
                        "type": "str",
                        "description": "The absolute or relative path to a Python file."
                    },
                    {
                        "name": "project_root",
                        "type": "str",
                        "description": "The root directory of the project used to compute the relative path."
                    }
                ],
                "returns": [
                    {
                        "name": "module_path",
                        "type": "str",
                        "description": "A dot-separated module path derived from the given file path."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by _collect_definitions and __init__ methods in relationship_analyzer.py."
                }
            },
            "error": null
        },
        "database.db.encrypt_text": {
            "identifier": "database.db.encrypt_text",
            "description": {
                "overall": "The function encrypts a given text string using a cipher suite, returning the encrypted result as a string. It first checks if the input text is empty or if the cipher suite is not available, in which case it returns the input text unchanged. If both conditions are met, it encodes the stripped text to bytes, encrypts it using the cipher suite, and then decodes the result back to a string.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "The text string to be encrypted."
                    }
                ],
                "returns": [
                    {
                        "name": "encrypted_text",
                        "type": "str",
                        "description": "The encrypted version of the input text, returned as a string."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the update_gemini_key function in the db.py file."
                }
            },
            "error": null
        },
        "database.db.decrypt_text": {
            "identifier": "database.db.decrypt_text",
            "description": {
                "overall": "The function decrypts a given text using a cipher suite if both the text and cipher suite are valid. It handles potential decryption errors gracefully by returning the original text if decryption fails. The function performs basic validation on the input text and cipher suite before attempting decryption.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "The encrypted text to be decrypted."
                    }
                ],
                "returns": [
                    {
                        "name": "result",
                        "type": "str",
                        "description": "The decrypted text if successful, otherwise the original input text."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the function 'get_decrypted_api_keys' in the file 'db.py'."
                }
            },
            "error": null
        },
        "database.db.insert_user": {
            "identifier": "database.db.insert_user",
            "description": {
                "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. The password is hashed before being stored. It also initializes additional fields such as API keys and returns the ID of the inserted document.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user, used as the '_id' field in the database."
                    },
                    {
                        "name": "name",
                        "type": "str",
                        "description": "The full name of the user."
                    },
                    {
                        "name": "password",
                        "type": "str",
                        "description": "The plain text password of the user, which gets hashed before storage."
                    }
                ],
                "returns": [
                    {
                        "name": "inserted_id",
                        "type": "ObjectId",
                        "description": "The unique identifier of the newly inserted user document in the database."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the Frontend class in the Frontend.py file at line 294."
                }
            },
            "error": null
        },
        "database.db.fetch_all_users": {
            "identifier": "database.db.fetch_all_users",
            "description": {
                "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It performs a database query to find all records in the collection and returns them as a list. The function does not accept any parameters and directly accesses the global 'dbusers' variable, which is expected to be initialized elsewhere in the codebase.",
                "parameters": [],
                "returns": [
                    {
                        "name": "result",
                        "type": "list",
                        "description": "A list containing all user documents retrieved from the 'dbusers' MongoDB collection."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not call any other functions directly.",
                    "called_by": "This function is called by the 'frontend.Frontend' class in the 'Frontend.py' file at line 244."
                }
            },
            "error": null
        },
        "database.db.fetch_user": {
            "identifier": "database.db.fetch_user",
            "description": {
                "overall": "The function fetch_user retrieves a user document from a MongoDB collection named 'dbusers' based on the provided username. It uses the find_one method to search for a document where the '_id' field matches the given username. The function assumes that the 'dbusers' collection and the MongoDB connection are properly initialized elsewhere in the codebase.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier (username) used to locate the specific user document in the MongoDB collection."
                    }
                ],
                "returns": [
                    {
                        "name": "result",
                        "type": "Any",
                        "description": "The user document retrieved from the MongoDB collection, or None if no matching document is found."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on external database operations.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.update_user_name": {
            "identifier": "database.db.update_user_name",
            "description": {
                "overall": "This function updates the name field of a user document in a MongoDB collection identified by the username. It uses the MongoDB update_one method to modify only the name field, leaving other fields unchanged. The function returns the count of modified documents, which should be 1 if the update was successful.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier (typically the _id) of the user whose name needs to be updated."
                    },
                    {
                        "name": "new_name",
                        "type": "str",
                        "description": "The new name value to set for the specified user."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified by the update operation. This should typically be 1 if the user exists and the update was applied."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally calls the MongoDB update_one method to perform the database update operation.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.update_gemini_key": {
            "identifier": "database.db.update_gemini_key",
            "description": {
                "overall": "This function updates the Gemini API key for a specified user in the database. It first encrypts the provided API key using a text encryption function, then performs an update operation on the 'dbusers' collection to store the encrypted key under the user's ID. The function returns the count of modified documents, indicating whether the update was successful.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user whose Gemini API key needs to be updated."
                    },
                    {
                        "name": "gemini_api_key",
                        "type": "str",
                        "description": "The raw Gemini API key provided by the user, which will be stripped of whitespace and encrypted before storage."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified as a result of the update operation."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally calls 'encrypt_text' to encrypt the provided API key before storing it.",
                    "called_by": "This function is called by 'save_gemini_cb' in 'Frontend.py' at line 35 and by 'frontend.Frontend' in 'Frontend.py' at line 393."
                }
            },
            "error": null
        },
        "database.db.update_ollama_url": {
            "identifier": "database.db.update_ollama_url",
            "description": {
                "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and performs an update operation on the user document. The function returns the count of modified documents, which should be 1 if the update was successful.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user whose Ollama base URL needs to be updated."
                    },
                    {
                        "name": "ollama_base_url",
                        "type": "str",
                        "description": "The new Ollama base URL to be set for the user. Leading and trailing whitespace will be stripped."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified by the update operation. Typically 1 if the user exists and the update was applied."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on the pymongo library's update_one method.",
                    "called_by": "This function is called by save_ollama_cb in Frontend.py at line 42 and by frontend.Frontend in Frontend.py at line 407."
                }
            },
            "error": null
        },
        "database.db.fetch_gemini_key": {
            "identifier": "database.db.fetch_gemini_key",
            "description": {
                "overall": "The function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user whose Gemini API key is to be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "gemini_api_key",
                        "type": "Optional[str]",
                        "description": "The Gemini API key associated with the provided username, or None if no such user exists."
                    }
                ],
                "usage_context": {
                    "calls": "This function internally uses the 'dbusers.find_one' method to query a MongoDB collection.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.fetch_ollama_url": {
            "identifier": "database.db.fetch_ollama_url",
            "description": {
                "overall": "This function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier (username) used to look up the user in the database."
                    }
                ],
                "returns": [
                    {
                        "name": "ollama_base_url",
                        "type": "str or None",
                        "description": "The Ollama base URL retrieved from the user's document, or None if no such user exists."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses the 'dbusers.find_one' method to query the database.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.delete_user": {
            "identifier": "database.db.delete_user",
            "description": {
                "overall": "The function 'delete_user' removes a user document from a MongoDB collection based on the provided username. It uses the 'delete_one' method to target a specific user by their '_id', which corresponds to the username. The function then returns the count of deleted documents, which should be 1 if the user was successfully deleted or 0 if no matching user was found.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier (username) of the user to be deleted from the database."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of documents deleted, typically 1 if the user existed and was deleted, or 0 if no such user was found."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on the 'dbusers.delete_one' method from the pymongo library.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.get_decrypted_api_keys": {
            "identifier": "database.db.get_decrypted_api_keys",
            "description": {
                "overall": "This function retrieves and decrypts API keys for a given username from a database. It first fetches the user document using the username as the identifier. If the user does not exist, it returns two None values. If the user exists, it attempts to decrypt the 'gemini_api_key' field using a decryption function and retrieves the 'ollama_base_url' directly. Both decrypted and plain text values are returned as a tuple.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user whose API keys are to be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "gemini_plain",
                        "type": "str",
                        "description": "The decrypted Gemini API key for the user, or an empty string if not found."
                    },
                    {
                        "name": "ollama_plain",
                        "type": "str",
                        "description": "The Ollama base URL for the user, or an empty string if not found."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses dbusers.find_one to retrieve user data from the database.",
                    "called_by": "This function is called by the frontend.Frontend class in Frontend.py at lines 380 and 479."
                }
            },
            "error": null
        },
        "database.db.insert_chat": {
            "identifier": "database.db.insert_chat",
            "description": {
                "overall": "The function 'insert_chat' creates a new chat entry in the database with a unique identifier, associated username, chat name, and timestamp. It generates a UUID for the chat ID, sets the creation time to the current moment, and inserts the chat document into the 'dbchats' collection. The function returns the ID of the newly inserted chat document.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat."
                    }
                ],
                "returns": [
                    {
                        "name": "result.inserted_id",
                        "type": "str",
                        "description": "The unique identifier of the newly inserted chat document."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by load_data_from_db in Frontend.py at line 81, handle_delete_chat in Frontend.py at line 122, and frontend.Frontend in Frontend.py at line 344."
                }
            },
            "error": null
        },
        "database.db.fetch_chats_by_user": {
            "identifier": "database.db.fetch_chats_by_user",
            "description": {
                "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet einen Datenbankcursor, um die Chats basierend auf dem Benutzernamen zu filtern und sie nach dem Erstellungsdatum in aufsteigender Reihenfolge zu sortieren. Das Ergebnis wird als Liste zurückgegeben.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "Der Benutzername des Benutzers, dessen Chats abgerufen werden sollen."
                    }
                ],
                "returns": [
                    {
                        "name": "chats",
                        "type": "list",
                        "description": "Eine Liste der Chats, die dem angegebenen Benutzernamen entsprechen und nach Erstellungsdatum sortiert sind."
                    }
                ],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes auf.",
                    "called_by": "Die Funktion wird von der Funktion load_data_from_db in der Datei Frontend.py aufgerufen."
                }
            },
            "error": null
        },
        "database.db.check_chat_exists": {
            "identifier": "database.db.check_chat_exists",
            "description": {
                "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a lookup in the 'dbchats' collection using a MongoDB query that matches both the username and chat name. The function returns a boolean value indicating the presence or absence of the chat entry.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat to check for existence."
                    }
                ],
                "returns": [
                    {
                        "name": "exists",
                        "type": "bool",
                        "description": "True if a chat with the specified username and chat_name exists in the database; False otherwise."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses the 'dbchats.find_one' method to query the database.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.rename_chat_fully": {
            "identifier": "database.db.rename_chat_fully",
            "description": {
                "overall": "This function renames a chat and updates all associated exchanges in the database. It first modifies the chat entry in the chats collection, then updates all related exchange records in the exchanges collection to reflect the new chat name. The function returns the number of modified chat entries.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat to be renamed."
                    },
                    {
                        "name": "old_name",
                        "type": "str",
                        "description": "The current name of the chat to be renamed."
                    },
                    {
                        "name": "new_name",
                        "type": "str",
                        "description": "The new name to assign to the chat."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of chat entries that were successfully modified in the database."
                    }
                ],
                "usage_context": {
                    "calls": "The function performs database operations using MongoDB update methods but does not call any other user-defined functions.",
                    "called_by": "This function is called by the frontend.Frontend class in the Frontend.py file at line 462."
                }
            },
            "error": null
        },
        "database.db.insert_exchange": {
            "identifier": "database.db.insert_exchange",
            "description": {
                "overall": "This function inserts a new exchange record into a MongoDB collection. It generates a unique ID for the exchange, constructs a dictionary with all the provided details including question, answer, feedback, and timing information, and attempts to insert this record into the database. If the insertion fails, it catches the exception, prints an error message, and returns None. Otherwise, it returns the generated unique ID.",
                "parameters": [
                    {
                        "name": "question",
                        "type": "str",
                        "description": "The question asked in the exchange."
                    },
                    {
                        "name": "answer",
                        "type": "str",
                        "description": "The answer provided in response to the question."
                    },
                    {
                        "name": "feedback",
                        "type": "str",
                        "description": "Feedback associated with the exchange."
                    },
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username of the user involved in the exchange."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat session."
                    },
                    {
                        "name": "helper_used",
                        "type": "str",
                        "description": "The helper tool used during the exchange (optional)."
                    },
                    {
                        "name": "main_used",
                        "type": "str",
                        "description": "The main tool used during the exchange (optional)."
                    },
                    {
                        "name": "total_time",
                        "type": "str",
                        "description": "Total time taken for the exchange (optional)."
                    },
                    {
                        "name": "helper_time",
                        "type": "str",
                        "description": "Time taken by the helper tool during the exchange (optional)."
                    },
                    {
                        "name": "main_time",
                        "type": "str",
                        "description": "Time taken by the main tool during the exchange (optional)."
                    }
                ],
                "returns": [
                    {
                        "name": "new_id",
                        "type": "str",
                        "description": "The unique ID of the inserted exchange record, or None if insertion failed."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the frontend.Frontend function in the Frontend.py file."
                }
            },
            "error": null
        },
        "database.db.fetch_exchanges_by_user": {
            "identifier": "database.db.fetch_exchanges_by_user",
            "description": {
                "overall": "This function retrieves all exchange records from a MongoDB collection for a given username, sorted by creation timestamp in ascending order. It uses the pymongo library to query the database and returns the results as a list. The sorting ensures that exchanges are displayed chronologically.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the exchange records to be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "exchanges",
                        "type": "list",
                        "description": "A list of exchange records matching the provided username, sorted by creation timestamp in ascending order."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the load_data_from_db function in Frontend.py at line 64."
                }
            },
            "error": null
        },
        "database.db.fetch_exchanges_by_chat": {
            "identifier": "database.db.fetch_exchanges_by_chat",
            "description": {
                "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with specific criteria and orders the results by creation time in ascending order. The function returns the fetched documents as a list.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the exchanges to be retrieved."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat associated with the exchanges to be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "exchanges",
                        "type": "list",
                        "description": "A list of exchange documents matching the provided username and chat name, sorted by creation time in ascending order."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses the 'dbexchanges.find' method to query the database and 'sort' to order the results.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.update_exchange_feedback": {
            "identifier": "database.db.update_exchange_feedback",
            "description": {
                "overall": "This function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document by setting its 'feedback' field to the provided value. The function returns the number of documents modified as a result of the operation.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "Any",
                        "description": "The unique identifier of the exchange document to be updated."
                    },
                    {
                        "name": "feedback",
                        "type": "int",
                        "description": "The new feedback value to be set in the document."
                    }
                ],
                "returns": [
                    {
                        "name": "result.modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified by the update operation."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on the pymongo library's update_one method.",
                    "called_by": "This function is called by the handle_feedback_change function in the Frontend.py file at line 98."
                }
            },
            "error": null
        },
        "database.db.update_exchange_feedback_message": {
            "identifier": "database.db.update_exchange_feedback_message",
            "description": {
                "overall": "This function updates the feedback message associated with a specific exchange document in a MongoDB collection. It takes an exchange ID and a new feedback message as inputs, then performs an atomic update operation on the database to set the feedback_message field. The function returns the count of modified documents, which should be 1 if the update was successful.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "Any",
                        "description": "The unique identifier of the exchange document to be updated."
                    },
                    {
                        "name": "feedback_message",
                        "type": "str",
                        "description": "The new feedback message to be stored in the exchange document."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified by the update operation."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on the pymongo library's update_one method.",
                    "called_by": "This function is called by the render_exchange function in Frontend.py at line 211."
                }
            },
            "error": null
        },
        "database.db.delete_exchange_by_id": {
            "identifier": "database.db.delete_exchange_by_id",
            "description": {
                "overall": "This function deletes a document from the 'dbexchanges' collection in a MongoDB database based on a given exchange ID. It performs a delete operation using the 'delete_one' method and returns the count of deleted documents. The function assumes that the 'dbexchanges' collection and the 'delete_one' method are properly initialized and accessible within the scope.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "str",
                        "description": "A string identifier used to locate and delete a specific document in the 'dbexchanges' collection."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of documents deleted as a result of the 'delete_one' operation. Typically 0 or 1, depending on whether a matching document was found and deleted."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not call any other functions directly; it relies on the 'dbexchanges.delete_one' method.",
                    "called_by": "This function is called by 'handle_delete_exchange' in 'Frontend.py' at line 102."
                }
            },
            "error": null
        },
        "database.db.delete_full_chat": {
            "identifier": "database.db.delete_full_chat",
            "description": {
                "overall": "This function deletes a complete chat session along with all associated exchanges from the database. It first removes all exchange records linked to the specified username and chat name, followed by deleting the chat record itself. The function returns the count of deleted chat documents, ensuring consistency between frontend and backend data states.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat to be deleted."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat session to be deleted."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of chat documents that were successfully deleted from the database."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not call any other functions directly; it relies on external database operations via dbexchanges and dbchats.",
                    "called_by": "This function is called by the handle_delete_chat function in Frontend.py at line 110."
                }
            },
            "error": null
        },
        "frontend.Frontend.save_gemini_cb": {
            "identifier": "frontend.Frontend.save_gemini_cb",
            "description": {
                "overall": "This function handles the saving of a Gemini API key entered by the user in a Streamlit frontend application. It retrieves the key from the session state, updates the database with the new key for the current user, clears the input field, and displays a success message to the user. The function does not take any parameters and does not return any value.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally uses streamlit session state operations and calls a database update function.",
                    "called_by": "This function is not called by any other function according to the provided context."
                }
            },
            "error": null
        },
        "frontend.Frontend.save_ollama_cb": {
            "identifier": "frontend.Frontend.save_ollama_cb",
            "description": {
                "overall": "This function is designed to save a new Ollama URL entered by the user into the database. It retrieves the URL from the Streamlit session state, checks if it's non-empty, and then updates the database with the new URL associated with the current username. Upon successful update, it displays a success message to the user via a toast notification.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally uses `st.session_state.get` to retrieve the Ollama URL and `db.update_ollama_url` to persist the data.",
                    "called_by": "This function is not called by any other function within the provided context."
                }
            },
            "error": null
        },
        "frontend.Frontend.load_data_from_db": {
            "identifier": "frontend.Frontend.load_data_from_db",
            "description": {
                "overall": "Die Funktion 'load_data_from_db' lädt Chats und Exchanges konsistent aus einer Datenbank für einen bestimmten Benutzer. Sie prüft zunächst, ob der Benutzer bereits geladen wurde, und lädt dann die Chats und zugehörigen Exchanges aus der Datenbank. Dabei werden auch Legacy-Chats unterstützt und ein Standard-Chat erstellt, falls keine Chats vorhanden sind. Anschließend wird der aktive Chat festgelegt.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "Der Benutzername, für den die Daten aus der Datenbank geladen werden sollen."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes auf.",
                    "called_by": "Die Funktion wird von der Methode 'frontend.Frontend' in der Datei 'Frontend.py' auf Zeile 310 aufgerufen."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_feedback_change": {
            "identifier": "frontend.Frontend.handle_feedback_change",
            "description": {
                "overall": "This function updates the feedback value for a given exchange object in the database and triggers a rerun of the Streamlit application. It takes an exchange dictionary and a new feedback value as inputs, modifies the exchange's feedback field, updates the corresponding record in the database, and refreshes the Streamlit UI.",
                "parameters": [
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary representing an exchange object, expected to contain keys such as 'feedback' and '_id'."
                    },
                    {
                        "name": "val",
                        "type": "Any",
                        "description": "The new feedback value to be assigned to the exchange object."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally calls `db.update_exchange_feedback` to update the feedback in the database and `st.rerun()` to refresh the Streamlit UI.",
                    "called_by": "This function is called by the `render_exchange` function in `Frontend.py` at lines 199 and 204."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_delete_exchange": {
            "identifier": "frontend.Frontend.handle_delete_exchange",
            "description": {
                "overall": "This function handles the deletion of an exchange from the database and updates the session state accordingly. It first deletes the exchange from the database using its ID, then checks if the exchange exists in the session state for a given chat and removes it if found. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
                "parameters": [
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat from which the exchange should be removed."
                    },
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on external modules like 'db' and 'st' for database operations and Streamlit functionality.",
                    "called_by": "This function is called by the render_exchange function in Frontend.py at lines 228 and 234."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_delete_chat": {
            "identifier": "frontend.Frontend.handle_delete_chat",
            "description": {
                "overall": "The function handles the deletion of a chat by first removing the chat from the database and then cleaning up the session state. It ensures that the active chat is updated appropriately after deletion, either by selecting another existing chat or by creating a new default chat if none remain. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat to be deleted."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat to be deleted."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on external modules such as 'db' and 'st.session_state'.",
                    "called_by": "This function is called by 'frontend.Frontend' in the file 'Frontend.py' at line 367."
                }
            },
            "error": null
        },
        "frontend.Frontend.extract_repo_name": {
            "identifier": "frontend.Frontend.extract_repo_name",
            "description": {
                "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from any URL present in the text. It uses regular expressions to find a URL, parses it using urllib.parse.urlparse, extracts the path component, and then derives the repository name from the last segment of the path. If the repository name ends with '.git', it removes the extension. If no URL is found or the path is empty, it returns None.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "A string that may contain a URL from which to extract the repository name."
                    }
                ],
                "returns": [
                    {
                        "name": "repo_name",
                        "type": "str",
                        "description": "The extracted repository name from the URL, with '.git' suffix removed if present, or None if no valid URL is found."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly defined within the provided source code.",
                    "called_by": "This function is called by the 'frontend.Frontend' class constructor at line 442 in the file 'Frontend.py'."
                }
            },
            "error": null
        },
        "frontend.Frontend.stream_text_generator": {
            "identifier": "frontend.Frontend.stream_text_generator",
            "description": {
                "overall": "The function `stream_text_generator` takes a string input and yields each word from the string followed by a space, with a small delay between each yield. It is designed to simulate a streaming effect for text rendering. The function splits the input text into words based on spaces and processes them one at a time.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "A string containing the text to be processed and streamed."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the function 'render_text_with_mermaid' in the file 'Frontend.py'."
                }
            },
            "error": null
        },
        "frontend.Frontend.render_text_with_mermaid": {
            "identifier": "frontend.Frontend.render_text_with_mermaid",
            "description": {
                "overall": "This function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text based on Mermaid code block delimiters and handles regular markdown content separately from Mermaid diagram code. For non-Mermaid content, it either streams or displays the text as markdown depending on the streaming flag. For Mermaid code blocks, it attempts to render them as interactive diagrams, falling back to displaying them as plain code if rendering fails.",
                "parameters": [
                    {
                        "name": "markdown_text",
                        "type": "str",
                        "description": "A string containing markdown text that may include Mermaid code blocks enclosed in triple backticks with 'mermaid' language identifier."
                    },
                    {
                        "name": "should_stream",
                        "type": "bool",
                        "description": "A boolean flag indicating whether to stream the regular markdown text instead of rendering it all at once."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "The function uses regular expressions to split the markdown text and relies on external libraries like streamlit_mermaid.st_mermaid for rendering Mermaid diagrams, and streamlit components such as st.write_stream and st.markdown for displaying content.",
                    "called_by": "This function is called by the render_exchange method in Frontend.py at line 238 and also by the frontend.Frontend module at line 524."
                }
            },
            "error": null
        },
        "frontend.Frontend.render_exchange": {
            "identifier": "frontend.Frontend.render_exchange",
            "description": {
                "overall": "The function `render_exchange` renders a chat exchange in a Streamlit interface, displaying a user's question and an assistant's response. It handles both regular responses and error cases, providing interactive feedback mechanisms such as like/dislike buttons, comment popups, download options, and delete functionality. The assistant's response is rendered with Mermaid support. It uses various Streamlit components for UI rendering and integrates with backend functions for handling feedback and deletions.",
                "parameters": [
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary containing the exchange data, including the question, answer, feedback status, and other metadata."
                    },
                    {
                        "name": "current_chat_name",
                        "type": "str",
                        "description": "The name of the current chat session, used for deleting exchanges."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not directly call any other user-defined functions based on the provided source code; however, it relies on external functions like `handle_feedback_change`, `handle_delete_exchange`, and `render_text_with_mermaid` which are assumed to be defined elsewhere.",
                    "called_by": "This function is called by the `frontend.Frontend` class in the `Frontend.py` file at line 429."
                }
            },
            "error": null
        }
    },
    "classes": {
        "backend.AST_Schema.ASTVisitor": {
            "identifier": "backend.AST_Schema.ASTVisitor",
            "description": {
                "overall": "The ASTVisitor class is a specialized AST (Abstract Syntax Tree) visitor that traverses Python source code to extract structural information such as imports, classes, and functions. It builds a schema representation of the code by collecting metadata like identifiers, docstrings, source segments, and line numbers. The visitor maintains contextual information about current class scope during traversal to properly associate methods with their respective classes.",
                "init_method": {
                    "description": "Initializes the ASTVisitor with source code, file path, and project root. It sets up internal state including module path derived from the file path and project root, and initializes an empty schema dictionary to store collected information about imports, functions, and classes.",
                    "parameters": [
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "The full source code string of the file being analyzed."
                        },
                        {
                            "name": "file_path",
                            "type": "str",
                            "description": "The absolute or relative path to the Python file being processed."
                        },
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "The root directory of the project to determine module paths."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles import nodes in the AST by extracting the names of imported modules and appending them to the schema's imports list. It iterates over all aliases in the import statement and adds each to the imports section of the schema before continuing traversal.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "An AST node representing an import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when encountering an import node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Processes 'from ... import ...' statements in the AST by constructing qualified names for imported items and adding them to the schema's imports list. Each imported item is prefixed with its module name to form a fully qualified import path.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "An AST node representing a 'from ... import ...' statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when encountering an import from node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "Visits class definitions in the AST and records detailed information about each class, including its identifier, name, docstring, source segment, and line numbers. It also tracks the class within the schema under the 'classes' key and sets the current class context for subsequent method processing.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "An AST node representing a class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when encountering a class definition node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Handles function definitions in the AST, either associating them with the currently active class context or treating them as top-level functions. For functions within a class, it creates method context entries; otherwise, it creates standalone function entries in the schema with associated metadata.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "An AST node representing a function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when encountering a function definition node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_AsyncFunctionDef",
                        "description": {
                            "overall": "Processes asynchronous function definitions by delegating to the standard function visitor method. This ensures that async functions are treated similarly to regular functions in terms of schema collection.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AsyncFunctionDef",
                                    "description": "An AST node representing an async function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method delegates to visit_FunctionDef.",
                                "called_by": "This method is called by the generic AST traversal mechanism when encountering an async function definition node."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on the 'ast' module for parsing and analyzing Python source code.",
                    "instantiated_by": "The ASTVisitor class is instantiated by the 'analyze_repository' function located in 'AST_Schema.py' at line 182."
                }
            },
            "error": null
        },
        "backend.AST_Schema.ASTAnalyzer": {
            "identifier": "backend.AST_Schema.ASTAnalyzer",
            "description": {
                "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Trees (ASTs) and enriching the resulting schema with call graph information. It merges relationship data into the schema and supports the construction of a comprehensive representation of the codebase including functions, classes, and their interdependencies. The class orchestrates the process of AST traversal, schema enrichment, and integration of call graph and relationship data.",
                "init_method": {
                    "description": "Initializes an instance of the ASTAnalyzer class. The constructor currently does not perform any initialization actions.",
                    "parameters": []
                },
                "methods": [
                    {
                        "identifier": "_enrich_schema_with_callgraph",
                        "description": {
                            "overall": "Enriches a given schema with call graph information by updating function and method contexts with details about what they call and who calls them. It iterates over functions and methods in the schema and updates their context fields based on the provided call graph.",
                            "parameters": [
                                {
                                    "name": "schema",
                                    "type": "dict",
                                    "description": "A dictionary representing the schema to be enriched with call graph data."
                                },
                                {
                                    "name": "call_graph",
                                    "type": "nx.DiGraph",
                                    "description": "A NetworkX directed graph representing the call relationships between functions and methods."
                                },
                                {
                                    "name": "filename",
                                    "type": "str",
                                    "description": "The filename associated with the schema being processed."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the analyze_repository method within the ASTAnalyzer class."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "merge_relationship_data",
                        "description": {
                            "overall": "Merges relationship data into a full schema by mapping identifiers from the relationship data to corresponding entries in the schema's functions, classes, and methods. It updates context information such as 'called_by' for functions and classes, and 'called_by' for methods.",
                            "parameters": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "The complete schema into which relationship data will be merged."
                                },
                                {
                                    "name": "relationship_data",
                                    "type": "list",
                                    "description": "A list of dictionaries containing relationship information, including identifiers and called_by lists."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "The updated schema with merged relationship data."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the evaluation function in evaluation.py at line 137 and by the main_workflow function in main.py at line 190."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "analyze_repository",
                        "description": {
                            "overall": "Analyzes a repository by processing a list of files, parsing their content into ASTs, and building a schema representation. It uses an ASTVisitor to traverse each file's AST and enriches the schema with call graph information. It also handles errors during parsing and constructs a full schema of files and their AST nodes.",
                            "parameters": [
                                {
                                    "name": "files",
                                    "type": "list",
                                    "description": "A list of file objects to be analyzed."
                                },
                                {
                                    "name": "repo",
                                    "type": "GitRepository",
                                    "description": "An object representing the Git repository containing the files to be analyzed."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "A dictionary containing the full schema of the analyzed repository files."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls the _enrich_schema_with_callgraph method and attempts to build a filtered callgraph using build_filtered_callgraph. It also instantiates an ASTVisitor to parse and visit AST nodes.",
                                "called_by": "This method is called by the evaluation function in evaluation.py at line 129 and by the main_workflow function in main.py at line 181."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on external modules such as ast, networkx, os, callgraph.build_filtered_callgraph, and getRepo.GitRepository.",
                    "instantiated_by": "This class is instantiated by the evaluation function in evaluation.py at line 128 and by the main_workflow function in main.py at line 180."
                }
            },
            "error": null
        },
        "backend.File_Dependency.FileDependencyGraph": {
            "identifier": "backend.File_Dependency.FileDependencyGraph",
            "description": {
                "overall": "The FileDependencyGraph class is designed to analyze and resolve Python file dependencies, particularly focusing on handling relative imports. It extends NodeVisitor to traverse AST nodes of Python files and builds a dependency graph by tracking import relationships between files. The class resolves relative imports by mapping them to actual module or symbol names based on file system checks and parsing of __init__.py files. It maintains a dictionary of import dependencies for each file.",
                "init_method": {
                    "description": "Initializes the FileDependencyGraph with a filename and repository root path. Sets up the instance variables to track the current file being processed and the root directory of the repository.",
                    "parameters": [
                        {
                            "name": "filename",
                            "type": "str",
                            "description": "The name of the file being analyzed for dependencies."
                        },
                        {
                            "name": "repo_root",
                            "type": "Any",
                            "description": "The root directory path of the repository containing the files."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_resolve_module_name",
                        "description": {
                            "overall": "Resolves relative imports by analyzing the AST node representing an import statement. It determines the correct module or symbol names by checking file existence and parsing __init__.py files. The method handles various levels of relative imports and raises ImportError if resolution fails.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ImportFrom",
                                    "description": "An AST node representing a relative import statement."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "resolved",
                                    "type": "list[str]",
                                    "description": "A list of resolved module or symbol names."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls helper functions module_file_exists and init_exports_symbol to check file existence and symbol exports respectively.",
                                "called_by": "This method is called by visit_ImportFrom when resolving relative imports."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles Import AST nodes by adding the imported module names to the import dependencies dictionary. It tracks both direct imports and those with base names, updating the dependency graph accordingly.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "Import | ImportFrom",
                                    "description": "An AST node representing an import statement."
                                },
                                {
                                    "name": "base_name",
                                    "type": "str | None",
                                    "description": "Optional base name for the imported module."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal of the AST.",
                                "called_by": "This method is called by visit_ImportFrom during AST traversal."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Processes ImportFrom AST nodes to handle complex import statements. It extracts module names and delegates to visit_Import for further processing. For relative imports, it attempts to resolve them using _resolve_module_name.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ImportFrom",
                                    "description": "An AST node representing a relative import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls _resolve_module_name to resolve relative imports and visit_Import to record dependencies.",
                                "called_by": "This method is called during AST traversal by the parent NodeVisitor class."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on networkx, os, ast modules, pathlib.Path, and several custom functions like get_all_temp_files and GitRepository.",
                    "instantiated_by": "This class is instantiated by the build_file_dependency_graph function in File_Dependency.py at line 156."
                }
            },
            "error": null
        },
        "backend.HelperLLM.LLMHelper": {
            "identifier": "backend.HelperLLM.LLMHelper",
            "description": {
                "overall": "The LLMHelper class serves as a centralized interface for interacting with various language models, including Google Gemini, OpenAI, custom APIs, and Ollama, to generate validated documentation for functions and classes. It manages model configuration, handles API interactions with batching and rate-limiting considerations, and ensures input/output validation using Pydantic models.",
                "init_method": {
                    "description": "Initializes the LLMHelper with API credentials, prompt files, and model configurations. It reads system prompts from specified files, configures batch settings based on the selected model, and sets up appropriate language model clients depending on the model type. It also prepares structured output parsers for function and class analysis using Pydantic schemas.",
                    "parameters": [
                        {
                            "name": "api_key",
                            "type": "str",
                            "description": "API key for accessing the language model service."
                        },
                        {
                            "name": "function_prompt_path",
                            "type": "str",
                            "description": "File path to the system prompt used for function documentation generation."
                        },
                        {
                            "name": "class_prompt_path",
                            "type": "str",
                            "description": "File path to the system prompt used for class documentation generation."
                        },
                        {
                            "name": "model_name",
                            "type": "str",
                            "description": "Name of the language model to use, defaulting to 'gemini-2.0-flash-lite'."
                        },
                        {
                            "name": "base_url",
                            "type": "str",
                            "description": "Base URL for custom API endpoints, optional."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_configure_batch_settings",
                        "description": {
                            "overall": "Configures the batch size for processing requests based on the specified model name. It assigns different batch sizes according to model capabilities and fallbacks to a default value for unknown models.",
                            "parameters": [
                                {
                                    "name": "model_name",
                                    "type": "str",
                                    "description": "Name of the language model being configured."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is called by the constructor (__init__)."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "generate_for_functions",
                        "description": {
                            "overall": "Processes a batch of function inputs to generate and validate documentation using the configured language model. It splits inputs into batches, sends them to the LLM with appropriate system prompts, and handles errors by filling failed items with None while maintaining order. It respects rate limits by waiting between batches.",
                            "parameters": [
                                {
                                    "name": "function_inputs",
                                    "type": "List[FunctionAnalysisInput]",
                                    "description": "A list of function input models to be documented."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "List[Optional[FunctionAnalysis]]",
                                    "description": "A list of validated function analysis results or None for failed items."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not directly call other functions from the provided context.",
                                "called_by": "Called by evaluation() in evaluation.py and main_workflow() in main.py."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "generate_for_classes",
                        "description": {
                            "overall": "Processes a batch of class inputs to generate and validate documentation using the configured language model. Similar to generate_for_functions, it batches inputs, sends them to the LLM with appropriate system prompts, and handles errors by filling failed items with None while maintaining order. It also respects rate limits by waiting between batches.",
                            "parameters": [
                                {
                                    "name": "class_inputs",
                                    "type": "List[ClassAnalysisInput]",
                                    "description": "A list of class input models to be documented."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "List[Optional[ClassAnalysis]]",
                                    "description": "A list of validated class analysis results or None for failed items."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not directly call other functions from the provided context.",
                                "called_by": "Called by evaluation() in evaluation.py and main_workflow() in main.py."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "No external dependencies were explicitly listed in the context.",
                    "instantiated_by": "The class is instantiated in HelperLLM.py by main_orchestrator, in evaluation.py by evaluation, and in main.py by main_workflow."
                }
            },
            "error": null
        },
        "backend.MainLLM.MainLLM": {
            "identifier": "backend.MainLLM.MainLLM",
            "description": {
                "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs), including Google's Gemini models, OpenAI models, and local Ollama models. It initializes with an API key, a prompt file path, and model specifications, and provides two core functionalities: synchronous LLM invocation via `call_llm` and streaming responses via `stream_llm`. The class abstracts away the differences between model providers by dynamically selecting the appropriate LLM client based on the model name prefix.",
                "init_method": {
                    "description": "Initializes the MainLLM instance by validating the API key, loading a system prompt from a file, and setting up the appropriate LLM client based on the model name. It supports multiple LLM backends including Google Generative AI, OpenAI, and Ollama, with configurable model names and base URLs.",
                    "parameters": [
                        {
                            "name": "api_key",
                            "type": "str",
                            "description": "The API key required for accessing the LLM service."
                        },
                        {
                            "name": "prompt_file_path",
                            "type": "str",
                            "description": "The file path to the system prompt used for initializing the LLM."
                        },
                        {
                            "name": "model_name",
                            "type": "str",
                            "description": "The name of the model to use, which determines the backend client to instantiate."
                        },
                        {
                            "name": "ollama_base_url",
                            "type": "str",
                            "description": "The base URL for the Ollama server, used when the model is not a Google or OpenAI model."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "call_llm",
                        "description": {
                            "overall": "Executes a synchronous call to the configured LLM with a user input message. It constructs a conversation history using the system prompt and the user input, sends it to the LLM, and returns the content of the response. In case of errors, it logs the error and returns None.",
                            "parameters": [
                                {
                                    "name": "user_input",
                                    "type": "str",
                                    "description": "The input text provided by the user to be processed by the LLM."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "response_content",
                                    "type": "str",
                                    "description": "The content of the LLM's response, or None if an error occurs."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "Called by the main_workflow function in main.py at line 410."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "stream_llm",
                        "description": {
                            "overall": "Initiates a streaming call to the configured LLM with a user input message. It constructs a conversation history using the system prompt and the user input, streams the response chunks from the LLM, and yields each chunk's content. If an error occurs during streaming, it logs the error and yields an error message.",
                            "parameters": [
                                {
                                    "name": "user_input",
                                    "type": "str",
                                    "description": "The input text provided by the user to be processed by the LLM."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "chunk_content",
                                    "type": "str",
                                    "description": "Yields content chunks from the LLM's streaming response, or an error message if an exception occurs."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on several external libraries including langchain_google_genai.ChatGoogleGenerativeAI, langchain_ollama.ChatOllama, langchain.messages.HumanMessage, and langchain.messages.SystemMessage.",
                    "instantiated_by": "This class is instantiated by the main_workflow function in main.py at line 391."
                }
            },
            "error": null
        },
        "backend.basic_info.ProjektInfoExtractor": {
            "identifier": "backend.basic_info.ProjektInfoExtractor",
            "description": {
                "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It maintains an internal dictionary structure to store extracted information including project overview details like title, description, status, key features, and technology stack, as well as installation-related data such as dependencies, setup instructions, and quick start guides. The class orchestrates the extraction process by identifying relevant files, parsing their contents according to file type, and prioritizing information sources to ensure metadata accuracy.",
                "init_method": {
                    "description": "Initializes the ProjektInfoExtractor with a predefined structure for storing project information. It sets up placeholder values for various project metadata fields and defines a constant for indicating missing information.",
                    "parameters": []
                },
                "methods": [
                    {
                        "identifier": "_finde_datei",
                        "description": {
                            "overall": "This private method searches for a file among a list of files based on a set of filename patterns. It performs a case-insensitive search to find a matching file and returns the first match found, or None if no match is found.",
                            "parameters": [
                                {
                                    "name": "patterns",
                                    "type": "List[str]",
                                    "description": "A list of filename extensions or patterns to match against."
                                },
                                {
                                    "name": "dateien",
                                    "type": "List[Any]",
                                    "description": "A list of file objects to search through."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "Optional[Any]",
                                    "description": "The matched file object or None if no match is found."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is called by the extrahiere_info method to locate relevant project files such as README, pyproject.toml, and requirements.txt."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_extrahiere_sektion_aus_markdown",
                        "description": {
                            "overall": "This private method extracts a specific section from a markdown document based on a list of possible section headers. It uses regular expressions to identify the header and captures all content until the next header or end of the document.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The full markdown text to parse."
                                },
                                {
                                    "name": "keywords",
                                    "type": "List[str]",
                                    "description": "A list of alternative keywords to look for as section headers."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "extracted_text",
                                    "type": "Optional[str]",
                                    "description": "The extracted text section or None if no matching section is found."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is called by the _parse_readme method to extract sections like Features, Tech Stack, Status, Installation, and Quick Start from README files."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_readme",
                        "description": {
                            "overall": "This private method parses the content of a README file to extract project metadata such as title, description, key features, tech stack, current status, setup instructions, and quick start guide. It uses regex patterns and the _extrahiere_sektion_aus_markdown helper to extract relevant information from the markdown content.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The content of the README file to parse."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the _extrahiere_sektion_aus_markdown method to extract specific sections from the README content.",
                                "called_by": "This method is called by the extrahiere_info method when a README file is identified during the file processing phase."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_toml",
                        "description": {
                            "overall": "This private method parses the content of a pyproject.toml file to extract project metadata. It checks for the presence of the tomllib module and attempts to load the TOML content. If successful, it extracts project name, description, and dependencies, updating the internal info structure accordingly.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The content of the pyproject.toml file to parse."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is called by the extrahiere_info method when a pyproject.toml file is identified during the file processing phase."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_requirements",
                        "description": {
                            "overall": "This private method parses the content of a requirements.txt file to extract dependency information. It only populates the dependencies field if no dependencies were previously found in a pyproject.toml file, ensuring proper prioritization of information sources.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The content of the requirements.txt file to parse."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is called by the extrahiere_info method when a requirements.txt file is identified during the file processing phase."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "extrahiere_info",
                        "description": {
                            "overall": "This public method orchestrates the entire information extraction process from a list of repository files. It identifies relevant files (README, pyproject.toml, requirements.txt), processes them in order of priority, and formats the final output. It also ensures that the project title is updated based on the repository URL.",
                            "parameters": [
                                {
                                    "name": "dateien",
                                    "type": "List[Any]",
                                    "description": "A list of file objects to extract information from."
                                },
                                {
                                    "name": "repo_url",
                                    "type": "str",
                                    "description": "The URL of the repository used to derive the project title."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "info",
                                    "type": "Dict[str, Any]",
                                    "description": "A dictionary containing the extracted project information organized under 'projekt_uebersicht' and 'installation' keys."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls the _finde_datei, _parse_readme, _parse_toml, and _parse_requirements methods to locate and process different types of project files.",
                                "called_by": "This method is called by the evaluation function in evaluation.py and the main_workflow function in main.py."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "No external dependencies are explicitly required beyond standard library modules and typing annotations.",
                    "instantiated_by": "This class is instantiated in the evaluation function in evaluation.py at line 104 and in the main_workflow function in main.py at line 153."
                }
            },
            "error": null
        },
        "backend.callgraph.CallGraph": {
            "identifier": "backend.callgraph.CallGraph",
            "description": {
                "overall": "The CallGraph class is designed to construct a call graph from Python AST nodes. It traverses the abstract syntax tree of a Python file to identify function definitions, imports, class definitions, and function calls. The class maintains internal state such as current function and class names, local definitions, import mappings, and a directed graph representing function call relationships. It uses NetworkX to manage the graph structure and supports both synchronous and asynchronous function definitions.",
                "init_method": {
                    "description": "Initializes the CallGraph with a filename and sets up internal data structures including tracking for current function and class, local definitions, a NetworkX directed graph, import mappings, a set of function names, and edges for call relationships.",
                    "parameters": [
                        {
                            "name": "filename",
                            "type": "str",
                            "description": "The name of the file being processed to build the call graph."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_recursive_call",
                        "description": {
                            "overall": "Recursively extracts the dotted name components from an AST node representing a function call. It handles different types of AST nodes like Name, Attribute, and Call to build a list of name components that represent the full path of a function or method.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AST",
                                    "description": "An AST node representing a function call or reference."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "parts",
                                    "type": "list[str]",
                                    "description": "A list of strings representing the dotted name components."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the _resolve_all_callee_names method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_all_callee_names",
                        "description": {
                            "overall": "Resolves a list of dotted name components into full qualified names by checking local definitions, import mappings, and constructing appropriate names based on the current class context. It processes each component list to determine the correct fully qualified name for a callee.",
                            "parameters": [
                                {
                                    "name": "callee_nodes",
                                    "type": "list[list[str]]",
                                    "description": "A list of lists containing name components for callees."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "resolved",
                                    "type": "list[str]",
                                    "description": "A list of fully qualified names for the callees."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls the _recursive_call method to extract name components.",
                                "called_by": "This method is called by the visit_Call method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_make_full_name",
                        "description": {
                            "overall": "Constructs a fully qualified name for a function or method by combining the filename, optional class name, and base name. This helps in creating unique identifiers for functions within the call graph.",
                            "parameters": [
                                {
                                    "name": "basename",
                                    "type": "str",
                                    "description": "The base name of the function or method."
                                },
                                {
                                    "name": "class_name",
                                    "type": "Optional[str]",
                                    "description": "The name of the class if the function belongs to one."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "full_name",
                                    "type": "str",
                                    "description": "The fully qualified name constructed from the filename, class name, and base name."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the visit_FunctionDef method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_current_caller",
                        "description": {
                            "overall": "Determines the current caller's name based on whether there is an active function or class context. If no function is active, it defaults to the global scope or the filename.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "caller",
                                    "type": "str",
                                    "description": "The name of the current caller."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the visit_Call method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles the AST node for import statements by mapping aliases to their actual module names and storing them in the import mapping dictionary. This allows for resolving imported names correctly during call resolution.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "An AST node representing an import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Handles the AST node for 'from ... import ...' statements by mapping aliases to their respective modules and storing them in the import mapping dictionary. This enables proper resolution of names imported from other modules.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "An AST node representing a 'from ... import ...' statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "Processes AST nodes representing class definitions by temporarily setting the current class name and then visiting the class body. After processing, it restores the previous class name to maintain proper context.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "An AST node representing a class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Processes AST nodes representing function definitions by creating a fully qualified name for the function, updating local definitions, adding the function to the graph, and marking it in the function set. It also manages the current function context during traversal.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "An AST node representing a function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls _make_full_name and generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_AsyncFunctionDef",
                        "description": {
                            "overall": "Handles AST nodes representing asynchronous function definitions by delegating to the visit_FunctionDef method, ensuring that async functions are treated similarly to regular functions in terms of graph construction.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AsyncFunctionDef",
                                    "description": "An AST node representing an asynchronous function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls visit_FunctionDef to handle the function definition.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Call",
                        "description": {
                            "overall": "Processes AST nodes representing function calls by identifying the caller, extracting the callee's name components, resolving those names, and recording the call relationship in the graph edges. It ensures that call relationships are tracked properly.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Call",
                                    "description": "An AST node representing a function call."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls _current_caller, _recursive_call, _resolve_all_callee_names, and generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_If",
                        "description": {
                            "overall": "Handles AST nodes representing conditional statements. If the condition checks for '__name__ == '__main__'' it temporarily changes the current function context to '<main_block>' before visiting the conditional body, restoring the original context afterward.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.If",
                                    "description": "An AST node representing a conditional statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on the ast module for parsing Python code, networkx for graph operations, os for file system interactions, pathlib.Path for path manipulations, typing.Dict for type hints, getRepo.GitRepository for repository information, and basic_info.ProjektInfoExtractor for project metadata.",
                    "instantiated_by": "This class is instantiated in the build_filtered_callgraph function located in callgraph.py at lines 207 and 214."
                }
            },
            "error": null
        },
        "backend.getRepo.RepoFile": {
            "identifier": "backend.getRepo.RepoFile",
            "description": {
                "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as content and size to optimize performance by only loading data when necessary. The class provides properties to access the Git blob, content, and size of the file, along with utility methods for word count analysis and serialization to a dictionary format.",
                "init_method": {
                    "description": "Initializes a RepoFile object with a file path and a commit tree. It sets up internal attributes for lazy loading including placeholders for the blob, content, and size of the file.",
                    "parameters": [
                        {
                            "name": "file_path",
                            "type": "str",
                            "description": "The path to the file within the repository."
                        },
                        {
                            "name": "commit_tree",
                            "type": "git.Tree",
                            "description": "The tree object of the commit from which the file originates."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "blob",
                        "description": {
                            "overall": "A property that lazily loads the Git blob object associated with the file. If the blob hasn't been loaded yet, it retrieves it from the commit tree using the stored file path. Raises a FileNotFoundError if the file cannot be found in the commit tree.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "blob",
                                    "type": "git.Blob",
                                    "description": "The Git blob object representing the file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "content",
                        "description": {
                            "overall": "A property that lazily loads and returns the decoded content of the file. It reads the data stream from the blob and decodes it into UTF-8 text, ignoring encoding errors. The content is cached after the first access to avoid repeated reads.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "content",
                                    "type": "str",
                                    "description": "The decoded content of the file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "size",
                        "description": {
                            "overall": "A property that lazily loads and returns the size of the file in bytes. It accesses the size attribute of the blob object, caching the result after the first access to improve performance.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "size",
                                    "type": "int",
                                    "description": "The size of the file in bytes."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "analyze_word_count",
                        "description": {
                            "overall": "An example analysis method that counts the number of words in the file's content. It splits the content on whitespace and returns the resulting count.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "word_count",
                                    "type": "int",
                                    "description": "The total number of words in the file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__repr__",
                        "description": {
                            "overall": "Provides a useful string representation of the RepoFile object, displaying the file path for debugging and logging purposes.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "repr_string",
                                    "type": "str",
                                    "description": "A string representation of the RepoFile object."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "to_dict",
                        "description": {
                            "overall": "Serializes the RepoFile object into a dictionary format. It includes basic file information such as path, name, size, and type. Optionally, it can also include the file's content if requested.",
                            "parameters": [
                                {
                                    "name": "include_content",
                                    "type": "bool",
                                    "description": "Whether to include the file's content in the returned dictionary."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "data",
                                    "type": "dict",
                                    "description": "A dictionary containing file metadata and optionally the content."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on external modules such as git.Repo, git.GitCommandError, logging, and os.",
                    "instantiated_by": "This class is instantiated by the get_all_files method in getRepo.py at line 111."
                }
            },
            "error": null
        },
        "backend.getRepo.GitRepository": {
            "identifier": "backend.getRepo.GitRepository",
            "description": {
                "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to its files through RepoFile objects. It supports retrieving all files in the repository, constructing a hierarchical file tree representation, and cleaning up the temporary directory upon closing. The class implements the context manager protocol (__enter__ and __exit__) to ensure proper resource management.",
                "init_method": {
                    "description": "Initializes a GitRepository instance by cloning the specified repository URL into a temporary directory. It sets up necessary attributes such as the repository URL, temporary directory path, and references to the cloned repository and its latest commit. If cloning fails, it raises a RuntimeError after cleaning up resources.",
                    "parameters": [
                        {
                            "name": "repo_url",
                            "type": "str",
                            "description": "The URL of the Git repository to clone."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "get_all_files",
                        "description": {
                            "overall": "Retrieves a list of all files in the repository and creates RepoFile objects for each file. These objects are stored in the instance's 'files' attribute and returned. The method uses Git's ls-files command to enumerate the files.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "files",
                                    "type": "list[RepoFile]",
                                    "description": "A list of RepoFile instances representing the files in the repository."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "close",
                        "description": {
                            "overall": "Deletes the temporary directory used for cloning the repository and cleans up associated resources. This method ensures that temporary files are removed when the repository is no longer needed.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__enter__",
                        "description": {
                            "overall": "Enables the use of the GitRepository instance in a 'with' statement, returning the instance itself for use within the context block.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "instance",
                                    "type": "GitRepository",
                                    "description": "The GitRepository instance itself."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__exit__",
                        "description": {
                            "overall": "Implements the exit behavior for the 'with' statement context manager, ensuring that the close() method is called when exiting the context block.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                },
                                {
                                    "name": "exc_type",
                                    "type": "Any",
                                    "description": "Exception type if an exception occurred in the context block."
                                },
                                {
                                    "name": "exc_val",
                                    "type": "Any",
                                    "description": "Exception value if an exception occurred in the context block."
                                },
                                {
                                    "name": "exc_tb",
                                    "type": "Any",
                                    "description": "Exception traceback if an exception occurred in the context block."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the close() method internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "get_file_tree",
                        "description": {
                            "overall": "Constructs a hierarchical tree representation of the repository's file structure. If the files have not been retrieved yet, it calls get_all_files() to fetch them. Then, it iterates over the files to build a nested dictionary structure representing directories and files.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                },
                                {
                                    "name": "include_content",
                                    "type": "bool",
                                    "description": "Flag indicating whether to include file content in the returned dictionary."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "tree",
                                    "type": "dict",
                                    "description": "A dictionary representing the hierarchical file tree structure."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls the get_all_files() method if the files have not been previously fetched.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on the 'tempfile', 'shutil', 'git.Repo', 'git.GitCommandError', 'logging', and 'os' modules.",
                    "instantiated_by": "This class is instantiated in the evaluation.py file within the evaluation function at line 86 and in main.py within the main_workflow function at line 134."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.ProjectAnalyzer": {
            "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
            "description": {
                "overall": "The ProjectAnalyzer class is designed to analyze Python projects by examining their source code structure and identifying relationships between definitions such as functions, classes, and methods. It traverses the project directory to find Python files, parses them into Abstract Syntax Trees (ASTs), collects definitions including functions, classes, and methods along with their locations, and resolves inter-definition call relationships. The analyzer maintains internal state for definitions and call graphs, and finally formats the collected information into a structured result showing which definitions are called by others.",
                "init_method": {
                    "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including dictionaries for storing definitions, call graphs, and ASTs, as well as a set of directories to ignore during file traversal.",
                    "parameters": [
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "The root directory path of the project to be analyzed."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "analyze",
                        "description": {
                            "overall": "The main analysis method that orchestrates the process of finding Python files, collecting definitions from those files, resolving call relationships, and formatting the results. It iterates over all Python files in the project, collects definitions and resolves calls, clears temporary AST storage, and returns formatted results.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "output_list",
                                    "type": "list",
                                    "description": "A list of dictionaries representing definitions and their callers."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls `_find_py_files`, `_collect_definitions`, `_resolve_calls`, and `get_formatted_results`.",
                                "called_by": "This method is called by the functions `evaluation` in `evaluation.py` at line 120 and `main_workflow` in `main.py` at line 171."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_find_py_files",
                        "description": {
                            "overall": "Recursively walks through the project root directory to find all Python (.py) files, excluding specified directories like .git, venv, etc. It returns a list of absolute paths to these Python files.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "py_files",
                                    "type": "list",
                                    "description": "List of absolute file paths to Python files in the project."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the `analyze` method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_collect_definitions",
                        "description": {
                            "overall": "Parses a given Python file into an AST and extracts definitions such as functions, classes, and methods. It maps these definitions to their full qualified names (including module paths) and stores metadata like file location and type. Errors during parsing are logged.",
                            "parameters": [
                                {
                                    "name": "filepath",
                                    "type": "str",
                                    "description": "The absolute path to the Python file to analyze."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the `analyze` method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_get_parent",
                        "description": {
                            "overall": "Given an AST tree and a node, this method attempts to find the parent node of the given node by walking the AST. It is used to determine if a function or method is defined within a class.",
                            "parameters": [
                                {
                                    "name": "tree",
                                    "type": "ast.AST",
                                    "description": "The AST tree to search in."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.AST",
                                    "description": "The node whose parent is to be found."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "parent",
                                    "type": "ast.AST or None",
                                    "description": "The parent node of the given node, or None if not found."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the `_collect_definitions` method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_calls",
                        "description": {
                            "overall": "Resolves call relationships within a given Python file by using a CallResolverVisitor to traverse the AST and collect call information. It updates the global call graph with the resolved calls.",
                            "parameters": [
                                {
                                    "name": "filepath",
                                    "type": "str",
                                    "description": "The absolute path to the Python file to resolve calls in."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls `CallResolverVisitor` and its `visit` method.",
                                "called_by": "This method is called by the `analyze` method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "get_formatted_results",
                        "description": {
                            "overall": "Formats the collected call graph and definition information into a structured list of dictionaries. Each dictionary represents a definition and includes details about its origin and the callers that reference it.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "output_list",
                                    "type": "list",
                                    "description": "A list of dictionaries containing formatted definition and call relationship data."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the `analyze` method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond standard library imports (ast, os, logging, collections.defaultdict).",
                    "instantiated_by": "This class is instantiated by the functions `evaluation` in `evaluation.py` at line 119 and `main_workflow` in `main.py` at line 170."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.CallResolverVisitor": {
            "identifier": "backend.relationship_analyzer.CallResolverVisitor",
            "description": {
                "overall": "The CallResolverVisitor class is an AST (Abstract Syntax Tree) visitor designed to analyze Python code and resolve call relationships between functions, methods, and classes. It tracks the current execution context (such as class and function names) and records calls made within the code. Additionally, it maintains mappings of imported modules and class instances to support accurate call resolution.",
                "init_method": {
                    "description": "Initializes the CallResolverVisitor with the file path, project root directory, and a set of definitions. It also sets up internal tracking structures such as scope, instance types, and call records.",
                    "parameters": [
                        {
                            "name": "filepath",
                            "type": "str",
                            "description": "The path to the Python file being analyzed."
                        },
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "The root directory of the project being analyzed."
                        },
                        {
                            "name": "definitions",
                            "type": "set",
                            "description": "A collection of known definitions (functions, classes, etc.) in the project."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "Handles the visitation of class definitions in the AST. It temporarily updates the current class name during traversal and restores it afterward to maintain proper context for subsequent visits.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "The AST node representing the class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor framework when encountering a class definition."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Handles the visitation of function definitions in the AST. It temporarily updates the current caller name to the function name during traversal and restores it afterward to maintain proper context for subsequent visits.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "The AST node representing the function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor framework when encountering a function definition."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Call",
                        "description": {
                            "overall": "Processes function or method calls in the AST. It resolves the qualified name of the called function and records the call along with metadata like the caller, file, and line number if the call is in the known definitions.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Call",
                                    "description": "The AST node representing the function or method call."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the private helper method `_resolve_call_qname` to determine the qualified name of the call.",
                                "called_by": "This method is called by the generic AST visitor framework when encountering a function or method call."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles import statements in the AST. It maps imported names to their actual module paths in the scope dictionary for later reference during call resolution.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "The AST node representing the import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor framework when encountering an import statement."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Handles 'from ... import ...' statements in the AST. It resolves relative imports and maps imported names to their fully qualified module paths in the scope dictionary.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "The AST node representing the 'from ... import ...' statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor framework when encountering a 'from ... import ...' statement."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Assign",
                        "description": {
                            "overall": "Processes assignment statements in the AST. Specifically, it identifies assignments of class instances and records the type of the assigned instance for future use in call resolution.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Assign",
                                    "description": "The AST node representing the assignment statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor framework when encountering an assignment statement."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_call_qname",
                        "description": {
                            "overall": "Resolves the qualified name of a function or method call based on the AST node representing the call. It handles both direct names and attribute-based calls (e.g., obj.method).",
                            "parameters": [
                                {
                                    "name": "func_node",
                                    "type": "ast.expr",
                                    "description": "The AST node representing the function or method being called."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "qualified_name",
                                    "type": "str or None",
                                    "description": "The fully qualified name of the function or method, or None if it cannot be resolved."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the `visit_Call` method to resolve the qualified name of a call."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "No external dependencies are explicitly listed.",
                    "instantiated_by": "This class is instantiated in the `_resolve_calls` function located in `relationship_analyzer.py` at line 92."
                }
            },
            "error": null
        },
        "schemas.types.ParameterDescription": {
            "identifier": "schemas.types.ParameterDescription",
            "description": {
                "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the description of a single function parameter. It encapsulates three essential attributes: the parameter's name, its type, and a textual description. This class ensures data integrity and structure for parameter metadata, making it suitable for use in APIs, documentation systems, or any application requiring standardized parameter definitions.",
                "init_method": {
                    "description": "The constructor initializes the ParameterDescription instance with three required fields: name, type, and description. These fields are defined as string types and are expected to be provided during instantiation.",
                    "parameters": [
                        {
                            "name": "name",
                            "type": "str",
                            "description": "The name of the function parameter."
                        },
                        {
                            "name": "type",
                            "type": "str",
                            "description": "The data type of the function parameter."
                        },
                        {
                            "name": "description",
                            "type": "str",
                            "description": "A textual description of the function parameter's purpose or usage."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those already imported in the source file.",
                    "instantiated_by": "This class is not instantiated by any other component as per the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ReturnDescription": {
            "identifier": "schemas.types.ReturnDescription",
            "description": {
                "overall": "The ReturnDescription class is a Pydantic model designed to represent and validate the description of a function's return value. It encapsulates three essential attributes: the name of the return value, its type, and a textual description. This class ensures data integrity and provides a standardized structure for documenting function returns within the system.",
                "init_method": {
                    "description": "Initializes a ReturnDescription instance with required fields for describing a function's return value. The constructor sets up the instance with name, type, and description attributes.",
                    "parameters": [
                        {
                            "name": "name",
                            "type": "str",
                            "description": "The name of the return value."
                        },
                        {
                            "name": "type",
                            "type": "str",
                            "description": "The type of the return value."
                        },
                        {
                            "name": "description",
                            "type": "str",
                            "description": "A textual description of the return value."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
                    "instantiated_by": "This class is not instantiated by any other component as indicated by the context."
                }
            },
            "error": null
        },
        "schemas.types.UsageContext": {
            "identifier": "schemas.types.UsageContext",
            "description": {
                "overall": "The UsageContext class is a Pydantic model designed to represent and validate the calling context of a function, specifically capturing information about what functions are called and by whom. It serves as a structured data container for describing the usage relationships between functions within a codebase.",
                "init_method": {
                    "description": "Initializes a UsageContext instance with two string fields: 'calls', which describes the functions being called, and 'called_by', which identifies the caller of the function.",
                    "parameters": [
                        {
                            "name": "calls",
                            "type": "str",
                            "description": "A string describing the functions or methods that are called within the context."
                        },
                        {
                            "name": "called_by",
                            "type": "str",
                            "description": "A string identifying the function or method that is making the call."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.FunctionDescription": {
            "identifier": "schemas.types.FunctionDescription",
            "description": {
                "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed information about a function's purpose, parameters, return values, and usage context. It serves as a structured representation for documenting function signatures and behavior, making it easier to analyze and communicate function details within a codebase.",
                "init_method": {
                    "description": "The constructor initializes the FunctionDescription instance with four required fields: 'overall', 'parameters', 'returns', and 'usage_context'. These fields represent the function's purpose, parameter descriptions, return value descriptions, and usage context respectively.",
                    "parameters": [
                        {
                            "name": "overall",
                            "type": "str",
                            "description": "A string describing the overall purpose and functionality of the function."
                        },
                        {
                            "name": "parameters",
                            "type": "List[ParameterDescription]",
                            "description": "A list of ParameterDescription objects detailing each parameter of the function."
                        },
                        {
                            "name": "returns",
                            "type": "List[ReturnDescription]",
                            "description": "A list of ReturnDescription objects detailing each return value of the function."
                        },
                        {
                            "name": "usage_context",
                            "type": "UsageContext",
                            "description": "An object describing the usage context of the function."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond standard typing and pydantic.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.FunctionAnalysis": {
            "identifier": "schemas.types.FunctionAnalysis",
            "description": {
                "overall": "The FunctionAnalysis class is a Pydantic BaseModel designed to represent the complete JSON schema for a function. It serves as a structured data model that encapsulates essential information about a function, including its identifier, a detailed description, and an optional error field. This class ensures type safety and validation for function-related metadata, making it suitable for use in APIs, configuration systems, or any application requiring standardized function schemas.",
                "init_method": {
                    "description": "Initializes a FunctionAnalysis instance with required fields for the function's identifier and description, along with an optional error field.",
                    "parameters": [
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string identifier for the function."
                        },
                        {
                            "name": "description",
                            "type": "FunctionDescription",
                            "description": "An instance of FunctionDescription containing detailed information about the function."
                        },
                        {
                            "name": "error",
                            "type": "Optional[str]",
                            "description": "An optional string field to store error messages related to the function."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
                    "instantiated_by": "This class is not instantiated by any other component based on the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ConstructorDescription": {
            "identifier": "schemas.types.ConstructorDescription",
            "description": {
                "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It encapsulates a textual description of the constructor's purpose and a list of parameter descriptions that define its interface. This class serves as a structured representation for documenting constructor details, likely used in automated documentation or introspection systems.",
                "init_method": {
                    "description": "Initializes a ConstructorDescription instance with a description of the constructor and a list of parameter descriptions.",
                    "parameters": [
                        {
                            "name": "description",
                            "type": "str",
                            "description": "A textual description of the constructor's purpose and behavior."
                        },
                        {
                            "name": "parameters",
                            "type": "List[ParameterDescription]",
                            "description": "A list of ParameterDescription objects detailing each parameter of the constructor."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
                    "instantiated_by": "This class is not instantiated by any other component according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ClassContext": {
            "identifier": "schemas.types.ClassContext",
            "description": {
                "overall": "The ClassContext class is a Pydantic model designed to describe and encapsulate information about a class's external dependencies and the entities that instantiate it. It serves as a structured representation of metadata related to class usage and integration within a system.",
                "init_method": {
                    "description": "Initializes a ClassContext instance with two string attributes: 'dependencies' and 'instantiated_by'. These fields are intended to store information about the class's external dependencies and the entities responsible for its instantiation.",
                    "parameters": [
                        {
                            "name": "dependencies",
                            "type": "str",
                            "description": "A string describing the external dependencies of the class."
                        },
                        {
                            "name": "instantiated_by",
                            "type": "str",
                            "description": "A string describing the entities or classes that instantiate this class."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any other external modules or libraries beyond those imported in the file.",
                    "instantiated_by": "This class is not instantiated by any other component within the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ClassDescription": {
            "identifier": "schemas.types.ClassDescription",
            "description": {
                "overall": "The ClassDescription class is a Pydantic model designed to encapsulate a comprehensive analysis of a Python class. It holds information about the class's overall purpose, its constructor details, a list of its methods along with their descriptions, and contextual usage information. This class serves as a structured representation for documenting and communicating the essential characteristics and behaviors of a class within a codebase.",
                "init_method": {
                    "description": "Initializes a new instance of the ClassDescription class with default values for all fields. The constructor sets up the basic structure required to hold detailed analysis information about a class.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond standard library imports and Pydantic.",
                    "instantiated_by": "This class is not instantiated by any other component based on the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ClassAnalysis": {
            "identifier": "schemas.types.ClassAnalysis",
            "description": {
                "overall": "The ClassAnalysis class serves as the primary data model for representing the complete JSON schema of a class. It encapsulates essential information about a class including its identifier, a detailed description, and an optional error field. This class is designed to provide a standardized structure for documenting class metadata and associated descriptions, making it suitable for use in documentation systems or schema validation processes.",
                "init_method": {
                    "description": "Initializes a new instance of the ClassAnalysis class with the required identifier and description fields, and an optional error field.",
                    "parameters": [
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string identifier for the class being analyzed."
                        },
                        {
                            "name": "description",
                            "type": "ClassDescription",
                            "description": "An instance of ClassDescription containing detailed information about the class."
                        },
                        {
                            "name": "error",
                            "type": "Optional[str]",
                            "description": "An optional string field that can contain error messages related to the class analysis."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
                    "instantiated_by": "This class is not instantiated by any other components as indicated in the context."
                }
            },
            "error": null
        },
        "schemas.types.CallInfo": {
            "identifier": "schemas.types.CallInfo",
            "description": {
                "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It serves as a data structure to capture metadata related to how functions are invoked within the system.",
                "init_method": {
                    "description": "Initializes a CallInfo instance with fields representing a call event, including the file path, function name, call mode, and line number.",
                    "parameters": [
                        {
                            "name": "file",
                            "type": "str",
                            "description": "The file path where the call event occurred."
                        },
                        {
                            "name": "function",
                            "type": "str",
                            "description": "The name of the function that made the call."
                        },
                        {
                            "name": "mode",
                            "type": "str",
                            "description": "The mode of the call, such as 'method', 'function', or 'module'."
                        },
                        {
                            "name": "line",
                            "type": "int",
                            "description": "The line number in the file where the call occurred."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "No external dependencies were identified for this class.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.FunctionContextInput": {
            "identifier": "schemas.types.FunctionContextInput",
            "description": {
                "overall": "The FunctionContextInput class is a Pydantic model designed to structure contextual information for analyzing a function. It encapsulates two key pieces of information: a list of function calls made within the function and a list of CallInfo objects indicating which functions call this one. This class serves as a data transfer object to represent the calling context of a function in a standardized format.",
                "init_method": {
                    "description": "Initializes the FunctionContextInput with two attributes: 'calls', a list of strings representing function names called within the function, and 'called_by', a list of CallInfo objects representing functions that call this function.",
                    "parameters": [
                        {
                            "name": "calls",
                            "type": "List[str]",
                            "description": "A list of strings representing the names of functions called within the analyzed function."
                        },
                        {
                            "name": "called_by",
                            "type": "List[CallInfo]",
                            "description": "A list of CallInfo objects representing the functions that call the analyzed function."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond its declared imports.",
                    "instantiated_by": "The class is instantiated by the 'evaluation' function in 'evaluation.py' at line 162 and by the 'main_workflow' function in 'main.py' at line 216."
                }
            },
            "error": null
        },
        "schemas.types.FunctionAnalysisInput": {
            "identifier": "schemas.types.FunctionAnalysisInput",
            "description": {
                "overall": "The FunctionAnalysisInput class serves as a structured input model for generating FunctionAnalysis objects. It encapsulates essential metadata and contextual information required for function analysis, including the mode of operation, identifier, source code, imports, and associated context.",
                "init_method": {
                    "description": "Initializes the FunctionAnalysisInput instance with required fields including the operational mode, identifier, source code, list of imports, and contextual input.",
                    "parameters": [
                        {
                            "name": "mode",
                            "type": "Literal[\"function_analysis\"]",
                            "description": "Specifies the operational mode for the analysis, constrained to the literal value 'function_analysis'."
                        },
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A unique identifier for the function being analyzed."
                        },
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "The complete source code of the function under analysis."
                        },
                        {
                            "name": "imports",
                            "type": "List[str]",
                            "description": "A list of import statements used within the function's source code."
                        },
                        {
                            "name": "context",
                            "type": "FunctionContextInput",
                            "description": "Additional contextual information required for the function analysis."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports list.",
                    "instantiated_by": "The class is instantiated by the evaluation function in evaluation.py at line 167 and by the main_workflow function in main.py at line 221."
                }
            },
            "error": null
        },
        "schemas.types.MethodContextInput": {
            "identifier": "schemas.types.MethodContextInput",
            "description": {
                "overall": "The MethodContextInput class is a Pydantic model designed to structure contextual information about a method within a class. It encapsulates details such as the method's identifier, the methods it calls, the methods that call it, its arguments, and its docstring. This class serves as a standardized way to represent and pass around metadata related to method usage and dependencies in a structured format.",
                "init_method": {
                    "description": "The constructor initializes the MethodContextInput instance with fields for storing method metadata including its identifier, a list of methods it calls, a list of CallInfo objects indicating which methods call it, a list of argument names, and an optional docstring.",
                    "parameters": [
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string identifier for the method."
                        },
                        {
                            "name": "calls",
                            "type": "List[str]",
                            "description": "A list of strings representing the identifiers of methods called by this method."
                        },
                        {
                            "name": "called_by",
                            "type": "List[CallInfo]",
                            "description": "A list of CallInfo objects detailing which methods call this method."
                        },
                        {
                            "name": "args",
                            "type": "List[str]",
                            "description": "A list of strings representing the argument names of the method."
                        },
                        {
                            "name": "docstring",
                            "type": "Optional[str]",
                            "description": "An optional string containing the docstring of the method."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports list.",
                    "instantiated_by": "This class is instantiated in the evaluation.py file within the evaluation function at line 187 and in the main.py file within the main_workflow function at line 241."
                }
            },
            "error": null
        },
        "schemas.types.ClassContextInput": {
            "identifier": "schemas.types.ClassContextInput",
            "description": {
                "overall": "The ClassContextInput class is a Pydantic model designed to encapsulate structured context information for analyzing a class. It holds three main pieces of data: a list of dependencies, a list of call information for instances where the class is instantiated, and a list of method context inputs for each method within the class.",
                "init_method": {
                    "description": "The constructor initializes the ClassContextInput instance with three attributes: dependencies, instantiated_by, and method_context. These attributes are expected to hold lists of strings, CallInfo objects, and MethodContextInput objects respectively.",
                    "parameters": [
                        {
                            "name": "dependencies",
                            "type": "List[str]",
                            "description": "A list of string identifiers representing the dependencies of the class."
                        },
                        {
                            "name": "instantiated_by",
                            "type": "List[CallInfo]",
                            "description": "A list of CallInfo objects indicating where and how the class is instantiated."
                        },
                        {
                            "name": "method_context",
                            "type": "List[MethodContextInput]",
                            "description": "A list of MethodContextInput objects providing context for each method within the class."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not directly depend on any external modules beyond those imported in the file.",
                    "instantiated_by": "The class is instantiated by the main_orchestrator function in HelperLLM.py at line 369, the evaluation function in evaluation.py at line 199, and the main_workflow function in main.py at line 253."
                }
            },
            "error": null
        },
        "schemas.types.ClassAnalysisInput": {
            "identifier": "schemas.types.ClassAnalysisInput",
            "description": {
                "overall": "The ClassAnalysisInput class serves as a data transfer object (DTO) for encapsulating the necessary inputs required to generate a ClassAnalysis object. It defines the structure of the input data including metadata about the mode, identifier, source code, imports, and associated context.",
                "init_method": {
                    "description": "Initializes the ClassAnalysisInput instance with the required fields: mode, identifier, source_code, imports, and context. The mode is constrained to the literal value 'class_analysis', ensuring strict adherence to the expected input format for class analysis operations.",
                    "parameters": [
                        {
                            "name": "mode",
                            "type": "Literal['class_analysis']",
                            "description": "A literal string value that must be 'class_analysis' to indicate the type of analysis being performed."
                        },
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string identifier representing the name of the class being analyzed."
                        },
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "A string containing the full source code of the class to be analyzed."
                        },
                        {
                            "name": "imports",
                            "type": "List[str]",
                            "description": "A list of strings representing the import statements used in the source file containing the class."
                        },
                        {
                            "name": "context",
                            "type": "ClassContextInput",
                            "description": "An object containing contextual information about the class, such as dependencies and instantiation details."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond standard typing and pydantic components.",
                    "instantiated_by": "The class is instantiated by the main_orchestrator function in HelperLLM.py at line 338, the evaluation function in evaluation.py at line 205, and the main_workflow function in main.py at line 259."
                }
            },
            "error": null
        }
    }
}