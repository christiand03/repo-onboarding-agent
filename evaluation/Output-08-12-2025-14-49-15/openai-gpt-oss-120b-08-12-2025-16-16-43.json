{
    "functions": {
        "backend.AST_Schema.path_to_module": {
            "identifier": "backend.AST_Schema.path_to_module",
            "description": {
                "overall": "The function converts a filesystem path to a dotted Python module path. It first attempts to compute the path relative to the given project root, falling back to the filename if the relative computation fails. The function strips a trailing '.py' extension and replaces OS-specific path separators with dots. If the resulting module path ends with '.__init__', that suffix is removed before the final module path is returned.",
                "parameters": [
                    {
                        "name": "filepath",
                        "type": "str",
                        "description": "The absolute or relative path of the file that should be translated into a module import path."
                    },
                    {
                        "name": "project_root",
                        "type": "str",
                        "description": "The root directory of the Python project against which the relative path is calculated."
                    }
                ],
                "returns": [
                    {
                        "name": "module_path",
                        "type": "str",
                        "description": "A dotted module path derived from the input file path, suitable for use in import statements."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not call any other functions.",
                    "called_by": "It is invoked by the __init__ method of the AST_Schema class in AST_Schema.py (line 31)."
                }
            },
            "error": null
        },
        "backend.File_Dependency.build_file_dependency_graph": {
            "identifier": "backend.File_Dependency.build_file_dependency_graph",
            "description": {
                "overall": "The function builds a directed dependency graph for a given source file. It receives the file name, its abstract syntax tree, and the repository root path. A custom AST visitor (FileDependencyGraph) extracts import relationships, which are then added as nodes and edges to a NetworkX DiGraph. Finally, the populated graph is returned to the caller.",
                "parameters": [
                    {
                        "name": "filename",
                        "type": "str",
                        "description": "The name (or path) of the source file for which the dependency graph is being constructed."
                    },
                    {
                        "name": "tree",
                        "type": "AST",
                        "description": "The abstract syntax tree representation of the source file."
                    },
                    {
                        "name": "repo_root",
                        "type": "str",
                        "description": "The root directory of the repository containing the source file."
                    }
                ],
                "returns": [
                    {
                        "name": "graph",
                        "type": "nx.DiGraph",
                        "description": "A directed graph where each node represents a module/file and each edge (caller → callee) represents an import dependency."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not invoke any other functions within the provided context.",
                    "called_by": "It is called by the function build_repository_graph in File_Dependency.py (line 177)."
                }
            },
            "error": null
        },
        "backend.File_Dependency.build_repository_graph": {
            "identifier": "backend.File_Dependency.build_repository_graph",
            "description": {
                "overall": "The function builds a directed dependency graph for a Git repository by iterating over all files in the repository. For each Python file it extracts the filename, parses the file content into an AST, and creates a file‑level dependency graph using `build_file_dependency_graph`. The nodes and edges from each file graph are merged into a single global NetworkX `DiGraph`, with non‑Python files being ignored. After processing all files, the aggregated graph representing inter‑file call relationships is returned.",
                "parameters": [
                    {
                        "name": "repository",
                        "type": "GitRepository",
                        "description": "An object representing the Git repository, providing methods such as `get_all_files()` and attributes like `temp_dir`."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "nx.DiGraph",
                        "description": "A directed graph where nodes correspond to symbols (e.g., functions, classes) and edges represent call relationships across the repository's Python files."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly within its body.",
                    "called_by": "It is invoked by the backend.File_Dependency module in File_Dependency.py at line 233."
                }
            },
            "error": null
        },
        "backend.File_Dependency.get_all_temp_files": {
            "identifier": "backend.File_Dependency.get_all_temp_files",
            "description": {
                "overall": "The function `get_all_temp_files` enumerates all Python source files within a given directory tree. It converts the supplied directory string into an absolute `Path` object. Using `Path.rglob(\"*.py\")` it recursively finds every file ending with `.py`. For each found file it computes the path relative to the root directory and collects these into a list. The list of relative `Path` objects is returned to the caller.",
                "parameters": [
                    {
                        "name": "directory",
                        "type": "str",
                        "description": "The directory path to search for Python files."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "list[Path]",
                        "description": "A list of `Path` objects representing the relative paths of all discovered `.py` files."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not invoke any other functions.",
                    "called_by": "It is invoked by the method `_resolve_module_name` in `File_Dependency.py` (line 43)."
                }
            },
            "error": null
        },
        "backend.File_Dependency.nx_to_mermaid_with_folders": {
            "identifier": "backend.File_Dependency.nx_to_mermaid_with_folders",
            "description": {
                "overall": "The function converts a NetworkX directed graph whose nodes represent file paths into a Mermaid diagram string that visualizes the files and their folder hierarchy. It first groups nodes by their parent folder, building a mapping from folder paths to file names. Then it constructs Mermaid subgraph definitions for each folder, adding nodes for the files, and finally adds edges representing the graph's relationships. The resulting multiline string can be rendered by Mermaid to display the file dependency structure.",
                "parameters": [
                    {
                        "name": "G",
                        "type": "nx.DiGraph",
                        "description": "A directed graph where each node is a file path (e.g., \"src/utils/helpers.py\") and edges represent dependencies between files."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "str",
                        "description": "A Mermaid diagram definition as a multiline string that visualizes the folder hierarchy and file dependencies."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not invoke any other functions.",
                    "called_by": "No functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "backend.HelperLLM.main_orchestrator": {
            "identifier": "backend.HelperLLM.main_orchestrator",
            "description": {
                "overall": "The `main_orchestrator` function creates example inputs for function analysis, validates them, and assembles corresponding analysis objects. It then instantiates an `LLMHelper` with the appropriate system prompts and uses it to generate documentation for the provided functions. The generated documentation objects are collected into a final dictionary, logged, and printed as formatted JSON. This orchestrates the end‑to‑end flow of preparing dummy data, invoking the LLM helper, and outputting the aggregated documentation.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly within its own logic.",
                    "called_by": "It is invoked by the `backend.HelperLLM` module at HelperLLM.py line 419."
                }
            },
            "error": null
        },
        "backend.callgraph.make_safe_dot": {
            "identifier": "backend.callgraph.make_safe_dot",
            "description": {
                "overall": "The function generates a DOT representation of a NetworkX directed graph while ensuring that node identifiers are safe for DOT syntax. It first copies the input graph, then creates a mapping from each original node to a simple name like \"n0\", \"n1\", etc. The graph is relabeled using this mapping, and the original node identifier is stored as a \"label\" attribute on the new node. Finally, the relabeled graph is written to the specified output path using NetworkX's Pydot writer.",
                "parameters": [
                    {
                        "name": "graph",
                        "type": "nx.DiGraph",
                        "description": "The directed graph to be converted into a DOT file."
                    },
                    {
                        "name": "out_path",
                        "type": "str",
                        "description": "Filesystem path where the generated DOT file will be saved."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "It is invoked by the function backend.callgraph defined in the file callgraph.py at line 252."
                }
            },
            "error": null
        },
        "backend.callgraph.build_filtered_callgraph": {
            "identifier": "backend.callgraph.build_filtered_callgraph",
            "description": {
                "overall": "The function builds a global call graph for a given Git repository and then filters this graph to retain only edges between functions that are defined within the repository itself. It first collects all Python files from the repository, parses each file into an abstract syntax tree, and records the functions defined in each file using a CallGraph visitor. Afterwards it iterates over the collected ASTs again, adding edges to a NetworkX directed graph only when both the caller and callee belong to the set of own functions. The resulting directed graph represents the filtered call relationships and is returned to the caller.",
                "parameters": [
                    {
                        "name": "repo",
                        "type": "GitRepository",
                        "description": "An object representing the Git repository from which source files are retrieved via its `get_all_files` method."
                    }
                ],
                "returns": [
                    {
                        "name": "global_graph",
                        "type": "nx.DiGraph",
                        "description": "A directed graph containing nodes for functions defined in the repository and edges for calls between those functions."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly (the provided context lists no internal calls).",
                    "called_by": "It is invoked by the function `analyze_repository` in `AST_Schema.py` (line 167) and by the module `backend.callgraph` in `callgraph.py` (line 251)."
                }
            },
            "error": null
        },
        "backend.main.create_savings_chart": {
            "identifier": "backend.main.create_savings_chart",
            "description": {
                "overall": "The function creates a bar chart that compares the number of JSON tokens with the number of TOON tokens and annotates the chart with the percentage of savings. It defines labels, values, and colors for the two bars, then uses Matplotlib to draw the figure with a specific size. The chart includes a title showing the savings percentage, axis labels, a grid, and numeric labels displayed above each bar. Finally, the chart is saved to the supplied file path and the Matplotlib figure is closed.",
                "parameters": [
                    {
                        "name": "json_tokens",
                        "type": "int",
                        "description": "The count of tokens for the JSON format, used as the height of the first bar."
                    },
                    {
                        "name": "toon_tokens",
                        "type": "int",
                        "description": "The count of tokens for the TOON format, used as the height of the second bar."
                    },
                    {
                        "name": "savings_percent",
                        "type": "float",
                        "description": "The percentage of token savings, displayed in the chart title with two decimal places."
                    },
                    {
                        "name": "output_path",
                        "type": "str",
                        "description": "Filesystem path where the generated chart image will be saved."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function main_workflow in main.py (line 442)."
                }
            },
            "error": null
        },
        "backend.main.calculate_net_time": {
            "identifier": "backend.main.calculate_net_time",
            "description": {
                "overall": "The function calculates the net elapsed time between a start and end timestamp, adjusting for artificial sleep periods that are introduced to respect rate limits for certain models. It first computes the raw duration as `end_time - start_time`. If the `model_name` does not start with \"gemini-\", the raw duration is returned unchanged. For Gemini models, it determines how many batches of items will be processed, computes the number of required sleep intervals (61 seconds each), subtracts the total sleep time from the raw duration, and finally returns the non‑negative result.",
                "parameters": [
                    {
                        "name": "start_time",
                        "type": "int | float",
                        "description": "The timestamp marking the beginning of the operation."
                    },
                    {
                        "name": "end_time",
                        "type": "int | float",
                        "description": "The timestamp marking the end of the operation."
                    },
                    {
                        "name": "total_items",
                        "type": "int",
                        "description": "The total number of items that will be processed."
                    },
                    {
                        "name": "batch_size",
                        "type": "int",
                        "description": "The number of items processed in a single batch."
                    },
                    {
                        "name": "model_name",
                        "type": "str",
                        "description": "The name of the model; sleep adjustments are applied only when it starts with \"gemini-\"."
                    }
                ],
                "returns": [
                    {
                        "name": "net_time",
                        "type": "int | float",
                        "description": "The net elapsed time after subtracting any required sleep periods; guaranteed to be zero or positive."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the `evaluation` function in `evaluation.py` (lines 249 and 275) and by the `main_workflow` function in `main.py` (lines 304 and 335)."
                }
            },
            "error": null
        },
        "backend.main.main_workflow": {
            "identifier": "backend.main.main_workflow",
            "description": {
                "overall": "The function **main_workflow** orchestrates the complete analysis pipeline for a given repository URL. It extracts API keys and model names, validates the input, clones the repository, extracts basic project information, builds an AST schema and relationship data, and prepares inputs for helper LLMs that generate documentation for functions and classes. After aggregating these intermediate results, it calls a main LLM to produce a final markdown report while updating status via an optional callback and extensive logging. The function finally returns a dictionary containing the generated report and timing metrics.",
                "parameters": [
                    {
                        "name": "input",
                        "type": "Any",
                        "description": "The raw user input string that should contain a GitHub repository URL and possibly other instructions."
                    },
                    {
                        "name": "api_keys",
                        "type": "dict",
                        "description": "Dictionary mapping service names (e.g., \"gemini\", \"gpt\", \"scadsllm\") to their corresponding API keys."
                    },
                    {
                        "name": "model_names",
                        "type": "dict",
                        "description": "Dictionary mapping role identifiers (e.g., \"helper\", \"main\") to the model names that should be used for each LLM."
                    },
                    {
                        "name": "status_callback",
                        "type": "Callable[[str], None] | None",
                        "description": "Optional callable that receives status messages for UI updates; if omitted, status is only logged."
                    }
                ],
                "returns": [
                    {
                        "name": "result",
                        "type": "dict",
                        "description": "A dictionary with two keys: \"report\" containing the final markdown report string, and \"metrics\" containing timing and model information."
                    }
                ],
                "usage_context": {
                    "calls": "According to the provided context, this function does not call any other functions that are tracked in the `calls` list.",
                    "called_by": "This function is invoked by `frontend.Frontend` in *Frontend.py* (line 489) and by `backend.main` in *main.py* (line 469)."
                }
            },
            "error": null
        },
        "backend.main.update_status": {
            "identifier": "backend.main.update_status",
            "description": {
                "overall": "The `update_status` function records a status message and optionally forwards it to a callback. It accepts a single argument `msg` representing the message to be handled. If a global `status_callback` is defined and truthy, the function invokes this callback with the message. Afterwards, it logs the message using `logging.info`. The function does not return any value.",
                "parameters": [
                    {
                        "name": "msg",
                        "type": "Any",
                        "description": "The status message to be logged and optionally passed to the status callback."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function `main_workflow` in `main.py` at lines 80, 127, 151, 160, 168, 178, 188, 198, 294, 326, 329, 402, and 405."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.path_to_module": {
            "identifier": "backend.relationship_analyzer.path_to_module",
            "description": {
                "overall": "The function converts a filesystem file path into a dotted Python module path that can be used for imports. It first attempts to compute the path relative to the given project root, falling back to the file's basename if that fails. The function then removes a trailing `.py` extension, replaces OS‑specific path separators with dots, and strips a trailing `.__init__` segment for package modules. Finally, it returns the resulting module path string.",
                "parameters": [
                    {
                        "name": "filepath",
                        "type": "str",
                        "description": "The absolute or relative path to the Python file that should be translated into a module path."
                    },
                    {
                        "name": "project_root",
                        "type": "str",
                        "description": "The root directory of the project against which the file path is made relative."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "str",
                        "description": "A dotted module path derived from the input file path (e.g., \"package.submodule\")."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is called by the methods `_collect_definitions` and `__init__` in the file `relationship_analyzer.py`."
                }
            },
            "error": null
        },
        "database.db.encrypt_text": {
            "identifier": "database.db.encrypt_text",
            "description": {
                "overall": "The function `encrypt_text` encrypts a given string using a globally‑available `cipher_suite`. It first checks that the input `text` is non‑empty and that `cipher_suite` is defined; if either check fails, the original text is returned unchanged. When both conditions are satisfied, the function strips whitespace from the text, encodes it to bytes, encrypts it with `cipher_suite.encrypt`, and decodes the resulting bytes back to a string. The returned value is therefore the encrypted representation of the input text, or the original text if encryption could not be performed.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "The plaintext string that should be encrypted."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "str",
                        "description": "The encrypted text as a decoded string, or the original `text` if it was empty or `cipher_suite` was unavailable."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is called by the function `update_gemini_key` defined in `db.py` (line 71)."
                }
            },
            "error": null
        },
        "database.db.decrypt_text": {
            "identifier": "database.db.decrypt_text",
            "description": {
                "overall": "The function `decrypt_text` receives a string that is expected to be encrypted and attempts to decrypt it using a globally defined `cipher_suite` (a Fernet instance). If the input string is empty or the `cipher_suite` is unavailable, the function immediately returns the original input. It strips whitespace, encodes the string to bytes, decrypts it, and decodes the result back to a string. Any exception raised during decryption is caught, and the original input is returned unchanged.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "The encrypted text to be decrypted; may be an empty string."
                    }
                ],
                "returns": [
                    {
                        "name": "result",
                        "type": "str",
                        "description": "The decrypted string if decryption succeeds; otherwise the original `text` value."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is called by the function `get_decrypted_api_keys` in `db.py` (line 93)."
                }
            },
            "error": null
        },
        "database.db.insert_user": {
            "identifier": "database.db.insert_user",
            "description": {
                "overall": "The function creates a new user document and inserts it into a MongoDB collection. It receives a username, a display name, and a plain‑text password. The password is hashed using the Streamlit Authenticator hasher before being stored. After insertion, the function returns the identifier of the newly created document.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user; it is stored as the document's \"_id\" field."
                    },
                    {
                        "name": "name",
                        "type": "str",
                        "description": "The display name of the user."
                    },
                    {
                        "name": "password",
                        "type": "str",
                        "description": "The user's plain‑text password, which will be hashed before storage."
                    }
                ],
                "returns": [
                    {
                        "name": "inserted_id",
                        "type": "ObjectId",
                        "description": "The MongoDB identifier of the newly inserted user document."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is called by the Frontend.Frontend function in Frontend.py (line 294)."
                }
            },
            "error": null
        },
        "database.db.fetch_all_users": {
            "identifier": "database.db.fetch_all_users",
            "description": {
                "overall": "The function `fetch_all_users` retrieves every user document stored in the database. It accesses the `dbusers` collection and invokes its `find` method to obtain a cursor over all records. The cursor is immediately converted to a Python `list`, materialising the complete result set in memory. Finally, the list of user records is returned to the caller.",
                "parameters": [],
                "returns": [
                    {
                        "name": "users",
                        "type": "list",
                        "description": "A list containing all user documents returned by `dbusers.find()`."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not call any other functions.",
                    "called_by": "It is called by the `frontend.Frontend` function in `Frontend.py` at line 244."
                }
            },
            "error": null
        },
        "database.db.fetch_user": {
            "identifier": "database.db.fetch_user",
            "description": {
                "overall": "The function `fetch_user` retrieves a user record from a MongoDB collection. It accepts a single argument, `username`, which is used as the document identifier. Inside the function, it calls the `find_one` method on the `dbusers` collection, passing a query that matches the `_id` field to the provided username. The result of this database query is returned directly to the caller. No additional processing or error handling is performed.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username identifier used to query the user document."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "dict",
                        "description": "The user document retrieved from the `dbusers` collection, or `None` if no matching document is found."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not invoke any other functions.",
                    "called_by": "No other functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "database.db.update_user_name": {
            "identifier": "database.db.update_user_name",
            "description": {
                "overall": "The function updates the \"name\" field of a user document in a MongoDB collection. It uses the provided `username` as the `_id` filter and applies a `$set` operation with the `new_name`. The MongoDB `update_one` call returns an `UpdateResult`, from which the function extracts `modified_count`. Finally, it returns the number of documents that were modified (typically 0 or 1). The function does not attempt to modify the `_id` field itself.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The identifier of the user to locate in the collection; used as the value for the `_id` field in the query filter."
                    },
                    {
                        "name": "new_name",
                        "type": "str",
                        "description": "The new name value that will be set for the user's \"name\" field."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were modified by the update operation (0 if no matching document, 1 if the name was updated)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "No other functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "database.db.update_gemini_key": {
            "identifier": "database.db.update_gemini_key",
            "description": {
                "overall": "The function updates a user's stored Gemini API key in the database. It first removes surrounding whitespace from the supplied key and encrypts the cleaned value using `encrypt_text`. The encrypted key is then written to the `dbusers` collection with a MongoDB `update_one` operation that matches the document whose `_id` equals the provided username. Finally, the function returns the count of modified documents, indicating whether the update was successful.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The identifier of the user whose Gemini API key should be updated; used as the `_id` field in the MongoDB query."
                    },
                    {
                        "name": "gemini_api_key",
                        "type": "str",
                        "description": "The raw Gemini API key to be stored; it will be stripped of whitespace and encrypted before being saved."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were modified by the update operation (typically 0 or 1)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions within the provided source code.",
                    "called_by": "It is invoked by `save_gemini_cb` in *Frontend.py* and by the `Frontend.Frontend` module initialization in *Frontend.py*."
                }
            },
            "error": null
        },
        "database.db.update_ollama_url": {
            "identifier": "database.db.update_ollama_url",
            "description": {
                "overall": "The function updates a user's record in the MongoDB collection `dbusers` by setting the `ollama_base_url` field to a cleaned version of the provided URL. It builds a filter using the supplied `username` as the document `_id` and applies a `$set` operation with the stripped URL. After performing the update, it returns the number of documents that were modified. This allows callers to know whether the update succeeded (typically 1) or had no effect (0).",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier of the user whose document will be updated (used as the `_id` field in the query)."
                    },
                    {
                        "name": "ollama_base_url",
                        "type": "str",
                        "description": "The base URL for the Ollama service to store in the user's document; whitespace is removed via `strip()` before saving."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were modified by the update operation (0 if no document matched, 1 if the user's record was updated)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by `save_ollama_cb` in `Frontend.py` (line 42) and by `frontend.Frontend` in `Frontend.py` (line 407)."
                }
            },
            "error": null
        },
        "database.db.fetch_gemini_key": {
            "identifier": "database.db.fetch_gemini_key",
            "description": {
                "overall": "The function fetch_gemini_key retrieves a Gemini API key associated with a specific user from a MongoDB collection. It queries the collection `dbusers` for a document whose `_id` matches the provided username, projecting only the `gemini_api_key` field. If a matching document exists, the function extracts and returns the API key; otherwise it returns None. This provides a simple lookup utility for obtaining stored Gemini credentials.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The identifier of the user whose Gemini API key should be fetched; used as the `_id` filter in the MongoDB query."
                    }
                ],
                "returns": [
                    {
                        "name": "gemini_api_key",
                        "type": "Union[str, None]",
                        "description": "The Gemini API key string if a matching user document is found; otherwise None."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "No other functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "database.db.fetch_ollama_url": {
            "identifier": "database.db.fetch_ollama_url",
            "description": {
                "overall": "The function `fetch_ollama_url` retrieves the Ollama base URL for a specific user from a MongoDB collection. It accepts a username string, queries the `dbusers` collection for a document whose `_id` matches the provided username, and requests only the `ollama_base_url` field. If a matching document is found, the function extracts the URL value; otherwise, it returns `None`. The implementation relies on the MongoDB driver to perform the lookup and uses a concise conditional expression to handle the presence or absence of the user record.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The identifier of the user whose Ollama base URL should be fetched."
                    }
                ],
                "returns": [
                    {
                        "name": "ollama_base_url",
                        "type": "Optional[str]",
                        "description": "The Ollama base URL associated with the given username, or `None` if the user does not exist or the field is missing."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "No other functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "database.db.delete_user": {
            "identifier": "database.db.delete_user",
            "description": {
                "overall": "The function `delete_user` removes a user record from the MongoDB collection `dbusers`. It accepts a single argument, `username`, which is expected to be a string representing the user's identifier. The function builds a query that matches the `_id` field to the provided username and calls the collection's `delete_one` method. It then returns the `deleted_count` attribute of the operation result, indicating how many documents were removed. A return value of `1` signifies that the user was successfully deleted, while `0` means no matching user was found.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username (used as the document `_id`) of the user to be removed."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of documents deleted (0 if no matching user, 1 if deletion succeeded)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "No other functions are documented as calling this function."
                }
            },
            "error": null
        },
        "database.db.get_decrypted_api_keys": {
            "identifier": "database.db.get_decrypted_api_keys",
            "description": {
                "overall": "The function `get_decrypted_api_keys` retrieves a user's stored API credentials from a MongoDB collection and returns them in plaintext. It accepts a single argument, `username`, which is used to query the `dbusers` collection for a matching document. If no document is found, the function returns a pair of `None` values. When a document exists, it decrypts the stored Gemini API key using `decrypt_text` and extracts the Ollama base URL without decryption. Finally, it returns both values as a two‑element tuple.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username identifier used to look up the user document in the `dbusers` collection."
                    }
                ],
                "returns": [
                    {
                        "name": "api_keys",
                        "type": "Tuple[Optional[str], Optional[str]]",
                        "description": "A tuple containing the decrypted Gemini API key and the Ollama base URL, or `(None, None)` if the user does not exist."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the `frontend.Frontend` function in `Frontend.py` at lines 380 and 479."
                }
            },
            "error": null
        },
        "database.db.insert_chat": {
            "identifier": "database.db.insert_chat",
            "description": {
                "overall": "The function `insert_chat` creates a new chat document and stores it in a MongoDB collection. It receives a username and a chat name, generates a unique identifier for the chat, and records the current timestamp. The constructed dictionary is then inserted into the `dbchats` collection using the `insert_one` method. Finally, the function returns the identifier of the newly inserted document.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The name of the user who owns the chat."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The display name of the chat to be created."
                    }
                ],
                "returns": [
                    {
                        "name": "inserted_id",
                        "type": "ObjectId",
                        "description": "The unique identifier generated by MongoDB for the newly inserted chat document."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly (it only uses standard library utilities and the MongoDB collection method).",
                    "called_by": "It is invoked by `load_data_from_db`, `handle_delete_chat`, and the `Frontend` class in `Frontend.py`."
                }
            },
            "error": null
        },
        "database.db.fetch_chats_by_user": {
            "identifier": "database.db.fetch_chats_by_user",
            "description": {
                "overall": "The function `fetch_chats_by_user` retrieves all chat records associated with a given username from a MongoDB collection. It accepts a single string argument representing the user's name. Inside the function, it queries the `dbchats` collection, filters documents by the provided username, and sorts the results by the `created_at` timestamp in ascending order. The matching documents are materialized into a list and returned to the caller. This operation enables downstream components to load a user's chat history in chronological order.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username whose chat records should be fetched from the database."
                    }
                ],
                "returns": [
                    {
                        "name": "chats",
                        "type": "list",
                        "description": "A list of chat documents (as dictionaries) belonging to the specified user, ordered by creation time."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function `load_data_from_db` defined in `Frontend.py` (line 57)."
                }
            },
            "error": null
        },
        "database.db.check_chat_exists": {
            "identifier": "database.db.check_chat_exists",
            "description": {
                "overall": "The function `check_chat_exists` determines whether a specific chat record is present in the MongoDB collection `dbchats`. It accepts a username and a chat name, builds a query dictionary, and passes it to the collection's `find_one` method. The result of `find_one` is compared to `None` to produce a boolean outcome. If a matching document is found, the function returns `True`; otherwise, it returns `False`. This provides a simple existence check without retrieving the full document.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat to be looked up."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat whose existence is being verified."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "bool",
                        "description": "True if a document matching the given username and chat_name exists in `dbchats`; otherwise False."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions or methods directly.",
                    "called_by": "No calling functions are listed in the provided context."
                }
            },
            "error": null
        },
        "database.db.rename_chat_fully": {
            "identifier": "database.db.rename_chat_fully",
            "description": {
                "overall": "The function `rename_chat_fully` renames a chat and all of its associated exchanges for a given user. It first updates the chat entry in the `dbchats` collection by setting the `chat_name` field to the new name. Afterwards it updates every message (exchange) belonging to that chat in the `dbexchanges` collection, also setting their `chat_name` to the new name. Finally it returns the number of chat documents that were modified by the operation. The implementation relies on MongoDB's `update_one` and `update_many` methods.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username of the owner of the chat that is being renamed."
                    },
                    {
                        "name": "old_name",
                        "type": "str",
                        "description": "The current name of the chat to be renamed."
                    },
                    {
                        "name": "new_name",
                        "type": "str",
                        "description": "The new name that will replace the old chat name."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of chat documents that were modified by the `update_one` operation."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is called by the `frontend.Frontend` function in the file `Frontend.py` (line 462)."
                }
            },
            "error": null
        },
        "database.db.insert_exchange": {
            "identifier": "database.db.insert_exchange",
            "description": {
                "overall": "The function creates a new exchange record and stores it in a MongoDB collection. It generates a unique identifier using UUID and assembles a dictionary containing the question, answer, feedback, user information, timing metadata, and a creation timestamp. The record is then inserted into the `dbexchanges` collection; if the insertion succeeds, the generated identifier is returned, otherwise the function prints an error message and returns `None`. This encapsulates the full lifecycle of persisting a single chat exchange.",
                "parameters": [
                    {
                        "name": "question",
                        "type": "str",
                        "description": "The text of the user's question."
                    },
                    {
                        "name": "answer",
                        "type": "str",
                        "description": "The system's answer to the question."
                    },
                    {
                        "name": "feedback",
                        "type": "str",
                        "description": "Feedback provided for the exchange."
                    },
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username of the participant."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat session."
                    },
                    {
                        "name": "helper_used",
                        "type": "str",
                        "description": "Identifier of any helper model used (optional)."
                    },
                    {
                        "name": "main_used",
                        "type": "str",
                        "description": "Identifier of any main model used (optional)."
                    },
                    {
                        "name": "total_time",
                        "type": "str",
                        "description": "Total time taken for the exchange (optional)."
                    },
                    {
                        "name": "helper_time",
                        "type": "str",
                        "description": "Time spent in the helper component (optional)."
                    },
                    {
                        "name": "main_time",
                        "type": "str",
                        "description": "Time spent in the main component (optional)."
                    }
                ],
                "returns": [
                    {
                        "name": "new_id",
                        "type": "Optional[str]",
                        "description": "The generated UUID string of the inserted exchange on success, or `None` if the database insertion fails."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the `frontend.Frontend` function in `Frontend.py` (line 530)."
                }
            },
            "error": null
        },
        "database.db.fetch_exchanges_by_user": {
            "identifier": "database.db.fetch_exchanges_by_user",
            "description": {
                "overall": "The function fetch_exchanges_by_user retrieves exchange records for a specific user from the MongoDB collection `dbexchanges`. It filters documents where the \"username\" field matches the provided username, sorts the results by the \"created_at\" timestamp in ascending order, and converts the cursor to a Python list. The sorted list is then returned to the caller. This ordering ensures that exchanges are displayed chronologically.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username whose exchange records should be fetched from the database."
                    }
                ],
                "returns": [
                    {
                        "name": "exchanges",
                        "type": "list[dict]",
                        "description": "A list of exchange documents belonging to the given user, sorted by the `created_at` timestamp in ascending order."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function `load_data_from_db` in the file `Frontend.py` (line 64)."
                }
            },
            "error": null
        },
        "database.db.fetch_exchanges_by_chat": {
            "identifier": "database.db.fetch_exchanges_by_chat",
            "description": {
                "overall": "The function fetch_exchanges_by_chat retrieves chat exchange records from a MongoDB collection. It accepts a username and a chat name, builds a query to match documents with those fields, and sorts the results by the creation timestamp in ascending order. The MongoDB cursor is materialized into a Python list, which is then returned to the caller. This provides a convenient way to obtain the full conversation history for a specific user and chat.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username used to filter exchange documents in the database."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat whose exchanges should be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "exchanges",
                        "type": "List[dict]",
                        "description": "A list of exchange records matching the given username and chat name, ordered by the 'created_at' field in ascending order."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "No other functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "database.db.update_exchange_feedback": {
            "identifier": "database.db.update_exchange_feedback",
            "description": {
                "overall": "The function `update_exchange_feedback` updates the feedback value for a specific exchange record in the database. It receives an exchange identifier and an integer feedback score. Using the `dbexchanges` collection, it performs an `update_one` operation that sets the `feedback` field to the provided value. The function returns the number of documents that were modified as an integer.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "Any",
                        "description": "Identifier of the exchange document to be updated."
                    },
                    {
                        "name": "feedback",
                        "type": "int",
                        "description": "The new feedback score to store."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "Number of documents whose feedback field was modified (0 if no document matched)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function `handle_feedback_change` in `Frontend.py` (line 98)."
                }
            },
            "error": null
        },
        "database.db.update_exchange_feedback_message": {
            "identifier": "database.db.update_exchange_feedback_message",
            "description": {
                "overall": "The function update_exchange_feedback_message updates the feedback_message field of a specific exchange document in the database. It receives the exchange's identifier and the new feedback message as arguments. Using the dbexchanges collection, it performs an update_one operation that sets the feedback_message field to the provided value. The function then returns the number of documents that were modified, allowing the caller to know whether the update succeeded.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "Any",
                        "description": "The unique identifier of the exchange document to be updated."
                    },
                    {
                        "name": "feedback_message",
                        "type": "str",
                        "description": "The new feedback message to store in the exchange record."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "int",
                        "description": "The count of documents that were modified (0 if no matching exchange was found)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is called by the function render_exchange in Frontend.py (line 211)."
                }
            },
            "error": null
        },
        "database.db.delete_exchange_by_id": {
            "identifier": "database.db.delete_exchange_by_id",
            "description": {
                "overall": "The function `delete_exchange_by_id` removes a single exchange document from the MongoDB collection `dbexchanges` based on a provided identifier. It accepts a string `exchange_id` representing the `_id` of the document to delete. Inside the function it calls the `delete_one` method on the `dbexchanges` collection with a filter `{\"_id\": exchange_id}`. The function then returns the number of documents that were deleted, obtained from the `deleted_count` attribute of the result. This return value lets the caller know whether the deletion was successful.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "str",
                        "description": "The identifier of the exchange document to be removed; used as the `_id` field in the MongoDB query."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of documents deleted by the operation (0 if no matching document was found, 1 if the deletion succeeded)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function `handle_delete_exchange` defined in `Frontend.py` (line 102)."
                }
            },
            "error": null
        },
        "database.db.delete_full_chat": {
            "identifier": "database.db.delete_full_chat",
            "description": {
                "overall": "The function `delete_full_chat` permanently removes a chat and all of its related exchange messages for a specific user. It first deletes every exchange document that matches the provided `username` and `chat_name` using `dbexchanges.delete_many`. Afterwards it deletes the chat document itself from the chat collection with `dbchats.delete_one`. Finally, it returns the number of chat documents that were deleted, allowing the caller to know whether the operation succeeded.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username of the user whose chat is to be deleted."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat to delete."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_chat_count",
                        "type": "int",
                        "description": "The count of chat documents removed (0 if no chat matched, 1 if the chat was deleted)."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function `handle_delete_chat` in `Frontend.py` (line 110)."
                }
            },
            "error": null
        },
        "frontend.Frontend.save_gemini_cb": {
            "identifier": "frontend.Frontend.save_gemini_cb",
            "description": {
                "overall": "The function `save_gemini_cb` reads a Gemini API key from Streamlit's session state under the key `in_gemini_key`. If a non‑empty key is found, it updates the stored Gemini key for the current user by calling `db.update_gemini_key`. After updating, it clears the temporary session entry and displays a toast notification indicating that the Gemini key was saved successfully. The function performs no explicit return and operates solely for its side effects.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "No other functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "frontend.Frontend.save_ollama_cb": {
            "identifier": "frontend.Frontend.save_ollama_cb",
            "description": {
                "overall": "The function `save_ollama_cb` reads a potential Ollama service URL from the Streamlit session state under the key `in_ollama_url`. If a non‑empty URL is found, it updates the stored Ollama URL for the current user by calling `db.update_ollama_url` with the username from the session state and the new URL. After successfully updating the database, it displays a toast notification to the user confirming that the URL has been saved. The function performs no further actions and does not return any value.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "No other functions are recorded as calling this function."
                }
            },
            "error": null
        },
        "frontend.Frontend.load_data_from_db": {
            "identifier": "frontend.Frontend.load_data_from_db",
            "description": {
                "overall": "The function loads a user's chat history and associated exchanges from the database into Streamlit's session state. It first checks whether the data for the given username has already been loaded; if not, it clears any existing chat data. It then retrieves defined chats, creates placeholder entries for them, loads all exchanges (adding missing chats for legacy data), normalizes missing feedback values, and stores everything in the session state. If no chats exist after loading, a default chat is created both in the database and in the session state. Finally, it ensures an active chat is set and records the username as the loaded user.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The identifier of the user whose chats and exchanges should be loaded from the database."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the Frontend class in Frontend.py at line 310."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_feedback_change": {
            "identifier": "frontend.Frontend.handle_feedback_change",
            "description": {
                "overall": "The function `handle_feedback_change` updates the feedback field of a given exchange object and persists the change to the database. It receives an exchange dictionary `ex` and a new feedback value `val`. First, it assigns `val` to the `\"feedback\"` key of `ex`. Then it calls `db.update_exchange_feedback` with the exchange's identifier and the new value to update the stored record. Finally, it triggers a Streamlit rerun via `st.rerun()` to refresh the UI.",
                "parameters": [
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary representing an exchange, expected to contain keys such as \"_id\" and \"feedback\"."
                    },
                    {
                        "name": "val",
                        "type": "Any",
                        "description": "The new feedback value to be stored."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the `render_exchange` function in Frontend.py at lines 199 and 204."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_delete_exchange": {
            "identifier": "frontend.Frontend.handle_delete_exchange",
            "description": {
                "overall": "The function `handle_delete_exchange` removes a specific exchange record from both the persistent database and the in‑memory session state for a given chat. It first deletes the exchange document in the database by calling `db.delete_exchange_by_id` with the exchange's `_id`. Then, if the chat exists in `st.session_state.chats` and the exchange is present in that chat's list of exchanges, it removes the exchange from the list. Finally, it triggers a Streamlit rerun to refresh the UI. The function performs no explicit return.",
                "parameters": [
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The identifier (name) of the chat whose exchanges are being managed."
                    },
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary representing the exchange to delete; it must contain an \"_id\" key used for database deletion."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly within the provided code.",
                    "called_by": "It is invoked by the `render_exchange` function in `Frontend.py` at lines 228 and 234."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_delete_chat": {
            "identifier": "frontend.Frontend.handle_delete_chat",
            "description": {
                "overall": "The function `handle_delete_chat` removes a specific chat belonging to a user from the persistent database and then updates the Streamlit session state to reflect this deletion. It first invokes `db.delete_full_chat` to delete the chat record in the database. Afterwards it cleans up the in‑memory `st.session_state.chats` dictionary, selects a new active chat if any remain, or creates a default empty chat when none are left, and finally forces the UI to refresh with `st.rerun()`. The implementation relies on the `database.db` module and Streamlit's session state handling.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The identifier of the user whose chat is being deleted."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat to delete."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "According to the provided context, this function does not call any other functions.",
                    "called_by": "It is called by the `Frontend` class defined in `Frontend.py` at line 367."
                }
            },
            "error": null
        },
        "frontend.Frontend.extract_repo_name": {
            "identifier": "frontend.Frontend.extract_repo_name",
            "description": {
                "overall": "The function `extract_repo_name` extracts a repository name from a block of text that may contain a URL. It first searches the text for an HTTP or HTTPS URL using a regular expression. If a URL is found, it parses the URL, isolates the path component, and takes the last segment as the repository name, stripping a trailing `.git` suffix if present. The function returns the cleaned repository name or `None` when no suitable URL is detected.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "A string that may contain a repository URL from which the repository name should be extracted."
                    }
                ],
                "returns": [
                    {
                        "name": "repo_name",
                        "type": "Optional[str]",
                        "description": "The extracted repository name without a trailing `.git` extension, or `None` if no URL could be parsed from the input."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the `frontend.Frontend` class (in `Frontend.py` at line 442)."
                }
            },
            "error": null
        },
        "frontend.Frontend.stream_text_generator": {
            "identifier": "frontend.Frontend.stream_text_generator",
            "description": {
                "overall": "The function `stream_text_generator` receives a text string, splits it into individual words using a space delimiter, and iterates over those words. For each word it yields the word concatenated with a trailing space, then pauses briefly (0.01 seconds) before proceeding to the next word. This creates a streaming effect where the output appears incrementally rather than all at once. The function is a simple generator intended for use cases such as live text display.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "The input text to be split into words."
                    }
                ],
                "returns": [
                    {
                        "name": "",
                        "type": "Generator[str]",
                        "description": "Yields each word from the input text followed by a space, with a short delay between yields."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions.",
                    "called_by": "It is invoked by the function `render_text_with_mermaid` in `Frontend.py` (line 160)."
                }
            },
            "error": null
        },
        "frontend.Frontend.render_text_with_mermaid": {
            "identifier": "frontend.Frontend.render_text_with_mermaid",
            "description": {
                "overall": "The function renders a markdown string that may contain Mermaid diagram definitions. It first checks for an empty input and returns early if none is provided. The markdown is split on fenced Mermaid code blocks; plain text segments are displayed as regular markdown (optionally streamed), while Mermaid sections are rendered using Streamlit's Mermaid component with a fallback to a code block on error. This enables mixed markdown and diagram content to be shown in a Streamlit app.",
                "parameters": [
                    {
                        "name": "markdown_text",
                        "type": "str",
                        "description": "The markdown content to be rendered, which may include one or more Mermaid diagram blocks delimited by ```mermaid ... ```."
                    },
                    {
                        "name": "should_stream",
                        "type": "bool",
                        "description": "When True, the plain‑text markdown portions are streamed to the UI using `st.write_stream`; otherwise they are rendered directly with `st.markdown`."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other user‑defined functions within the provided context (it uses `re.split`, Streamlit APIs, and `st_mermaid`).",
                    "called_by": "It is called by `render_exchange` in `Frontend.py` at line 238 and by the `Frontend` class initializer in `Frontend.py` at line 524."
                }
            },
            "error": null
        },
        "frontend.Frontend.render_exchange": {
            "identifier": "frontend.Frontend.render_exchange",
            "description": {
                "overall": "The function renders a single chat exchange in a Streamlit interface. It first displays the user's question, then creates an assistant message block that shows the answer together with a toolbar containing feedback buttons, a comment pop‑over, a download button and a delete button. If the answer indicates an error, an error message and a delete option are shown instead. Finally, the answer text (potentially containing Mermaid diagrams) is rendered inside a scrollable container.",
                "parameters": [
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary representing the exchange; expected keys include \"question\", \"answer\", \"feedback\", \"feedback_message\", \"_id\" and optional \"feedback\" values."
                    },
                    {
                        "name": "current_chat_name",
                        "type": "str",
                        "description": "The name of the chat session to which this exchange belongs, used when deleting the exchange."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other user‑defined functions according to the provided context.",
                    "called_by": "It is invoked by the Frontend class defined in Frontend.py (line 429)."
                }
            },
            "error": null
        }
    },
    "classes": {
        "backend.AST_Schema.ASTVisitor": {
            "identifier": "backend.AST_Schema.ASTVisitor",
            "description": {
                "overall": "ASTVisitor walks a Python abstract syntax tree (AST) to build a lightweight schema describing imports, functions, and classes found in a source file. It records the raw source, file location, and module path, then populates a structured dictionary that can be consumed by downstream analysis tools. The visitor tracks the currently‑processed class to attach method information to the appropriate class entry. By leveraging the generic NodeVisitor traversal it can handle any Python module without needing explicit handling for every node type.",
                "init_method": {
                    "description": "The constructor stores the raw source code, the file's absolute path, and the project root, then derives the module path using a helper function. It also creates an empty schema dictionary that will be populated with imports, functions, and classes as the AST is visited, and initializes a placeholder for the class currently being processed.",
                    "parameters": [
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "The full text of the Python source file that will be parsed."
                        },
                        {
                            "name": "file_path",
                            "type": "str",
                            "description": "The filesystem path to the source file."
                        },
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "The root directory of the repository, used to compute the module's dotted path."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "backend.AST_Schema.ASTVisitor.visit_Import",
                        "description": {
                            "overall": "This method processes `import` statements encountered in the AST. It iterates over each alias in the node's `names` list and records the imported module name in the visitor's `schema[\"imports\"]` collection. After collecting the import names it delegates further traversal to the base class via `generic_visit`. The method does not produce a return value; its effect is purely side‑effectual, enriching the schema with import information.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "ASTVisitor",
                                    "description": "The visitor instance."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "The AST node representing an `import` statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other functions call this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "backend.AST_Schema.ASTVisitor.visit_ImportFrom",
                        "description": {
                            "overall": "This method handles `from … import …` statements found in the AST. For each alias it constructs a fully‑qualified import string (`module.name`) and appends it to the visitor's `schema[\"imports\"]`. It then continues the generic AST traversal with `generic_visit`. Like `visit_Import`, it returns nothing and only mutates the internal schema.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "ASTVisitor",
                                    "description": "The visitor instance."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "The AST node representing a `from … import …` statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other functions call this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "backend.AST_Schema.ASTVisitor.visit_ClassDef",
                        "description": {
                            "overall": "When a class definition node is encountered, this method builds a unique identifier for the class based on the module path and the class name. It assembles a dictionary containing metadata such as the class's source segment, line numbers, and an empty context placeholder, then appends this dictionary to `schema[\"classes\"]`. The method sets `_current_class` to the newly created class info so that subsequent function definitions are recorded as methods of this class, walks the class body with `generic_visit`, and finally resets `_current_class` to `None`.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "ASTVisitor",
                                    "description": "The visitor instance."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "The AST node representing a class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other functions call this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "backend.AST_Schema.ASTVisitor.visit_FunctionDef",
                        "description": {
                            "overall": "This method processes function definition nodes. If the visitor is currently inside a class (`_current_class` is set), it creates a method context entry containing the method's identifier, name, arguments, and docstring, and stores it in the class's `context[\"method_context\"]` list. If the function is top‑level, it creates a function analysis entry with similar metadata and adds it to `schema[\"functions\"]`. After recording the appropriate information, it continues traversal with `generic_visit`. The method does not return a value.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "ASTVisitor",
                                    "description": "The visitor instance."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "The AST node representing a function or method definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other functions call this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "backend.AST_Schema.ASTVisitor.visit_AsyncFunctionDef",
                        "description": {
                            "overall": "The visitor treats asynchronous function definitions the same way as regular functions by delegating to `visit_FunctionDef`. It receives an `AsyncFunctionDef` node and forwards it to `visit_FunctionDef`, thereby reusing the logic that records method or function metadata. No additional processing is performed, and the method does not return a value.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "ASTVisitor",
                                    "description": "The visitor instance."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.AsyncFunctionDef",
                                    "description": "The AST node representing an asynchronous function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other functions call this method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not have external dependencies.",
                    "instantiated_by": "ASTVisitor is instantiated in the file AST_Schema.py within the function analyze_repository at line 182."
                }
            },
            "error": null
        },
        "backend.AST_Schema.ASTAnalyzer": {
            "identifier": "backend.AST_Schema.ASTAnalyzer",
            "description": {
                "overall": "The **ASTAnalyzer** class is responsible for extracting a structural representation of a Python code base. It parses each file, builds an abstract syntax tree (AST) via an `ASTVisitor`, and collects information about functions, classes, imports and their relationships. After the initial schema is created, it enriches the data with call‑graph information and merges additional relationship data such as instantiation and call origins. The resulting nested dictionary can be used by downstream tools to understand code dependencies, call relationships, and module structure across an entire repository.",
                "init_method": {
                    "description": "The constructor takes no arguments and performs no initialization work; it simply exists to allow instantiation of the analyzer.",
                    "parameters": []
                },
                "methods": [
                    {
                        "identifier": "_enrich_schema_with_callgraph",
                        "description": {
                            "overall": "This static helper iterates over the function and class entries of a per‑file schema and injects call‑graph information. For each function it builds a key `<filename>::<function_name>` and, if present in the supplied `call_graph`, adds a sorted list of successor nodes as the function's `calls` and predecessor nodes as `called_by`. For each class method it builds a similar key `<filename>::<class_name>::<method_name>` and adds the corresponding call relationships. The method mutates the supplied `schema` in‑place and does not return a value.",
                            "parameters": [
                                {
                                    "name": "schema",
                                    "type": "dict",
                                    "description": "A dictionary representing the AST schema for a single file, containing keys like \"functions\" and \"classes\"."
                                },
                                {
                                    "name": "call_graph",
                                    "type": "nx.DiGraph",
                                    "description": "A directed graph (from networkx) where nodes are fully‑qualified identifiers and edges represent call relationships."
                                },
                                {
                                    "name": "filename",
                                    "type": "str",
                                    "description": "The path of the file the schema belongs to; used to construct the fully‑qualified keys."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other functions call this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "merge_relationship_data",
                        "description": {
                            "overall": "This method merges external relationship information (e.g., who called a function or instantiated a class) into an existing full schema. It first builds a lookup table from the supplied `relationship_data` mapping identifiers to their `called_by` lists. It then walks through every file, function, class, and method in the schema, and where an identifier matches the lookup, it updates the corresponding `called_by` or `instantiated_by` fields. The operation is performed in‑place on the provided `full_schema` and the enriched schema is returned.",
                            "parameters": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "The complete repository schema containing per‑file AST nodes."
                                },
                                {
                                    "name": "relationship_data",
                                    "type": "list",
                                    "description": "A list of dictionaries, each with an 'identifier' key and optional 'called_by' information."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "merged_schema",
                                    "type": "dict",
                                    "description": "The input `full_schema` after it has been enriched with relationship data."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "It is called by the `evaluation` function in `evaluation.py` (line 137) and by the `main_workflow` function in `main.py` (line 190)."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "analyze_repository",
                        "description": {
                            "overall": "The main entry point of the class, this method orchestrates the full analysis of a repository. It receives a list of file objects and a `GitRepository` instance, determines the project root, and builds a global filtered call graph. For each Python file it parses the source into an AST, walks it with an `ASTVisitor` to produce a per‑file schema, and then enriches that schema with call‑graph data using `_enrich_schema_with_callgraph`. All successfully processed file schemas are collected into a `full_schema` dictionary, which is finally returned. Errors during parsing are caught and reported via printed warnings, allowing the analysis to continue for other files.",
                            "parameters": [
                                {
                                    "name": "files",
                                    "type": "list",
                                    "description": "A list of file objects, each having at least `path` and `content` attributes."
                                },
                                {
                                    "name": "repo",
                                    "type": "GitRepository",
                                    "description": "An object representing the Git repository; used to build the call graph."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "A dictionary containing the aggregated AST and call‑graph information for all processed files."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly (it invokes helper functions internally, but they are not listed in the provided context).",
                                "called_by": "It is called by the `evaluation` function in `evaluation.py` (line 129) and by the `main_workflow` function in `main.py` (line 181)."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not declare any external runtime dependencies beyond the imported modules (`ast`, `networkx`, `os`, and the custom `GitRepository` and call‑graph builder).",
                    "instantiated_by": "Instances of `ASTAnalyzer` are created in `evaluation.py` within the `evaluation` function (line 128) and in `main.py` inside the `main_workflow` function (line 180)."
                }
            },
            "error": null
        },
        "backend.File_Dependency.FileDependencyGraph": {
            "identifier": "backend.File_Dependency.FileDependencyGraph",
            "description": {
                "overall": "FileDependencyGraph is an AST NodeVisitor that walks through a Python file's abstract syntax tree and records which modules or symbols the file imports. It builds a dictionary (`import_dependencies`) that maps each filename to a set of its import dependencies, handling both absolute and relative imports. The class resolves relative imports by locating the appropriate module files or exported symbols in package `__init__.py` files, and records the resolved names for later graph construction.",
                "init_method": {
                    "description": "The constructor stores the target filename and the repository root path that are needed for import resolution and dependency tracking.",
                    "parameters": [
                        {
                            "name": "filename",
                            "type": "str",
                            "description": "The name (or relative path) of the Python file whose imports are being analysed."
                        },
                        {
                            "name": "repo_root",
                            "type": "Any",
                            "description": "The root directory of the repository; used to locate other files when resolving relative imports."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_resolve_module_name",
                        "description": {
                            "overall": "Resolves relative `from .. import name1, name2` statements to the actual module or symbol names that exist in the repository. It determines the import level, locates candidate files matching the current file, walks up the directory hierarchy according to the relative level, and then checks each imported name for a corresponding module file or an exported symbol in a package's `__init__.py`. Helper functions `module_file_exists` and `init_exports_symbol` perform these existence checks. If no names can be resolved, an ImportError is raised; otherwise a sorted list of unique resolved names is returned.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "FileDependencyGraph",
                                    "description": "The instance of the class."
                                },
                                {
                                    "name": "node",
                                    "type": "ImportFrom",
                                    "description": "AST node representing a relative `from ... import ...` statement."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "list[str]",
                                    "description": "A sorted list of resolved module or symbol names that exist in the repository."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method defines and uses the internal helpers `module_file_exists` and `init_exports_symbol` to check file existence and symbol export status.",
                                "called_by": "No other methods in the class call `_resolve_module_name` directly, except `visit_ImportFrom` when handling relative imports."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Visits an `import` or `import from` AST node and records the imported names as dependencies for the current file. For each alias in the node, it ensures an entry for the current filename exists in `import_dependencies` and adds either the provided `base_name` (when supplied) or the alias name itself to the set. After processing, it continues the generic AST traversal.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "FileDependencyGraph",
                                    "description": "The instance of the class."
                                },
                                {
                                    "name": "node",
                                    "type": "Import | ImportFrom",
                                    "description": "The AST node representing an import statement."
                                },
                                {
                                    "name": "base_name",
                                    "type": "str | None",
                                    "description": "Optional base module name to record instead of the alias name."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "Calls `self.generic_visit(node)` to continue traversing the AST.",
                                "called_by": "Invoked by `visit_ImportFrom` and directly by the AST visitor when an `Import` node is encountered."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Handles `ImportFrom` AST nodes. If the import has an explicit module (`from a.b.c import d`), it extracts the last part of the module path and records it via `visit_Import`. If the import is relative (no module name), it attempts to resolve the import using `_resolve_module_name`; each resolved base name is then recorded with `visit_Import`. ImportErrors during resolution are caught and reported, and the method finally continues generic AST traversal.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "FileDependencyGraph",
                                    "description": "The instance of the class."
                                },
                                {
                                    "name": "node",
                                    "type": "ImportFrom",
                                    "description": "The AST node representing a `from ... import ...` statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "Calls `_resolve_module_name` for relative imports, `visit_Import` to record dependencies, and `self.generic_visit(node)` to continue traversal. May also call `print` on import resolution failures.",
                                "called_by": "Automatically invoked by the AST traversal when an `ImportFrom` node is encountered."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not rely on external runtime dependencies beyond the standard library and the imported modules listed in the file.",
                    "instantiated_by": "An instance of `FileDependencyGraph` is created by the function `build_file_dependency_graph` in `File_Dependency.py` at line 156."
                }
            },
            "error": null
        },
        "backend.HelperLLM.LLMHelper": {
            "identifier": "backend.HelperLLM.LLMHelper",
            "description": {
                "overall": "LLMHelper centralises interaction with a large language model (Gemini, OpenAI, custom SCADSLLM or Ollama) for the purpose of generating structured documentation for Python functions and classes. It loads system‑prompt files for functions and classes, determines an appropriate batch size based on the selected model, and creates specialised LLM wrappers that output Pydantic‑validated schemas. The two public generation methods (`generate_for_functions` and `generate_for_classes`) accept lists of input models, build JSON payloads, call the LLM in configurable batches, handle errors, and respect rate‑limit pauses. By exposing a single, configurable façade, the class abstracts away prompt handling, model selection, and batch orchestration for downstream workflows.",
                "init_method": {
                    "description": "The LLMHelper is instantiated with a Gemini/OpenAI API key, file paths to function‑ and class‑level system prompts, a model name (defaulting to \"gemini-2.0-flash-lite\"), and an optional base URL. During construction it reads the prompt files, configures the batch size according to the model, selects the appropriate LLM client (Gemini, OpenAI, a custom SCADSLLM endpoint, or Ollama), and creates structured‑output LLM wrappers for function and class analysis. Instance attributes such as `function_system_prompt`, `class_system_prompt`, `model_name`, `batch_size`, `function_llm`, `class_llm` and `raw_llm` are initialised for later use.",
                    "parameters": [
                        {
                            "name": "api_key",
                            "type": "str",
                            "description": "Gemini/OpenAI API key required for authenticating LLM requests."
                        },
                        {
                            "name": "function_prompt_path",
                            "type": "str",
                            "description": "Filesystem path to the system‑prompt file used when documenting functions."
                        },
                        {
                            "name": "class_prompt_path",
                            "type": "str",
                            "description": "Filesystem path to the system‑prompt file used when documenting classes."
                        },
                        {
                            "name": "model_name",
                            "type": "str",
                            "description": "Identifier of the LLM model to use (e.g., \"gemini-2.0-flash-lite\", \"gpt-4\", etc.)."
                        },
                        {
                            "name": "base_url",
                            "type": "str | None",
                            "description": "Optional custom base URL for models that require a non‑standard endpoint (e.g., SCADSLLM or Ollama)."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_configure_batch_settings",
                        "description": {
                            "overall": "This private helper sets the instance attribute `batch_size` based on the supplied `model_name`. It contains a series of explicit mappings for known Gemini, Llama, and GPT model names, assigning larger batch sizes to models that can handle higher throughput. For custom or slash‑separated model identifiers (including DeepSeek, Teuken, Llama, Qwen, etc.) it defaults to a batch size of 500. If the model name does not match any known pattern, a warning is logged and a conservative batch size of 2 is used. The method does not return a value.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "LLMHelper",
                                    "description": "The instance on which the batch size will be configured."
                                },
                                {
                                    "name": "model_name",
                                    "type": "str",
                                    "description": "The name of the LLM model for which a batch size should be determined."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods or functions.",
                                "called_by": "No other methods in the class invoke `_configure_batch_settings`."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "generate_for_functions",
                        "description": {
                            "overall": "`generate_for_functions` creates documentation for a batch of functions by sending each function's serialized input to the LLM. It first determines the effective batch size, converts each `FunctionAnalysisInput` into a JSON payload, and builds a list of conversations that pair the function system prompt with the payload. The method then iterates over the conversations in batches, invoking the structured‑output LLM (`self.function_llm`) and collecting the parsed `FunctionAnalysis` results. Errors during a batch are caught, logged, and the corresponding positions are filled with `None` to preserve ordering. Between batches it optionally sleeps to respect rate‑limit constraints before finally returning a list of optional `FunctionAnalysis` objects.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "LLMHelper",
                                    "description": "The LLMHelper instance."
                                },
                                {
                                    "name": "function_inputs",
                                    "type": "List[FunctionAnalysisInput]",
                                    "description": "A list of input models describing the functions to be documented."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "List[Optional[FunctionAnalysis]]",
                                    "description": "A list containing the LLM‑generated `FunctionAnalysis` objects or `None` for failed items, preserving the original order."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods or functions (according to the provided context).",
                                "called_by": "It is invoked by `evaluation` (evaluation.py:245) and `main_workflow` (main.py:302)."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "generate_for_classes",
                        "description": {
                            "overall": "`generate_for_classes` mirrors `generate_for_functions` but operates on class inputs. It serialises each `ClassAnalysisInput` to JSON, pairs it with the class system prompt, and sends the conversations to the LLM in batches using the `self.class_llm` wrapper. The method handles batch‑level errors by logging them and inserting `None` placeholders, respects rate limits with a configurable sleep interval, and finally returns a list of optional `ClassAnalysis` results aligned with the input order.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "LLMHelper",
                                    "description": "The LLMHelper instance."
                                },
                                {
                                    "name": "class_inputs",
                                    "type": "List[ClassAnalysisInput]",
                                    "description": "A list of input models describing the classes to be documented."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "List[Optional[ClassAnalysis]]",
                                    "description": "A list containing the LLM‑generated `ClassAnalysis` objects or `None` for failed items, preserving the original order."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods or functions (according to the provided context).",
                                "called_by": "It is invoked by `evaluation` (evaluation.py:271) and `main_workflow` (main.py:333)."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not rely on external runtime dependencies beyond the imported modules listed in the file.",
                    "instantiated_by": "LLMHelper is instantiated in three places: the `main_orchestrator` function of HelperLLM.py (line 387), the `evaluation` function of evaluation.py (line 222), and the `main_workflow` function of main.py (line 277)."
                }
            },
            "error": null
        },
        "backend.MainLLM.MainLLM": {
            "identifier": "backend.MainLLM.MainLLM",
            "description": {
                "overall": "The **MainLLM** class acts as a thin wrapper around various language‑model back‑ends (Google Gemini, OpenAI GPT, or an Ollama server). It loads a system prompt from a file, selects the appropriate LangChain chat model based on the supplied model name, and exposes two convenience methods – one for a standard request/response call and another for streaming token‑by‑token output. By abstracting the model selection and message formatting, it enables the rest of the application to interact with any supported LLM through a uniform interface. Logging is used throughout to trace initialization and runtime errors.",
                "init_method": {
                    "description": "The constructor validates the provided API key, reads a system‑prompt file, stores the chosen model name, and creates a LangChain chat model instance appropriate for the model prefix (Gemini, GPT, or Ollama). It also records the system prompt and model instance on the object for later use by the call methods.",
                    "parameters": [
                        {
                            "name": "api_key",
                            "type": "str",
                            "description": "Authentication token required by Gemini or OpenAI APIs; the constructor raises a ValueError if it is empty."
                        },
                        {
                            "name": "prompt_file_path",
                            "type": "str",
                            "description": "Filesystem path to a UTF‑8 text file containing the system prompt that will be sent to the LLM on every call."
                        },
                        {
                            "name": "model_name",
                            "type": "str",
                            "description": "Name of the language model to use (e.g., \"gemini-2.5-pro\", \"gpt-4\", or an Ollama model). Defaults to \"gemini-2.5-pro\"."
                        },
                        {
                            "name": "ollama_base_url",
                            "type": "str | None",
                            "description": "Base URL of the Ollama server; used only when the model name does not start with \"gemini-\" or \"gpt-\". If omitted, a global constant OLLAMA_BASE_URL is used."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "call_llm",
                        "description": {
                            "overall": "call_llm builds a message list consisting of the stored system prompt and the user‑provided input, then invokes the configured LangChain chat model's `invoke` method. It logs the start and successful completion of the request. If the LLM call succeeds, the method returns the textual content of the response; otherwise it logs the exception and returns `None`. This method provides a simple synchronous request/response interaction with the underlying LLM.",
                            "parameters": [
                                {
                                    "name": "user_input",
                                    "type": "str",
                                    "description": "The raw text entered by the end‑user that will be sent to the LLM as a HumanMessage."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "response_content",
                                    "type": "str | None",
                                    "description": "The textual content returned by the LLM on success; `None` if an exception occurred during the call."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "It is invoked by the function `main_workflow` in file `main.py` at line 410."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "stream_llm",
                        "description": {
                            "overall": "stream_llm prepares the same system and human messages as `call_llm` but uses the LangChain chat model's `stream` method to obtain an iterator over incremental response chunks. It yields each chunk's content as it arrives, allowing the caller to process a streaming output. If an exception occurs, the method logs the error and yields a single error message string. This method enables real‑time token streaming from the LLM.",
                            "parameters": [
                                {
                                    "name": "user_input",
                                    "type": "str",
                                    "description": "The user's query that will be sent to the LLM as a HumanMessage."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "streamed_chunks",
                                    "type": "Iterator[str]",
                                    "description": "An iterator yielding strings representing each chunk of the LLM's streamed response, or a single error message string if the call fails."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "No external functions are recorded as calling this method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not have external runtime dependencies beyond the imported modules listed in the file.",
                    "instantiated_by": "An instance of `MainLLM` is created by the function `main_workflow` in `main.py` (line 391)."
                }
            },
            "error": null
        },
        "backend.basic_info.ProjektInfoExtractor": {
            "identifier": "backend.basic_info.ProjektInfoExtractor",
            "description": {
                "overall": "ProjektInfoExtractor extracts core project information from common repository files such as README, pyproject.toml, and requirements.txt. It builds a structured dictionary containing an overview (title, description, status, key features, tech stack) and installation details (dependencies, setup guide, quick‑start guide). The class prioritises metadata from pyproject.toml, falls back to requirements.txt for dependencies, and uses the README for descriptive sections. After processing, it normalises the dependency list and overwrites the project title with a generated value based on the repository URL. This class is used by the evaluation and main workflow components to provide a concise documentation snapshot of a project.",
                "init_method": {
                    "description": "The constructor initialises a placeholder constant for missing information and creates the `info` dictionary with nested structures for project overview and installation details, each field pre‑filled with the placeholder value.",
                    "parameters": []
                },
                "methods": [
                    {
                        "identifier": "_finde_datei",
                        "description": {
                            "overall": "This private method searches a collection of file objects for the first entry whose path matches any of the supplied filename patterns, ignoring case. It iterates over each file and, for each pattern, checks whether the file's path ends with the pattern (case‑insensitive). If a match is found, the corresponding file object is returned immediately; otherwise the method returns `None`. The search stops as soon as a matching file is identified, providing an efficient way to locate README, pyproject.toml, or requirements files within a repository.",
                            "parameters": [
                                {
                                    "name": "patterns",
                                    "type": "List[str]",
                                    "description": "A list of filename patterns (e.g., \"readme.md\", \"pyproject.toml\") to match against each file's path."
                                },
                                {
                                    "name": "dateien",
                                    "type": "List[Any]",
                                    "description": "A list of file objects (typically RepoFile instances) that are examined for a matching path."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "Optional[Any]",
                                    "description": "The first file object whose path matches one of the patterns, or `None` if no match is found."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_extrahiere_sektion_aus_markdown",
                        "description": {
                            "overall": "This helper extracts the text belonging to a specific markdown section identified by a heading level 2 (\"##\"). It builds a regular‑expression pattern that matches any of the supplied keyword alternatives, then searches the markdown content for a heading that contains one of those keywords. When a match is found, the method captures everything until the next level‑2 heading or the end of the document, trims whitespace, and returns the extracted block. If no matching heading exists, the method returns `None`. The function is case‑insensitive and works with multiline content.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The full markdown text from which a section should be extracted."
                                },
                                {
                                    "name": "keywords",
                                    "type": "List[str]",
                                    "description": "A list of possible section titles (e.g., [\"Installation\", \"Setup\"]) that the method will treat as equivalent."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "Optional[str]",
                                    "description": "The extracted section text without surrounding whitespace, or `None` if the heading is not found."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_readme",
                        "description": {
                            "overall": "This private method parses the content of a README file to populate various fields of the `info` dictionary. It first extracts the top‑level title using a regular expression that matches a leading \"#\" heading. If the description field is still empty, it captures the text following the title up to the next heading. The method then reuses `_extrahiere_sektion_aus_markdown` to obtain the \"Features\", \"Tech Stack\", \"Status\", \"Installation\", and \"Quick Start\" sections, storing each in the appropriate place within `info`. All extracted values replace the placeholder constant only when they are successfully found. The method does not return a value; it mutates the instance state directly.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The raw text content of the README file."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_toml",
                        "description": {
                            "overall": "This private method parses the content of a `pyproject.toml` file to extract project metadata. It first checks whether the `tomllib` module is available; if not, it prints a warning and aborts. When available, it loads the TOML string, accesses the `project` table, and copies the `name`, `description`, and `dependencies` fields into the corresponding locations of the `info` dictionary. The dependencies from the TOML file overwrite any previously stored values because the TOML source has the highest priority. Errors during parsing are caught and reported via a warning message. The method mutates the instance state and returns nothing.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The raw text of the `pyproject.toml` file."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_requirements",
                        "description": {
                            "overall": "This private method parses a `requirements.txt` file to collect a list of dependency specifications. It only proceeds if the `dependencies` field in `info[\"installation\"]` still contains the placeholder value, ensuring that TOML‑derived dependencies are not overwritten. The method splits the file content into lines, discards empty lines and comments, strips whitespace, and builds a list of clean dependency strings. If any dependencies are found, they replace the placeholder; otherwise the placeholder remains. The method mutates the instance state and returns nothing.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The full text of the `requirements.txt` file."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "extrahiere_info",
                        "description": {
                            "overall": "This public method orchestrates the complete extraction workflow for a repository. It first locates the relevant files (README, pyproject.toml, requirements.txt) using `_finde_datei`. The files are then parsed in order of priority: TOML metadata first, followed by requirements for dependencies, and finally the README for descriptive sections. After parsing, the method normalises the dependencies list into a markdown‑style bullet list or restores the placeholder if no dependencies were found. It then derives a project title from the repository URL, overwriting any previously set title, and finally returns the populated `info` dictionary. The method therefore provides a single entry point to obtain a structured summary of a project's key information.",
                            "parameters": [
                                {
                                    "name": "dateien",
                                    "type": "List[Any]",
                                    "description": "A list of file objects (e.g., RepoFile instances) representing the repository's files."
                                },
                                {
                                    "name": "repo_url",
                                    "type": "str",
                                    "description": "The URL of the repository, used to generate a default project title."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "Dict[str, Any]",
                                    "description": "A dictionary containing the extracted project overview and installation information."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "It is called by the function 'evaluation' in file evaluation.py (line 105) and by the function 'main_workflow' in file main.py (line 154)."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not have external dependencies listed in the provided context.",
                    "instantiated_by": "It is instantiated by the function 'evaluation' in file evaluation.py (line 104) and by the function 'main_workflow' in file main.py (line 153)."
                }
            },
            "error": null
        },
        "backend.callgraph.CallGraph": {
            "identifier": "backend.callgraph.CallGraph",
            "description": {
                "overall": "The **CallGraph** class is an `ast.NodeVisitor` that walks a Python abstract syntax tree to build a directed call graph of functions and methods. It records import aliases, local definitions, and resolves callee names to fully‑qualified identifiers that include the source filename and, when applicable, the containing class. The resulting graph (`self.graph`) and edge mapping (`self.edges`) can be used to analyse call relationships across a module.",
                "init_method": {
                    "description": "Initialises a new CallGraph for a given source file. It stores the filename, prepares state for tracking the current function and class during traversal, and creates containers for local definitions, import mappings, the graph structure, and edge collections.",
                    "parameters": [
                        {
                            "name": "filename",
                            "type": "str",
                            "description": "Path or name of the Python source file whose AST will be analysed."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_recursive_call",
                        "description": {
                            "overall": "Recursively extracts the name components from an AST node that represents a function call. It walks through `ast.Call`, `ast.Name`, and `ast.Attribute` nodes, building a list of strings that represent the dotted path of the callee (e.g., `['pkg', 'mod', 'Class', 'method']`). The method returns an empty list for unsupported node types.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AST",
                                    "description": "The AST node to analyse – typically a `Call`, `Name`, or `Attribute` node."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "list[str]",
                                    "description": "A list of name components that together form the dotted identifier of the callee."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_all_callee_names",
                        "description": {
                            "overall": "Resolves a collection of callee name component lists to fully‑qualified identifiers. For each list of parts it first checks local definitions, then the import mapping, and finally falls back to constructing a name that includes the source filename and, if a class context is active, the class name. The result is a list of strings suitable for insertion into the call‑graph edges.",
                            "parameters": [
                                {
                                    "name": "callee_nodes",
                                    "type": "list[list[str]]",
                                    "description": "A list where each element is a list of name components (as produced by `_recursive_call`)."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "list[str]",
                                    "description": "Resolved fully‑qualified callee names."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_make_full_name",
                        "description": {
                            "overall": "Constructs a fully‑qualified name string for a function or method using the stored filename, an optional class name, and the base identifier. The format is `<filename>::[<class_name>::]<basename>`.",
                            "parameters": [
                                {
                                    "name": "basename",
                                    "type": "str",
                                    "description": "The simple name of the function or method."
                                },
                                {
                                    "name": "class_name",
                                    "type": "str | None",
                                    "description": "The name of the enclosing class, if any."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "str",
                                    "description": "A fully‑qualified identifier that includes the filename and optional class."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_current_caller",
                        "description": {
                            "overall": "Determines the identifier of the function currently being visited. If a function is active it returns its fully‑qualified name; otherwise it falls back to a placeholder that includes the filename or a generic `<global-scope>` marker.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "str",
                                    "description": "The identifier of the current caller context."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Visits `import` statements, populating `self.import_mapping` with alias‑to‑module mappings. For each alias it records the original module name under the alias (or the module name itself if no alias). After updating the mapping it continues the generic AST traversal.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "The AST node representing an import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Handles `from … import …` statements. It extracts the base module name, then records each imported name (or its alias) in `self.import_mapping` pointing to the module's short name. The method then proceeds with the generic visitor.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "The AST node representing a relative or absolute import-from statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "Tracks entry into a class definition by saving the previous class context, setting `self.current_class` to the new class name, visiting the class body, and finally restoring the prior context. This enables later methods to know whether they are inside a class.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "The AST node representing a class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Processes a function (or method) definition. It builds a fully‑qualified name using `_make_full_name`, registers the name in `self.local_defs` (including a class‑qualified entry if inside a class), adds the function as a node in the graph, recursively visits its body, and finally records the function in `self.function_set` before restoring the previous function context.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "The AST node representing a function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_AsyncFunctionDef",
                        "description": {
                            "overall": "Handles asynchronous function definitions by delegating to `visit_FunctionDef`, thereby applying the same registration and graph‑building logic to `async def` nodes.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AsyncFunctionDef",
                                    "description": "The AST node representing an asynchronous function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Call",
                        "description": {
                            "overall": "When a call expression is encountered, the method determines the current caller via `_current_caller`, extracts the callee name components with `_recursive_call`, resolves them to fully‑qualified identifiers using `_resolve_all_callee_names`, and records each edge in `self.edges`. After updating the edge map it continues the generic traversal.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Call",
                                    "description": "The AST node representing a function/method call."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method calls `_current_caller`, `_recursive_call`, and `_resolve_all_callee_names`.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_If",
                        "description": {
                            "overall": "Provides special handling for `if __name__ == \"__main__\":` blocks. When such a test is detected, it temporarily sets `self.current_function` to \"<main_block>\" while visiting the block, ensuring calls inside the main guard are attributed correctly. All other `if` statements are visited generically.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.If",
                                    "description": "The AST node representing an if statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method does not call any other functions.",
                                "called_by": "No other methods in the class invoke this method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The CallGraph class does not rely on any external runtime dependencies beyond the standard imports.",
                    "instantiated_by": "It is instantiated in the function `build_filtered_callgraph` within `callgraph.py` at lines 207 and 214."
                }
            },
            "error": null
        },
        "backend.getRepo.RepoFile": {
            "identifier": "backend.getRepo.RepoFile",
            "description": {
                "overall": "RepoFile models a single file inside a Git repository and provides lazy loading for the underlying Git blob, its decoded text content, and its size in bytes. The class abstracts the interaction with a commit tree so that the heavy I/O operations are performed only when the corresponding property is accessed. It also offers convenience utilities such as a word‑count analysis, a readable string representation, and a method to serialize the file metadata (and optionally its content) into a dictionary.",
                "init_method": {
                    "description": "The constructor stores the repository‑relative file path and the commit‑tree object that contains the file. It also creates placeholder attributes for the blob, content and size which will be populated lazily on first access.",
                    "parameters": [
                        {
                            "name": "file_path",
                            "type": "str",
                            "description": "Path of the file inside the repository."
                        },
                        {
                            "name": "commit_tree",
                            "type": "git.Tree",
                            "description": "The Tree object of the commit from which the file originates."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "blob",
                        "description": {
                            "overall": "The `blob` property lazily loads the Git blob that represents the file. On first access it looks up the file path in the stored commit tree and caches the resulting blob object. If the path cannot be found a `FileNotFoundError` is raised with a helpful message. Subsequent accesses return the cached blob without additional tree look‑ups.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "RepoFile",
                                    "description": "Instance reference."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "blob",
                                    "type": "git.Blob",
                                    "description": "Git blob object containing the raw file data."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "content",
                        "description": {
                            "overall": "The `content` property provides the decoded text of the file. It triggers lazy loading of the underlying blob (via the `blob` property) if it has not been loaded yet, reads the binary data stream, decodes it as UTF‑8 while ignoring errors, and caches the resulting string. Subsequent accesses return the cached text, avoiding repeated I/O and decoding. This design ensures that large files are only read when their textual content is actually needed.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "RepoFile",
                                    "description": "Instance reference."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "content",
                                    "type": "str",
                                    "description": "Decoded UTF‑8 text of the file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "size",
                        "description": {
                            "overall": "The `size` property returns the size of the file in bytes. It lazily obtains the size from the cached blob object; if the blob has not been loaded yet, it first accesses the `blob` property to fetch and cache it. The size value is then cached in the `_size` attribute for fast subsequent retrieval. This property gives callers an inexpensive way to know the file's byte length without loading its full content.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "RepoFile",
                                    "description": "Instance reference."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "size",
                                    "type": "int",
                                    "description": "File size in bytes."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "analyze_word_count",
                        "description": {
                            "overall": "`analyze_word_count` is a simple example analysis method that counts how many words are present in the file's text content. It accesses the `content` property, which ensures the file is loaded and decoded, splits the string on whitespace, and returns the length of the resulting list. The method demonstrates how additional analyses can be built on top of the lazy‑loaded content without re‑reading the file. It returns an integer representing the word count.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "RepoFile",
                                    "description": "Instance reference."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "word_count",
                                    "type": "int",
                                    "description": "Number of words in the file content."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__repr__",
                        "description": {
                            "overall": "`__repr__` provides a developer‑friendly string representation of the `RepoFile` instance. It formats the stored path into a concise `<RepoFile(path='...')>` pattern, which is useful for debugging and logging. The method does not perform any I/O or lazy loading; it simply reflects the already‑available `path` attribute. Returning a clear representation helps developers quickly identify which repository file an object corresponds to.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "RepoFile",
                                    "description": "Instance reference."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "repr_str",
                                    "type": "str",
                                    "description": "String representation of the RepoFile instance."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "to_dict",
                        "description": {
                            "overall": "`to_dict` serializes the file's metadata into a plain Python dictionary. It always includes the repository‑relative path, the base filename (derived via `os.path.basename`), the file size, and a fixed type value of \"file\". If the optional `include_content` flag is set to true, the method also adds the decoded file content under the \"content\" key, which triggers lazy loading of the content if necessary. This method enables easy conversion of a `RepoFile` into JSON‑serializable structures for API responses or persistence.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "RepoFile",
                                    "description": "Instance reference."
                                },
                                {
                                    "name": "include_content",
                                    "type": "bool",
                                    "description": "When true, the file's text content is added to the resulting dictionary."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "data",
                                    "type": "dict",
                                    "description": "Dictionary containing file metadata and optionally its content."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not have external dependencies beyond the standard library and the imported `git` module.",
                    "instantiated_by": "RepoFile objects are created in `getRepo.py` inside the `get_all_files` function (line 111)."
                }
            },
            "error": null
        },
        "backend.getRepo.GitRepository": {
            "identifier": "backend.getRepo.GitRepository",
            "description": {
                "overall": "The **GitRepository** class encapsulates the lifecycle of a remote Git repository for the backend. It clones the repository into a temporary directory, exposes the list of files as `RepoFile` objects, and can build a hierarchical file‑tree representation optionally including file contents. The class also implements the context‑manager protocol so that resources (the temporary directory) are automatically cleaned up. Overall it provides a high‑level, Pythonic interface for read‑only access to a repository’s structure and files.",
                "init_method": {
                    "description": "The constructor receives a repository URL, creates a temporary directory, and attempts to clone the repository into that directory. It stores the cloned `Repo` object, the latest commit, and the commit tree for later use, and initializes an empty list that will hold `RepoFile` objects representing the repository’s files.",
                    "parameters": [
                        {
                            "name": "repo_url",
                            "type": "str",
                            "description": "The HTTPS/SSH URL of the Git repository that should be cloned."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "get_all_files",
                        "description": {
                            "overall": "This method queries the cloned repository for all tracked file paths using `git ls-files`. It then creates a `RepoFile` instance for each path, passing the repository’s commit tree so that each `RepoFile` can later retrieve its content. The resulting `RepoFile` objects are stored in the instance attribute `self.files` and also returned to the caller. The method therefore provides a convenient way to enumerate every file in the repository as high‑level objects.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance on which the method operates."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "files",
                                    "type": "list[RepoFile]",
                                    "description": "A list of `RepoFile` objects, one for each file tracked in the repository."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method does not call any other functions or methods directly.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "close",
                        "description": {
                            "overall": "The `close` method removes the temporary directory that was created during initialization, thereby freeing the filesystem resources used by the cloned repository. It prints a message indicating the directory that is being deleted. The actual removal via `shutil.rmtree` is commented out, so the directory path is cleared and the attribute set to `None` to prevent further use. This method is intended to be called explicitly or via the context‑manager exit hook.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance on which the method operates."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method does not call any other functions or methods directly.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__enter__",
                        "description": {
                            "overall": "Implements the entry part of the context‑manager protocol. When a `GitRepository` instance is used in a `with` statement, `__enter__` simply returns the instance itself so that the caller can interact with it inside the block. No additional setup is performed because the constructor already performed cloning and initialization.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance being entered."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The same `GitRepository` instance, allowing it to be used inside the `with` block."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method does not call any other functions or methods directly.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__exit__",
                        "description": {
                            "overall": "Implements the exit part of the context‑manager protocol. It receives any exception information that may have been raised inside the `with` block, forwards the call to `close` to clean up the temporary directory, and then returns `None` so that any exception is propagated. This ensures that resources are always released, even when errors occur.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance being exited."
                                },
                                {
                                    "name": "exc_type",
                                    "type": "type | None",
                                    "description": "The exception type, if an exception was raised; otherwise `None`."
                                },
                                {
                                    "name": "exc_val",
                                    "type": "BaseException | None",
                                    "description": "The exception instance, if an exception was raised; otherwise `None`."
                                },
                                {
                                    "name": "exc_tb",
                                    "type": "TracebackType | None",
                                    "description": "The traceback object, if an exception was raised; otherwise `None`."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "The method calls `self.close()` to clean up resources.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "get_file_tree",
                        "description": {
                            "overall": "Generates a nested dictionary that represents the directory tree of the repository. If the internal `self.files` list is empty, it first populates it by calling `get_all_files`. It then iterates over each `RepoFile`, splits its path into components, and builds a hierarchical structure of directories and files. Each file node is created by calling `RepoFile.to_dict`, optionally including the file content based on the `include_content` flag. The final tree dictionary has a root node named \"root\" and mirrors the repository’s folder layout.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance on which the method operates."
                                },
                                {
                                    "name": "include_content",
                                    "type": "bool",
                                    "description": "If `True`, the file nodes will contain the file content; otherwise only metadata is included."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "tree",
                                    "type": "dict",
                                    "description": "A nested dictionary representing the repository’s directory tree, with directories and files as nodes."
                                }
                            ],
                            "usage_context": {
                                "calls": "The method calls `self.get_all_files()` if the file list is empty, and calls `RepoFile.to_dict` for each file.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not have external dependencies beyond the standard library and the imported `git` package.",
                    "instantiated_by": "Instances of this class are created in `evaluation.py` (function `evaluation` at line 86) and in `main.py` (function `main_workflow` at line 134)."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.ProjectAnalyzer": {
            "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
            "description": {
                "overall": "ProjectAnalyzer is a utility class that inspects a Python project's source tree, discovers all Python files, parses their abstract syntax trees, collects definitions of functions, methods, and classes, resolves call relationships between those definitions, and finally produces a structured, formatted representation of the project's call graph. It encapsulates the entire workflow of file discovery, AST parsing, definition indexing, call resolution, and result formatting, making it reusable for static analysis of any Python code base.",
                "init_method": {
                    "description": "The constructor stores the absolute path of the project root and initializes internal data structures used during analysis: a dictionary for definitions, a call‑graph mapping, a cache for parsed ASTs, and a set of directory names to ignore while walking the file system.",
                    "parameters": [
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "Path to the root directory of the Python project that should be analyzed."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "analyze",
                        "description": {
                            "overall": "The `analyze` method coordinates the full analysis pipeline. It first discovers all Python files under the project root, then iterates over those files to collect definitions of functions, classes, and methods. After definitions are gathered, it makes a second pass to resolve call relationships between the collected definitions. Finally, it clears the cached ASTs and returns the formatted analysis results.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "list",
                                    "description": "A list of dictionaries, each describing a definition and the functions that call it."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods directly.",
                                "called_by": "The `analyze` method is invoked by the `evaluation` function in `evaluation.py` (line 120) and by the `main_workflow` function in `main.py` (line 171)."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_find_py_files",
                        "description": {
                            "overall": "Recursively walks the project root directory, skipping any directories listed in `ignore_dirs`, and collects the absolute paths of all files ending with the `.py` extension. The resulting list is returned for further processing.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "list",
                                    "description": "A list of absolute file paths (strings) for all discovered Python source files."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_collect_definitions",
                        "description": {
                            "overall": "Opens a given Python file, reads its source, parses it into an AST, and stores the tree in the `file_asts` cache. It then derives the module path and walks the AST to record definitions of functions, methods, and classes, populating the `definitions` dictionary with metadata such as file location, line number, and type. Errors during file reading or parsing are logged, and the AST cache entry is set to `None` for that file.",
                            "parameters": [
                                {
                                    "name": "filepath",
                                    "type": "str",
                                    "description": "Absolute path to the Python file whose definitions should be collected."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods directly.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_get_parent",
                        "description": {
                            "overall": "Searches the AST of a module to locate the immediate parent node of a given node. It iterates over all nodes and their children, returning the parent when the child matches the target node, or `None` if no parent is found.",
                            "parameters": [
                                {
                                    "name": "tree",
                                    "type": "ast.AST",
                                    "description": "The root AST node of the module being inspected."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.AST",
                                    "description": "The AST node whose parent is to be identified."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "ast.AST | None",
                                    "description": "The parent AST node if found, otherwise `None`."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_calls",
                        "description": {
                            "overall": "Retrieves the cached AST for a given file and, if present, uses a `CallResolverVisitor` to walk the tree and collect call relationships. The visitor returns a mapping of callee pathnames to caller information, which is then merged into the class's `call_graph` structure. Errors during resolution are logged.",
                            "parameters": [
                                {
                                    "name": "filepath",
                                    "type": "str",
                                    "description": "Absolute path to the Python file whose call relationships should be resolved."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods directly.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "get_formatted_results",
                        "description": {
                            "overall": "Iterates over the populated `call_graph` and, for each callee that has a recorded definition, builds a dictionary containing identifier, mode, origin file, origin line, and a sorted list of unique callers. These dictionaries are collected into a list, which is returned as the final formatted analysis output.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "list",
                                    "description": "A list of dictionaries, each representing a definition and its callers."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions or methods.",
                                "called_by": "No other functions or methods are recorded as calling this method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not rely on external dependencies beyond the standard library imports (`ast`, `os`, `logging`, and `collections.defaultdict`).",
                    "instantiated_by": "Instances of `ProjectAnalyzer` are created in the `evaluation` function of `evaluation.py` (line 119) and in the `main_workflow` function of `main.py` (line 170)."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.CallResolverVisitor": {
            "identifier": "backend.relationship_analyzer.CallResolverVisitor",
            "description": {
                "overall": "The **CallResolverVisitor** walks a Python abstract syntax tree (AST) of a module and records every call to a known definition. It builds a mapping from each callee’s fully‑qualified name to a list of caller information (file, line, caller name and type). To resolve names it maintains a scope of imported symbols and a registry of instance types created by class instantiations. The visitor is employed by the relationship analyzer to construct a call‑graph across the project.",
                "init_method": {
                    "description": "The constructor stores the path of the file being analysed, computes its module path, and initialises the internal state used during traversal, such as import scope, instance type mapping, the current caller context and the calls dictionary.",
                    "parameters": [
                        {
                            "name": "filepath",
                            "type": "str",
                            "description": "Absolute or relative path to the source file whose AST is being visited."
                        },
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "Root directory of the project; used together with *filepath* to compute the module path."
                        },
                        {
                            "name": "definitions",
                            "type": "set[str] | dict",
                            "description": "A collection of fully‑qualified names that are considered valid call targets within the project."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "When the visitor encounters a class definition node, it records the class name as the current context, recursively visits the class body, and finally restores the previous class context. This allows the visitor to distinguish method calls from top‑level function calls. The method does not produce a return value; its effect is limited to state management and traversal.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "The AST node representing the class definition being visited."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other function in the provided context calls this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Upon encountering a function definition, the visitor updates the current caller name to the function’s name, traverses the function body, and then restores the previous caller name. This tracking enables the visitor to label calls as originating from a specific function or method. The method returns nothing and solely manipulates traversal state.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "The AST node representing the function definition being visited."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "No other function in the provided context calls this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Call",
                        "description": {
                            "overall": "For each call expression the visitor attempts to resolve the fully‑qualified name of the callee. If the callee is present in the supplied *definitions*, it records caller information—including file name, line number, caller name and caller type (module, function, or method)—into the *calls* dictionary under the callee’s name. The method then continues traversing any nested nodes. It does not return a value.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Call",
                                    "description": "The AST node representing the call expression being visited."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the helper method `_resolve_call_qname` and the generic visitor `generic_visit`.",
                                "called_by": "No other function in the provided context calls this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "When an import statement is visited, the method adds each imported name to the visitor’s *scope* mapping, associating the alias (or original name) with its fully‑qualified module path. After updating the scope it continues traversal of any child nodes. The method does not produce a return value.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "The AST node representing the import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the generic visitor `generic_visit`.",
                                "called_by": "No other function in the provided context calls this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "For a relative or absolute `from … import …` statement, the method resolves the full module path, records each imported symbol in the *scope* dictionary, and then proceeds with generic traversal. It handles relative imports by adjusting the current module path according to the import level. No value is returned.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "The AST node representing the `import from` statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the generic visitor `generic_visit`.",
                                "called_by": "No other function in the provided context calls this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Assign",
                        "description": {
                            "overall": "When an assignment is visited, the method checks whether the right‑hand side is a call to a class that is known in the current *scope* and also present in *definitions*. If so, it records the variable name in *instance_types* mapping it to the qualified class name, enabling later resolution of method calls on that instance. The method then continues generic traversal and returns nothing.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Assign",
                                    "description": "The AST node representing the assignment statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the generic visitor `generic_visit`.",
                                "called_by": "No other function in the provided context calls this method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_call_qname",
                        "description": {
                            "overall": "This helper resolves the fully‑qualified name of a function or method call node. It handles simple name references by looking them up in the *scope* or by constructing a module‑local name, and it resolves attribute accesses on known instances or imported modules. If resolution fails, it returns *None*. The method returns a string representing the qualified name or *None*.",
                            "parameters": [
                                {
                                    "name": "func_node",
                                    "type": "ast.AST",
                                    "description": "The AST node representing the function part of a call expression (either `ast.Name` or `ast.Attribute`)."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "str | None",
                                    "description": "The fully‑qualified name of the called function/method if it can be resolved, otherwise `None`."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "It is called by the `visit_Call` method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class does not have external dependencies listed.",
                    "instantiated_by": "The class is instantiated in the file \"relationship_analyzer.py\" within the function \"_resolve_calls\" (mode: method) at line 92."
                }
            },
            "error": null
        },
        "schemas.types.ParameterDescription": {
            "identifier": "schemas.types.ParameterDescription",
            "description": {
                "overall": "ParameterDescription is a lightweight Pydantic model that encapsulates metadata for a single function parameter. It stores the parameter's name, its type annotation as a string, and a human‑readable description. By inheriting from BaseModel it gains validation, serialization and a generated __init__ that accepts these fields as keyword arguments.",
                "init_method": {
                    "description": "The class does not define an explicit __init__; it relies on the __init__ generated by Pydantic's BaseModel, which accepts the model fields as keyword arguments and performs type validation.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not have external dependencies beyond the imported pydantic.BaseModel.",
                    "instantiated_by": "No information is provided about where ParameterDescription is instantiated."
                }
            },
            "error": null
        },
        "schemas.types.ReturnDescription": {
            "identifier": "schemas.types.ReturnDescription",
            "description": {
                "overall": "ReturnDescription is a lightweight Pydantic model that encapsulates metadata about a function's return value. It stores the return value's name, its type as a string, and a human‑readable description. The class provides automatic validation and serialization via the BaseModel parent, making it convenient for documentation or code‑generation pipelines.",
                "init_method": {
                    "description": "The class inherits Pydantic's BaseModel, which automatically generates an __init__ method that accepts the three declared fields (name, type, description) as keyword arguments and validates them.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "The class does not have external dependencies beyond the imported modules listed in the file.",
                    "instantiated_by": "The class is not instantiated anywhere in the provided context."
                }
            },
            "error": null
        },
        "schemas.types.UsageContext": {
            "identifier": "schemas.types.UsageContext",
            "description": {
                "overall": "The **UsageContext** class is a lightweight Pydantic data model that captures the calling context of a function. It stores two string attributes: `calls`, which records the name(s) of functions that are invoked, and `called_by`, which records the name(s) of functions that invoke the current function. By inheriting from `BaseModel`, it gains validation, serialization, and convenient construction capabilities.",
                "init_method": {
                    "description": "Since the class does not define an explicit `__init__` method, Pydantic's generated initializer is used. The initializer accepts the two fields `calls` and `called_by` as keyword arguments, validates them as strings, and assigns them to the instance.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not have external dependencies.",
                    "instantiated_by": "No known locations instantiate this class."
                }
            },
            "error": null
        },
        "schemas.types.FunctionDescription": {
            "identifier": "schemas.types.FunctionDescription",
            "description": {
                "overall": "FunctionDescription is a Pydantic model that encapsulates a comprehensive analysis of a function, including a textual overall description, a list of parameter descriptions, a list of return value descriptions, and contextual usage information. It serves as a structured container for documenting function signatures and behavior within the system.",
                "init_method": {
                    "description": "The class relies on Pydantic's BaseModel for automatic attribute handling; no custom __init__ is defined, so instance creation follows the default BaseModel initialization.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "FunctionDescription does not depend on any external modules beyond the imports provided.",
                    "instantiated_by": "There are no recorded locations where FunctionDescription is instantiated."
                }
            },
            "error": null
        },
        "FunctionAnalysis": {
            "identifier": "FunctionAnalysis",
            "description": {
                "overall": "The **FunctionAnalysis** class is a Pydantic `BaseModel` that serves as the top‑level schema for representing the complete analysis of a function. It stores the function's unique identifier, a structured `FunctionDescription` object that holds detailed information about the function, and an optional error message if the analysis encounters a problem. By using Pydantic, the class provides validation, serialization, and clear typing for downstream components.",
                "init_method": {
                    "description": "Initialization is handled by the inherited `BaseModel.__init__`, which accepts the defined fields as keyword arguments and validates their types.",
                    "parameters": [
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string that uniquely identifies the function being analyzed."
                        },
                        {
                            "name": "description",
                            "type": "FunctionDescription",
                            "description": "A nested model containing the detailed description of the function (parameters, returns, usage, etc.)."
                        },
                        {
                            "name": "error",
                            "type": "Optional[str]",
                            "description": "An optional error message describing why analysis might have failed; defaults to `None`."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class relies only on standard typing utilities and the `pydantic` library, as reflected in the import list.",
                    "instantiated_by": "No specific instantiation locations are supplied in the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ConstructorDescription": {
            "identifier": "schemas.types.ConstructorDescription",
            "description": {
                "overall": "ConstructorDescription is a Pydantic model that captures a textual description of a class's __init__ method together with a list of ParameterDescription objects describing each constructor parameter. It provides a structured representation that can be used for documentation or analysis of class constructors.",
                "init_method": {
                    "description": "The class does not define a custom __init__ method; it relies on the BaseModel‑generated initializer which accepts the fields defined in the model (description and parameters).",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond the imports listed (typing and pydantic).",
                    "instantiated_by": "No locations where this class is instantiated are provided in the context."
                }
            },
            "error": null
        },
        "schemas.types.ClassContext": {
            "identifier": "schemas.types.ClassContext",
            "description": {
                "overall": "ClassContext is a Pydantic model that encapsulates metadata about a class's external dependencies and the locations where it is instantiated. It defines two string fields, `dependencies` and `instantiated_by`, to store this information. The model can be used throughout the codebase to pass around structured context data about classes, benefiting from BaseModel's validation and serialization features.",
                "init_method": {
                    "description": "The class inherits from `pydantic.BaseModel`, which automatically generates an `__init__` method that accepts the defined fields. Instances are created by providing values for the `dependencies` and `instantiated_by` attributes.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "The class does not declare any external dependencies.",
                    "instantiated_by": "No specific locations are recorded where this class is instantiated."
                }
            },
            "error": null
        },
        "schemas.types.ClassDescription": {
            "identifier": "schemas.types.ClassDescription",
            "description": {
                "overall": "ClassDescription is a Pydantic BaseModel that aggregates the detailed analysis of another class, including a high‑level purpose statement, a description of its constructor, analyses of each of its methods, and contextual information about dependencies and instantiation sites.",
                "init_method": {
                    "description": "The class does not define a custom __init__ method and therefore uses the default BaseModel initializer provided by Pydantic.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "No external dependencies are listed for this model in the provided context.",
                    "instantiated_by": "There are no recorded locations where this model is instantiated."
                }
            },
            "error": null
        },
        "ClassAnalysis": {
            "identifier": "ClassAnalysis",
            "description": {
                "overall": "ClassAnalysis is a Pydantic BaseModel that defines the schema for representing a full analysis of a Python class. It includes the class's unique identifier, a detailed description object, and an optional error message indicating analysis failures. This model serves as the top‑level container for all class‑analysis information.",
                "init_method": {
                    "description": "The class does not define its own __init__; it relies on the default BaseModel initializer which accepts the defined fields.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "",
                    "instantiated_by": ""
                }
            },
            "error": null
        },
        "schemas.types.CallInfo": {
            "identifier": "schemas.types.CallInfo",
            "description": {
                "overall": "CallInfo is a Pydantic model that encapsulates information about a specific call site discovered by the relationship analyzer. It stores the source file, the calling function name, the mode indicating whether the call originates from a method, function, or module, and the line number of the call. This structured representation is used in the `called_by` and `instantiated_by` collections to trace code relationships. By inheriting from `BaseModel`, it benefits from automatic validation, serialization, and convenient initialization of its fields.",
                "init_method": {
                    "description": "CallInfo relies on Pydantic's `BaseModel` for initialization, automatically assigning the defined fields from provided keyword arguments.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond the imported typing and pydantic utilities.",
                    "instantiated_by": "There are currently no recorded locations where `CallInfo` is instantiated."
                }
            },
            "error": null
        },
        "schemas.types.FunctionContextInput": {
            "identifier": "schemas.types.FunctionContextInput",
            "description": {
                "overall": "FunctionContextInput is a Pydantic model that provides a structured representation of a function's analysis context. It records the list of function names that the analyzed function calls (`calls`) and detailed information about callers (`called_by`) using the `CallInfo` type. This model is used throughout the system to pass function‑level call relationship data between components.",
                "init_method": {
                    "description": "The class relies on Pydantic's autogenerated `__init__`, which accepts the fields defined on the model (`calls` and `called_by`). No custom initialization logic is present.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not have external runtime dependencies beyond the imported typing and Pydantic modules.",
                    "instantiated_by": "FunctionContextInput is instantiated in `evaluation.py` inside the `evaluation` function (line 162) and in `main.py` inside the `main_workflow` function (line 216)."
                }
            },
            "error": null
        },
        "schemas.types.FunctionAnalysisInput": {
            "identifier": "schemas.types.FunctionAnalysisInput",
            "description": {
                "overall": "FunctionAnalysisInput is a Pydantic model that defines the required input for generating a FunctionAnalysis object. It captures the fixed mode value (\"function_analysis\"), the identifier of the target function, the raw source code, a list of import statements, and a context object describing function‑level information. By inheriting from BaseModel it gains automatic validation, serialization, and default handling of these fields. This model is used throughout the evaluation workflow to pass structured information to analysis components.",
                "init_method": {
                    "description": "The class inherits from pydantic.BaseModel and uses the default BaseModel initializer; no custom __init__ method is defined.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "The class depends on standard typing constructs and pydantic, as reflected in the provided imports list.",
                    "instantiated_by": "FunctionAnalysisInput is instantiated in evaluation.py within the evaluation function (line 167) and in main.py inside the main_workflow function (line 221)."
                }
            },
            "error": null
        },
        "schemas.types.MethodContextInput": {
            "identifier": "schemas.types.MethodContextInput",
            "description": {
                "overall": "MethodContextInput is a Pydantic model that encapsulates structured information about a class's methods. It stores the method identifier, a list of calls made by the method, information about callers via `CallInfo` objects, the argument names, and an optional docstring. This model serves as a lightweight container for method‑level metadata used throughout the evaluation workflow. By leveraging Pydantic it gains automatic validation, parsing, and easy serialization of this context data.",
                "init_method": {
                    "description": "The class relies on Pydantic's autogenerated `__init__` which accepts the defined fields as keyword arguments and performs validation.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "The class does not have external dependencies beyond the imported `typing` and `pydantic` modules.",
                    "instantiated_by": "It is instantiated in `evaluation.py` within the `evaluation` function (line 187) and in `main.py` within the `main_workflow` function (line 241)."
                }
            },
            "error": null
        },
        "schemas.types.ClassContextInput": {
            "identifier": "schemas.types.ClassContextInput",
            "description": {
                "overall": "ClassContextInput is a Pydantic model that encapsulates the structured context required for analyzing another class. It stores a list of external dependencies, information about where the class is instantiated, and per‑method context details. The model provides a clear, typed container that downstream analysis components can consume.",
                "init_method": {
                    "description": "The class inherits from Pydantic's BaseModel and does not define a custom __init__ method. Instance attributes are automatically created from the declared fields when the model is instantiated.",
                    "parameters": []
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not declare any external dependencies.",
                    "instantiated_by": "ClassContextInput is instantiated by three locations: the function `main_orchestrator` in **HelperLLM.py** at line 369, the function `evaluation` in **evaluation.py** at line 199, and the function `main_workflow` in **main.py** at line 253."
                }
            },
            "error": null
        },
        "schemas.types.ClassAnalysisInput": {
            "identifier": "schemas.types.ClassAnalysisInput",
            "description": {
                "overall": "ClassAnalysisInput is a Pydantic model that defines the required input schema for generating a ClassAnalysis object. It enforces that the caller supplies a mode flag set to the literal string \"class_analysis\", an identifier string naming the target class, the raw source code of that class, a list of import statements, and a context object describing dependencies and instantiation sites. By inheriting from BaseModel, it gains validation, serialization, and convenient construction semantics. The model serves as a strict contract between the helper LLM that analyses classes and the downstream components that consume the analysis results. Its fields together capture everything needed to perform a full class‑level static analysis.",
                "init_method": {
                    "description": "The class is instantiated with the fields mode, identifier, source_code, imports, and context, as defined by the Pydantic BaseModel. No custom __init__ is provided; the BaseModel generated initializer assigns each argument to the corresponding attribute after validation.",
                    "parameters": [
                        {
                            "name": "mode",
                            "type": "Literal[\"class_analysis\"]",
                            "description": "A literal flag indicating that the input is for a class analysis operation."
                        },
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "The name of the class that will be analysed."
                        },
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "The raw source code of the target class, including its definition and body."
                        },
                        {
                            "name": "imports",
                            "type": "List[str]",
                            "description": "A list of import statements extracted from the file containing the target class."
                        },
                        {
                            "name": "context",
                            "type": "ClassContextInput",
                            "description": "An object that provides additional context such as dependencies, instantiation sites, and method‑level call information."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "The class does not depend on external modules beyond the imports listed in the input.",
                    "instantiated_by": "ClassAnalysisInput is instantiated in three locations: HelperLLM.py within the function main_orchestrator (line 338), evaluation.py within the function evaluation (line 205), and main.py within the function main_workflow (line 259)."
                }
            },
            "error": null
        }
    }
}