{
    "functions": {
        "backend.AST_Schema.path_to_module": {
            "identifier": "backend.AST_Schema.path_to_module",
            "description": {
                "overall": "The function 'path_to_module' converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not within the project root by falling back to the basename of the file. If the resulting path ends with '.__init__', it removes the trailing part to correctly represent the package structure.",
                "parameters": [
                    {
                        "name": "filepath",
                        "type": "str",
                        "description": "The absolute or relative path to a Python file."
                    },
                    {
                        "name": "project_root",
                        "type": "str",
                        "description": "The root directory of the project used to compute the relative path."
                    }
                ],
                "returns": [
                    {
                        "name": "module_path",
                        "type": "str",
                        "description": "A dot-separated module path derived from the given file path."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the '__init__' method in 'AST_Schema.py' at line 31."
                }
            },
            "error": null
        },
        "backend.File_Dependency.build_file_dependency_graph": {
            "identifier": "backend.File_Dependency.build_file_dependency_graph",
            "description": {
                "overall": "This function constructs a directed graph representing file dependencies within a repository. It takes an AST representation of a file and uses a custom visitor to extract import dependencies. The resulting graph captures relationships between files where one file imports another. The function initializes an empty directed graph, processes the AST using a visitor pattern, and populates the graph with nodes and edges based on the import relationships found.",
                "parameters": [
                    {
                        "name": "filename",
                        "type": "str",
                        "description": "The name of the file being analyzed for dependencies."
                    },
                    {
                        "name": "tree",
                        "type": "AST",
                        "description": "The abstract syntax tree representation of the file being analyzed."
                    },
                    {
                        "name": "repo_root",
                        "type": "str",
                        "description": "The root directory path of the repository being analyzed."
                    }
                ],
                "returns": [
                    {
                        "name": "graph",
                        "type": "nx.DiGraph",
                        "description": "A NetworkX directed graph representing file dependencies, where nodes are files and edges represent import relationships."
                    }
                ],
                "usage_context": {
                    "calls": "The function utilizes a FileDependencyGraph visitor to traverse the AST and extract import dependencies.",
                    "called_by": "This function is called by the build_repository_graph function in File_Dependency.py at line 177."
                }
            },
            "error": null
        },
        "backend.File_Dependency.build_repository_graph": {
            "identifier": "backend.File_Dependency.build_repository_graph",
            "description": {
                "overall": "This function constructs a dependency graph for all Python files within a given Git repository. It iterates through each Python file, parses its content into an abstract syntax tree (AST), and builds a file-level dependency graph. These individual graphs are then merged into a single global directed graph representing dependencies across the entire repository. The function ensures that only Python files are processed and properly handles node and edge additions to the global graph.",
                "parameters": [
                    {
                        "name": "repository",
                        "type": "GitRepository",
                        "description": "The Git repository object containing the files to analyze for dependencies."
                    }
                ],
                "returns": [
                    {
                        "name": "global_graph",
                        "type": "nx.DiGraph",
                        "description": "A NetworkX directed graph representing the dependency relationships between Python files in the repository."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not directly call any other functions defined within the provided source code.",
                    "called_by": "This function is called by the module 'backend.File_Dependency' at line 233 in 'File_Dependency.py'."
                }
            },
            "error": null
        },
        "backend.File_Dependency.get_all_temp_files": {
            "identifier": "backend.File_Dependency.get_all_temp_files",
            "description": {
                "overall": "This function retrieves all Python files (.py) from a specified directory and its subdirectories, returning them as relative paths from the given directory. It resolves the input directory to an absolute path to ensure consistent behavior regardless of the working directory. The function uses pathlib for path manipulation and globbing to find all matching files.",
                "parameters": [
                    {
                        "name": "directory",
                        "type": "str",
                        "description": "The root directory path from which to search for Python files."
                    }
                ],
                "returns": [
                    {
                        "name": "all_files",
                        "type": "list[pathlib.Path]",
                        "description": "A list of Path objects representing all Python files found in the directory and its subdirectories, relative to the specified root directory."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by _resolve_module_name in File_Dependency.py at line 43."
                }
            },
            "error": null
        },
        "backend.File_Dependency.nx_to_mermaid_with_folders": {
            "identifier": "backend.File_Dependency.nx_to_mermaid_with_folders",
            "description": {
                "overall": "This function converts a NetworkX directed graph representing file dependencies into a Mermaid.js graph visualization format. It organizes nodes into folders and root-level files, creating subgraphs for each folder and rendering edges between nodes. The function processes nodes by splitting their paths to determine folder structures and maps them accordingly.",
                "parameters": [
                    {
                        "name": "G",
                        "type": "nx.DiGraph",
                        "description": "A NetworkX directed graph where nodes represent file paths and edges represent dependencies between files."
                    }
                ],
                "returns": [
                    {
                        "name": "mermaid_output",
                        "type": "str",
                        "description": "A string containing the Mermaid.js formatted graph representation with subgraphs for folders and connections between nodes."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses collections.defaultdict for grouping files by folder and performs string operations like split and replace on node identifiers.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "backend.HelperLLM.main_orchestrator": {
            "identifier": "backend.HelperLLM.main_orchestrator",
            "description": {
                "overall": "This function serves as a dummy data and processing loop for testing the LLMHelper class. It defines pre-computed analyses for example functions like 'add_item', 'check_stock', and 'generate_report'. These analyses are then processed by an LLMHelper instance to generate documentation for these functions. The function simulates how the Helper LLM would integrate with a larger system by preparing inputs and handling outputs.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it prepares data for external processing.",
                    "called_by": "Called by backend.HelperLLM (line 419 in HelperLLM.py)."
                }
            },
            "error": null
        },
        "backend.callgraph.make_safe_dot": {
            "identifier": "backend.callgraph.make_safe_dot",
            "description": {
                "overall": "The function 'make_safe_dot' takes a NetworkX directed graph and a file path as inputs. It creates a safe version of the graph by relabeling all nodes with unique identifiers prefixed by 'n', ensuring node names are safe for use in DOT format. The original node labels are preserved in the 'label' attribute of the new nodes. Finally, it writes the modified graph to a file in DOT format.",
                "parameters": [
                    {
                        "name": "graph",
                        "type": "nx.DiGraph",
                        "description": "A NetworkX directed graph to be processed and saved."
                    },
                    {
                        "name": "out_path",
                        "type": "str",
                        "description": "The file path where the DOT representation of the graph will be written."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the function 'backend.callgraph' in the file 'callgraph.py' at line 252."
                }
            },
            "error": null
        },
        "backend.callgraph.build_filtered_callgraph": {
            "identifier": "backend.callgraph.build_filtered_callgraph",
            "description": {
                "overall": "Die Funktion erstellt einen globalen Call-Graphen basierend auf allen Python-Dateien eines Git-Repositories und filtert diesen anschließend auf Funktionen, die vom Benutzer selbst geschrieben wurden. Sie durchläuft alle Dateien, parst deren Inhalt mit dem Abstract Syntax Tree (AST), extrahiert Funktionsaufrufe und baut einen gerichteten Graphen auf, wobei nur Kanten zwischen eigenen Funktionen erhalten bleiben.",
                "parameters": [
                    {
                        "name": "repo",
                        "type": "GitRepository",
                        "description": "Ein Objekt, das Informationen über ein Git-Repository enthält, insbesondere Zugriff auf alle enthaltenen Dateien."
                    }
                ],
                "returns": [
                    {
                        "name": "global_graph",
                        "type": "nx.DiGraph",
                        "description": "Ein gerichteter Graph, der die Aufrufbeziehungen zwischen Funktionen darstellt, gefiltert auf selbst geschriebene Funktionen."
                    }
                ],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes direkt auf.",
                    "called_by": "Diese Funktion wird von 'analyze_repository' in 'AST_Schema.py' und von 'backend.callgraph' in 'callgraph.py' aufgerufen."
                }
            },
            "error": null
        },
        "backend.main.create_savings_chart": {
            "identifier": "backend.main.create_savings_chart",
            "description": {
                "overall": "Die Funktion erstellt ein Balkendiagramm zur Darstellung des Token-Vergleichs zwischen JSON und TOON Format. Sie verwendet matplotlib zur Erstellung des Diagramms und speichert das Ergebnis in einer Datei. Das Diagramm zeigt die Anzahl der Token für beide Formate sowie den Prozentsatz der Einsparung. Die Funktion nimmt Parameter für die Token-Anzahl, den Einsparungsprozentsatz und den Ausgabepfad entgegen.",
                "parameters": [
                    {
                        "name": "json_tokens",
                        "type": "int",
                        "description": "Die Anzahl der Token im JSON-Format."
                    },
                    {
                        "name": "toon_tokens",
                        "type": "int",
                        "description": "Die Anzahl der Token im TOON-Format."
                    },
                    {
                        "name": "savings_percent",
                        "type": "float",
                        "description": "Der Prozentsatz der Einsparung zwischen den beiden Formaten."
                    },
                    {
                        "name": "output_path",
                        "type": "str",
                        "description": "Der Pfad, unter dem das generierte Diagramm gespeichert wird."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes auf.",
                    "called_by": "Die Funktion wird von der Funktion 'main_workflow' in der Datei 'main.py' aufgerufen."
                }
            },
            "error": null
        },
        "backend.main.calculate_net_time": {
            "identifier": "backend.main.calculate_net_time",
            "description": {
                "overall": "Die Funktion berechnet die reine Bearbeitungszeit eines Prozesses, indem sie die Gesamtdauer minus die durch Rate-Limits verursachten Schlafzeiten subtrahiert. Sie berücksichtigt speziell Modellnamen, die mit 'gemini-' beginnen, um diese Zeiten zu berücksichtigen. Bei Modellen, die nicht mit 'gemini-' beginnen, wird die Gesamtdauer unverändert zurückgegeben. Wenn keine Elemente verarbeitet werden, wird null zurückgegeben.",
                "parameters": [
                    {
                        "name": "start_time",
                        "type": "float",
                        "description": "Der Startzeitpunkt des Prozesses."
                    },
                    {
                        "name": "end_time",
                        "type": "float",
                        "description": "Der Endzeitpunkt des Prozesses."
                    },
                    {
                        "name": "total_items",
                        "type": "int",
                        "description": "Die Gesamtzahl der zu verarbeitenden Elemente."
                    },
                    {
                        "name": "batch_size",
                        "type": "int",
                        "description": "Die Anzahl der Elemente pro Batch."
                    },
                    {
                        "name": "model_name",
                        "type": "str",
                        "description": "Der Name des verwendeten Modells, welcher bestimmt, ob Rate-Limit-Schlafzeiten berücksichtigt werden."
                    }
                ],
                "returns": [
                    {
                        "name": "net_time",
                        "type": "float",
                        "description": "Die berechnete reine Bearbeitungszeit nach Subtraktion der Schlafzeiten."
                    }
                ],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes auf.",
                    "called_by": "Die Funktion wird von der Funktion 'evaluation' in der Datei 'evaluation.py' in zwei verschiedenen Zeilen und von der Funktion 'main_workflow' in der Datei 'main.py' aufgerufen."
                }
            },
            "error": null
        },
        "backend.main.main_workflow": {
            "identifier": "backend.main.main_workflow",
            "description": {
                "overall": "The `main_workflow` function orchestrates a comprehensive code analysis pipeline for a given GitHub repository. It begins by validating and extracting API keys and model configurations, then clones the repository and retrieves all files. It proceeds to extract basic project information, construct a file tree, and perform relationship analysis on the codebase. The function generates an Abstract Syntax Tree (AST) schema and enriches it with relationship data. Subsequently, it prepares inputs for a Helper LLM to analyze functions and classes, calling the LLM to generate documentation for each. Afterward, it prepares a final input for a Main LLM to produce a comprehensive report based on the collected data. Finally, it saves the report and associated statistics.",
                "parameters": [
                    {
                        "name": "input",
                        "type": "Any",
                        "description": "The input provided by the user, typically a string containing a GitHub repository URL."
                    },
                    {
                        "name": "api_keys",
                        "type": "dict",
                        "description": "A dictionary containing API keys for various services such as Gemini, OpenAI, and SCADsLLM."
                    },
                    {
                        "name": "model_names",
                        "type": "dict",
                        "description": "A dictionary specifying the names of models to be used for helper and main LLM tasks."
                    },
                    {
                        "name": "status_callback",
                        "type": "Callable[[str], None]",
                        "description": "An optional callback function to report progress updates."
                    }
                ],
                "returns": [
                    {
                        "name": "report",
                        "type": "str",
                        "description": "The final markdown report generated by the Main LLM."
                    },
                    {
                        "name": "metrics",
                        "type": "dict",
                        "description": "A dictionary containing timing metrics for the helper and main LLM processes."
                    }
                ],
                "usage_context": {
                    "calls": "This function internally calls several components including GitRepository for cloning repositories, ProjektInfoExtractor for extracting basic project information, ProjectAnalyzer for analyzing relationships, ASTAnalyzer for creating AST schemas, LLMHelper for function and class analysis, and MainLLM for generating the final report.",
                    "called_by": "This function is called by the frontend module in 'Frontend.py' at line 489 and by the backend.main module in 'main.py' at line 469."
                }
            },
            "error": null
        },
        "backend.main.update_status": {
            "identifier": "backend.main.update_status",
            "description": {
                "overall": "The function 'update_status' takes a message as input and logs it using the Python logging module. It also optionally invokes a callback function named 'status_callback' if it is defined. This function serves as a centralized mechanism for reporting status updates throughout the application.",
                "parameters": [
                    {
                        "name": "msg",
                        "type": "Any",
                        "description": "The message to be logged and optionally passed to the status callback."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function internally uses the 'logging.info' method to log messages.",
                    "called_by": "This function is called by the 'main_workflow' function multiple times across different lines in main.py."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.path_to_module": {
            "identifier": "backend.relationship_analyzer.path_to_module",
            "description": {
                "overall": "The function converts a file path into a Python module path by computing the relative path from the project root, removing the '.py' extension if present, and replacing directory separators with dots. It handles cases where the filepath is not under the project root by falling back to the basename of the file. If the resulting path ends with '__init__', it removes the trailing part to correctly represent the package structure.",
                "parameters": [
                    {
                        "name": "filepath",
                        "type": "str",
                        "description": "The absolute or relative path to a Python file."
                    },
                    {
                        "name": "project_root",
                        "type": "str",
                        "description": "The root directory of the project used to compute the relative path."
                    }
                ],
                "returns": [
                    {
                        "name": "module_path",
                        "type": "str",
                        "description": "A dot-separated module path derived from the given file path."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by _collect_definitions and __init__ methods in relationship_analyzer.py."
                }
            },
            "error": null
        },
        "database.db.encrypt_text": {
            "identifier": "database.db.encrypt_text",
            "description": {
                "overall": "The function encrypts a given text string using a Fernet cipher suite. It first checks if the input text is empty or if the cipher suite is not available, returning the original text in such cases. If both conditions are met, it strips whitespace from the input text, encodes it to bytes, encrypts it using the cipher suite, and then decodes the result back to a string.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "The text string to be encrypted."
                    }
                ],
                "returns": [
                    {
                        "name": "encrypted_text",
                        "type": "str",
                        "description": "The encrypted version of the input text as a string, or the original text if encryption is not possible."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the update_gemini_key function in the db.py file."
                }
            },
            "error": null
        },
        "database.db.decrypt_text": {
            "identifier": "database.db.decrypt_text",
            "description": {
                "overall": "The function decrypts a given text using a cipher suite, handling potential exceptions by returning the original text if decryption fails. It first checks if the input text is empty or if the cipher suite is not available, in which case it returns the input text as-is. If both conditions are met, it attempts to decrypt the text after stripping whitespace and encoding it to bytes. If any exception occurs during decryption, it gracefully falls back to returning the original text.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "The encrypted text to be decrypted."
                    }
                ],
                "returns": [
                    {
                        "name": "return_value",
                        "type": "str",
                        "description": "The decrypted text if successful; otherwise, the original input text."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by get_decrypted_api_keys in db.py at line 93."
                }
            },
            "error": null
        },
        "database.db.insert_user": {
            "identifier": "database.db.insert_user",
            "description": {
                "overall": "The function inserts a new user into the database by creating a user document with the provided username, name, and password. The password is hashed before being stored. It also initializes default values for the Gemini API key and Ollama base URL. The function returns the ID of the inserted document.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user, used as the '_id' field in the database."
                    },
                    {
                        "name": "name",
                        "type": "str",
                        "description": "The full name of the user."
                    },
                    {
                        "name": "password",
                        "type": "str",
                        "description": "The plain text password of the user, which gets hashed before storage."
                    }
                ],
                "returns": [
                    {
                        "name": "inserted_id",
                        "type": "ObjectId",
                        "description": "The unique identifier of the newly inserted user document in the database."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the Frontend class in the Frontend.py file at line 294."
                }
            },
            "error": null
        },
        "database.db.fetch_all_users": {
            "identifier": "database.db.fetch_all_users",
            "description": {
                "overall": "This function retrieves all user documents from a MongoDB collection named 'dbusers'. It performs a database query to find all records in the collection and returns them as a list. The function does not take any parameters and directly accesses the global 'dbusers' variable, which is presumably initialized elsewhere in the codebase.",
                "parameters": [],
                "returns": [
                    {
                        "name": "result",
                        "type": "list",
                        "description": "A list containing all user documents retrieved from the 'dbusers' MongoDB collection."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not call any other functions directly.",
                    "called_by": "This function is called by the 'frontend.Frontend' class in the 'Frontend.py' file at line 244."
                }
            },
            "error": null
        },
        "database.db.fetch_user": {
            "identifier": "database.db.fetch_user",
            "description": {
                "overall": "The function fetch_user retrieves a single user document from a MongoDB collection named 'dbusers' based on the provided username. It uses the find_one method to query the database with a filter that matches the '_id' field to the given username. The function does not perform any additional processing or validation on the retrieved data before returning it.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier (username) used to locate the specific user document in the MongoDB collection."
                    }
                ],
                "returns": [
                    {
                        "name": "result",
                        "type": "Any",
                        "description": "The user document matching the provided username, or None if no such document exists in the collection."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.update_user_name": {
            "identifier": "database.db.update_user_name",
            "description": {
                "overall": "This function updates the name field of a user document in a MongoDB collection identified by the username. It uses the MongoDB update_one method to modify only the 'name' field of the document matching the given username. The function returns the count of modified documents, which should be 1 if the update was successful or 0 if no matching document was found.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The identifier of the user whose name needs to be updated, used as the search criteria in the MongoDB query."
                    },
                    {
                        "name": "new_name",
                        "type": "str",
                        "description": "The new name value that will replace the existing name field in the user document."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified by the update operation. This will typically be 1 if a matching document was found and updated, or 0 if no matching document was found."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally calls the MongoDB update_one method to perform the database update operation.",
                    "called_by": "This function is not called by any other functions according to the provided context information."
                }
            },
            "error": null
        },
        "database.db.update_gemini_key": {
            "identifier": "database.db.update_gemini_key",
            "description": {
                "overall": "This function updates the Gemini API key for a specified user in the database. It first encrypts the provided API key using a text encryption function, then performs an update operation on the 'dbusers' collection to store the encrypted key under the user's ID. The function returns the count of modified documents, indicating whether the update was successful.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user whose Gemini API key needs to be updated."
                    },
                    {
                        "name": "gemini_api_key",
                        "type": "str",
                        "description": "The raw Gemini API key provided by the user, which will be stripped of whitespace and encrypted before storage."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified as a result of the update operation."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally calls 'encrypt_text' to encrypt the provided API key before storing it.",
                    "called_by": "This function is called by 'save_gemini_cb' in 'Frontend.py' at line 35 and by 'frontend.Frontend' in 'Frontend.py' at line 393."
                }
            },
            "error": null
        },
        "database.db.update_ollama_url": {
            "identifier": "database.db.update_ollama_url",
            "description": {
                "overall": "This function updates the Ollama base URL for a specified user in the database. It takes a username and a new Ollama base URL as inputs, strips any leading or trailing whitespace from the URL, and performs an update operation on the user document. The function returns the count of modified documents, which should be 1 if the update was successful.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier of the user whose Ollama base URL needs to be updated."
                    },
                    {
                        "name": "ollama_base_url",
                        "type": "str",
                        "description": "The new Ollama base URL to be set for the user. Leading and trailing whitespace will be stripped."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were successfully modified by the update operation. Typically 1 if the user exists and the update is applied."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by save_ollama_cb in Frontend.py at line 42 and by frontend.Frontend in Frontend.py at line 407."
                }
            },
            "error": null
        },
        "database.db.fetch_gemini_key": {
            "identifier": "database.db.fetch_gemini_key",
            "description": {
                "overall": "This function retrieves a Gemini API key associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'gemini_api_key' field. If no matching user is found, it returns None.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier (username) used to locate the corresponding user document in the database."
                    }
                ],
                "returns": [
                    {
                        "name": "gemini_api_key",
                        "type": "Optional[str]",
                        "description": "The retrieved Gemini API key if a matching user is found; otherwise, None."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses the 'dbusers.find_one' method to query the database.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.fetch_ollama_url": {
            "identifier": "database.db.fetch_ollama_url",
            "description": {
                "overall": "This function retrieves the Ollama base URL associated with a given username from a MongoDB collection. It queries the 'dbusers' collection to find a document matching the provided username and extracts the 'ollama_base_url' field. If no matching user is found, it returns None.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user whose Ollama base URL is to be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "ollama_base_url",
                        "type": "Optional[str]",
                        "description": "The Ollama base URL associated with the user, or None if the user is not found."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally calls 'dbusers.find_one' to query the database.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.delete_user": {
            "identifier": "database.db.delete_user",
            "description": {
                "overall": "The function 'delete_user' removes a user document from a MongoDB collection based on the provided username. It uses the 'delete_one' method to target a specific user by their '_id', which corresponds to the username. The function then returns the count of deleted documents, which will be 1 if the user was found and deleted, or 0 if no such user existed.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier (username) of the user to be deleted from the database."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of documents deleted, either 1 if the user was found and removed, or 0 if no matching user was found."
                    }
                ],
                "usage_context": {
                    "calls": "This function internally calls 'dbusers.delete_one' to perform the deletion operation in the MongoDB collection.",
                    "called_by": "This function is not called by any other functions within the provided context."
                }
            },
            "error": null
        },
        "database.db.get_decrypted_api_keys": {
            "identifier": "database.db.get_decrypted_api_keys",
            "description": {
                "overall": "This function retrieves and decrypts API keys for a given username from a database. It first fetches the user document using the username as the identifier. If the user does not exist, it returns two None values. If the user exists, it attempts to decrypt the 'gemini_api_key' field using a decryption function and retrieves the 'ollama_base_url' directly. Both decrypted and plain text values are returned as a tuple.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier for the user whose API keys are to be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "gemini_plain",
                        "type": "str",
                        "description": "The decrypted Gemini API key for the user, or an empty string if not found."
                    },
                    {
                        "name": "ollama_plain",
                        "type": "str",
                        "description": "The Ollama base URL for the user, or an empty string if not found."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses dbusers.find_one to retrieve user data and decrypt_text to decrypt the API key.",
                    "called_by": "This function is called by the frontend.Frontend class in Frontend.py at lines 380 and 479."
                }
            },
            "error": null
        },
        "database.db.insert_chat": {
            "identifier": "database.db.insert_chat",
            "description": {
                "overall": "The function 'insert_chat' creates a new chat entry in the database with a unique identifier, associated username, chat name, and timestamp. It generates a UUID for the chat ID, sets the creation time to the current moment, and inserts the chat document into the 'dbchats' collection. The function then returns the ID of the newly inserted chat.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat to be created."
                    }
                ],
                "returns": [
                    {
                        "name": "result.inserted_id",
                        "type": "str",
                        "description": "The unique identifier of the newly inserted chat document."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by load_data_from_db in Frontend.py at line 81, handle_delete_chat in Frontend.py at line 122, and frontend.Frontend in Frontend.py at line 344."
                }
            },
            "error": null
        },
        "database.db.fetch_chats_by_user": {
            "identifier": "database.db.fetch_chats_by_user",
            "description": {
                "overall": "Die Funktion fetch_chats_by_user ruft alle Chats eines bestimmten Benutzers aus einer MongoDB-Datenbank ab. Sie verwendet den Benutzernamen als Filterkriterium und sortiert die Ergebnisse nach dem Erstellungsdatum in aufsteigender Reihenfolge. Das Ergebnis ist eine Liste der gefundenen Chat-Dokumente.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "Der Benutzername, dessen Chats abgerufen werden sollen."
                    }
                ],
                "returns": [
                    {
                        "name": "chats",
                        "type": "list",
                        "description": "Eine Liste aller Chat-Dokumente des angegebenen Benutzers, sortiert nach Erstellungsdatum."
                    }
                ],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen Funktionen innerhalb ihres Codes auf.",
                    "called_by": "Die Funktion wird von der Funktion load_data_from_db in der Datei Frontend.py aufgerufen."
                }
            },
            "error": null
        },
        "database.db.check_chat_exists": {
            "identifier": "database.db.check_chat_exists",
            "description": {
                "overall": "This function checks whether a specific chat entry exists in the database for a given username and chat name. It performs a lookup in the 'dbchats' collection using a MongoDB query that matches both the username and chat name. The function returns a boolean value indicating the presence or absence of the chat entry.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat to check for existence."
                    }
                ],
                "returns": [
                    {
                        "name": "exists",
                        "type": "bool",
                        "description": "True if a chat with the specified username and chat_name exists in the database; False otherwise."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses the 'dbchats.find_one' method to query the database.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.rename_chat_fully": {
            "identifier": "database.db.rename_chat_fully",
            "description": {
                "overall": "This function renames a chat and updates all associated exchanges in the database. It first updates the chat entry in the chats collection, then updates all related exchange records in the exchanges collection. The function returns the number of modified chat entries.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat to be renamed."
                    },
                    {
                        "name": "old_name",
                        "type": "str",
                        "description": "The current name of the chat to be renamed."
                    },
                    {
                        "name": "new_name",
                        "type": "str",
                        "description": "The new name to assign to the chat."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of chat entries that were successfully modified during the renaming operation."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it uses MongoDB operations update_one and update_many.",
                    "called_by": "This function is called by the frontend.Frontend class in Frontend.py at line 462."
                }
            },
            "error": null
        },
        "database.db.insert_exchange": {
            "identifier": "database.db.insert_exchange",
            "description": {
                "overall": "This function inserts a new exchange record into a MongoDB collection. It generates a unique ID for the exchange, constructs a dictionary with all the provided details including question, answer, feedback, and timing information, and attempts to insert this document into the database. If the insertion fails, it catches the exception, prints an error message, and returns None. Otherwise, it returns the generated unique ID.",
                "parameters": [
                    {
                        "name": "question",
                        "type": "str",
                        "description": "The question asked in the exchange."
                    },
                    {
                        "name": "answer",
                        "type": "str",
                        "description": "The answer provided in response to the question."
                    },
                    {
                        "name": "feedback",
                        "type": "str",
                        "description": "Feedback associated with the exchange."
                    },
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username of the user involved in the exchange."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat session."
                    },
                    {
                        "name": "helper_used",
                        "type": "str",
                        "description": "The helper tool used during the exchange (optional)."
                    },
                    {
                        "name": "main_used",
                        "type": "str",
                        "description": "The main tool used during the exchange (optional)."
                    },
                    {
                        "name": "total_time",
                        "type": "str",
                        "description": "Total time taken for the exchange (optional)."
                    },
                    {
                        "name": "helper_time",
                        "type": "str",
                        "description": "Time taken by the helper tool (optional)."
                    },
                    {
                        "name": "main_time",
                        "type": "str",
                        "description": "Time taken by the main tool (optional)."
                    }
                ],
                "returns": [
                    {
                        "name": "new_id",
                        "type": "str",
                        "description": "The unique identifier of the inserted exchange record, or None if insertion failed."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the frontend.Frontend class in Frontend.py at line 530."
                }
            },
            "error": null
        },
        "database.db.fetch_exchanges_by_user": {
            "identifier": "database.db.fetch_exchanges_by_user",
            "description": {
                "overall": "This function retrieves all exchange records from a MongoDB collection for a given username, sorted by creation timestamp in ascending order. It uses the pymongo library to query the database and returns the results as a list. The sorting ensures that exchanges are displayed chronologically, which is important for user experience.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The unique identifier of the user whose exchange records are to be fetched."
                    }
                ],
                "returns": [
                    {
                        "name": "exchanges",
                        "type": "list",
                        "description": "A list of exchange records retrieved from the database for the specified user, sorted by creation timestamp in ascending order."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the load_data_from_db function in the Frontend.py file."
                }
            },
            "error": null
        },
        "database.db.fetch_exchanges_by_chat": {
            "identifier": "database.db.fetch_exchanges_by_chat",
            "description": {
                "overall": "This function retrieves a sorted list of exchanges from a MongoDB collection based on a given username and chat name. It queries the 'dbexchanges' collection with specific criteria and orders the results by creation date in ascending order. The function returns the fetched exchanges as a list.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the exchanges to be retrieved."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat associated with the exchanges to be retrieved."
                    }
                ],
                "returns": [
                    {
                        "name": "exchanges",
                        "type": "list",
                        "description": "A list of exchange documents matching the provided username and chat name, sorted by creation date in ascending order."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally uses the 'dbexchanges.find' method to query the database and 'sort' to order the results.",
                    "called_by": "This function is not called by any other functions according to the provided context."
                }
            },
            "error": null
        },
        "database.db.update_exchange_feedback": {
            "identifier": "database.db.update_exchange_feedback",
            "description": {
                "overall": "This function updates the feedback field of a document in the 'dbexchanges' collection within a MongoDB database. It takes an exchange ID and a feedback value, then attempts to update the corresponding document with the new feedback value. The function returns the count of modified documents, which indicates whether the update was successful.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "Any",
                        "description": "The unique identifier of the exchange document to be updated."
                    },
                    {
                        "name": "feedback",
                        "type": "int",
                        "description": "The feedback value to be set in the document."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were modified as a result of the update operation."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally calls the 'update_one' method on the 'dbexchanges' collection object to perform the database update.",
                    "called_by": "This function is called by the 'handle_feedback_change' function in 'Frontend.py' at line 98."
                }
            },
            "error": null
        },
        "database.db.update_exchange_feedback_message": {
            "identifier": "database.db.update_exchange_feedback_message",
            "description": {
                "overall": "This function updates the feedback message associated with a specific exchange document in a MongoDB collection. It takes an exchange ID and a new feedback message as inputs, then performs an update operation on the database to set the feedback_message field. The function returns the count of modified documents, which indicates whether the update was successful.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "Any",
                        "description": "The unique identifier of the exchange document to be updated."
                    },
                    {
                        "name": "feedback_message",
                        "type": "str",
                        "description": "The new feedback message to be stored in the exchange document."
                    }
                ],
                "returns": [
                    {
                        "name": "modified_count",
                        "type": "int",
                        "description": "The number of documents that were modified by the update operation."
                    }
                ],
                "usage_context": {
                    "calls": "The function does not call any other functions directly.",
                    "called_by": "This function is called by the render_exchange function in Frontend.py at line 211."
                }
            },
            "error": null
        },
        "database.db.delete_exchange_by_id": {
            "identifier": "database.db.delete_exchange_by_id",
            "description": {
                "overall": "This function deletes a document from the 'dbexchanges' collection in a MongoDB database based on a provided exchange ID. It performs a deletion operation and returns the count of deleted documents. The function assumes that the 'dbexchanges' collection and the MongoDB connection are properly initialized elsewhere in the codebase.",
                "parameters": [
                    {
                        "name": "exchange_id",
                        "type": "str",
                        "description": "A string identifier used to locate and delete a specific document in the 'dbexchanges' collection."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of documents successfully deleted from the 'dbexchanges' collection, typically 0 or 1."
                    }
                ],
                "usage_context": {
                    "calls": "The function internally calls the 'delete_one' method on the 'dbexchanges' collection to perform the deletion operation.",
                    "called_by": "This function is called by the 'handle_delete_exchange' function in 'Frontend.py' at line 102."
                }
            },
            "error": null
        },
        "database.db.delete_full_chat": {
            "identifier": "database.db.delete_full_chat",
            "description": {
                "overall": "This function deletes a complete chat session along with all associated exchanges from the database. It first removes all exchange records linked to the specified username and chat name, followed by deleting the chat record itself. The function returns the count of deleted chat documents, ensuring consistency between frontend and backend data states.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat to be deleted."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat session to be deleted."
                    }
                ],
                "returns": [
                    {
                        "name": "deleted_count",
                        "type": "int",
                        "description": "The number of chat documents that were successfully deleted from the database."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on external database operations via dbexchanges and dbchats.",
                    "called_by": "This function is called by the handle_delete_chat function in the Frontend.py file at line 110."
                }
            },
            "error": null
        },
        "frontend.Frontend.save_gemini_cb": {
            "identifier": "frontend.Frontend.save_gemini_cb",
            "description": {
                "overall": "This function handles the saving of a Gemini API key entered by the user in a Streamlit frontend application. It retrieves the key from the session state, updates the database with the new key for the current user, clears the input field, and displays a success message to the user. The function does not take any parameters and does not return any value.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally uses Streamlit session state operations and a database update function.",
                    "called_by": "This function is not called by any other function according to the provided context."
                }
            },
            "error": null
        },
        "frontend.Frontend.save_ollama_cb": {
            "identifier": "frontend.Frontend.save_ollama_cb",
            "description": {
                "overall": "This function handles the saving of a new Ollama URL entered by the user in the frontend interface. It retrieves the URL from the session state, updates the database with the new URL associated with the user's username, and displays a success toast message to the user. The function does not take any parameters and does not return any value.",
                "parameters": [],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally uses `st.session_state.get()` to retrieve values from the Streamlit session state and calls `db.update_ollama_url()` to update the database.",
                    "called_by": "This function is not called by any other function according to the provided context."
                }
            },
            "error": null
        },
        "frontend.Frontend.load_data_from_db": {
            "identifier": "frontend.Frontend.load_data_from_db",
            "description": {
                "overall": "Die Funktion 'load_data_from_db' lädt Chats und Exchanges konsistent aus einer Datenbank für einen bestimmten Benutzer. Sie prüft zunächst, ob der Benutzer bereits geladen wurde, und lädt dann die Chats und zugehörigen Exchanges aus der Datenbank. Bei Bedarf werden fehlende Chats und ein Standard-Chat angelegt. Die Funktion verwendet Streamlit-Sitzungsvariablen zur Speicherung der geladenen Daten.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "Der Benutzername, für den die Daten aus der Datenbank geladen werden sollen."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "Die Funktion ruft keine anderen internen Funktionen auf.",
                    "called_by": "Die Funktion wird von 'frontend.Frontend' in der Datei 'Frontend.py' auf Zeile 310 aufgerufen."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_feedback_change": {
            "identifier": "frontend.Frontend.handle_feedback_change",
            "description": {
                "overall": "This function updates the feedback value for a given exchange record in the database and triggers a Streamlit rerun to refresh the UI. It takes an exchange dictionary and a new feedback value, updates the 'feedback' key in the dictionary, saves the updated feedback to the database using the exchange ID, and then calls st.rerun() to update the frontend display.",
                "parameters": [
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary representing an exchange record, expected to contain keys such as '_id' and 'feedback'."
                    },
                    {
                        "name": "val",
                        "type": "Any",
                        "description": "The new feedback value to be assigned to the exchange record."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally calls db.update_exchange_feedback() to persist the feedback change in the database and st.rerun() to refresh the Streamlit interface.",
                    "called_by": "This function is called by render_exchange() in Frontend.py at lines 199 and 204."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_delete_exchange": {
            "identifier": "frontend.Frontend.handle_delete_exchange",
            "description": {
                "overall": "This function handles the deletion of an exchange from the database and updates the session state accordingly. It first deletes the exchange from the database using its ID, then checks if the exchange exists in the session state for a given chat and removes it if found. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
                "parameters": [
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat from which the exchange is to be deleted."
                    },
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary representing the exchange to be deleted, expected to contain an '_id' key."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally calls `db.delete_exchange_by_id` to delete the exchange from the database and uses `st.rerun()` to refresh the Streamlit UI.",
                    "called_by": "This function is called by the `render_exchange` function in `Frontend.py` at lines 228 and 234."
                }
            },
            "error": null
        },
        "frontend.Frontend.handle_delete_chat": {
            "identifier": "frontend.Frontend.handle_delete_chat",
            "description": {
                "overall": "This function handles the deletion of a chat by first removing the chat from the database and then cleaning up the session state. It ensures that the active chat is updated appropriately after deletion, either by selecting another existing chat or by creating a new default chat if none remain. Finally, it triggers a rerun of the Streamlit app to reflect the changes.",
                "parameters": [
                    {
                        "name": "username",
                        "type": "str",
                        "description": "The username associated with the chat to be deleted."
                    },
                    {
                        "name": "chat_name",
                        "type": "str",
                        "description": "The name of the chat to be deleted."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not directly call any other user-defined functions but relies on external modules such as 'db' and 'st' for database operations and session management.",
                    "called_by": "This function is called by the frontend.Frontend class in the Frontend.py file at line 367."
                }
            },
            "error": null
        },
        "frontend.Frontend.extract_repo_name": {
            "identifier": "frontend.Frontend.extract_repo_name",
            "description": {
                "overall": "The function 'extract_repo_name' takes a text input and attempts to extract a repository name from any URL present in the text. It uses regular expressions to find a URL, parses it using urllib.parse.urlparse, extracts the path component, and then derives the repository name from the last segment of the path. If the repository name ends with '.git', it removes the extension before returning the result. If no valid URL is found or no repository name can be extracted, it returns None.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "A string that may contain a URL from which to extract the repository name."
                    }
                ],
                "returns": [
                    {
                        "name": "repo_name",
                        "type": "str",
                        "description": "The extracted repository name from the URL, with '.git' suffix removed if present."
                    },
                    {
                        "name": "None",
                        "type": "NoneType",
                        "description": "Returned when no valid URL is found in the input text or when no repository name can be derived."
                    }
                ],
                "usage_context": {
                    "calls": "This function does not call any other functions directly; it relies on external modules like 're' and 'urllib.parse.urlparse'.",
                    "called_by": "This function is called by the 'frontend.Frontend' class in the 'Frontend.py' file at line 442."
                }
            },
            "error": null
        },
        "frontend.Frontend.stream_text_generator": {
            "identifier": "frontend.Frontend.stream_text_generator",
            "description": {
                "overall": "The function 'stream_text_generator' takes a string input and yields each word from the string followed by a space, with a small delay between each word. It is designed to simulate a streaming effect for text rendering. The function does not perform any complex processing or validation on the input.",
                "parameters": [
                    {
                        "name": "text",
                        "type": "str",
                        "description": "A string containing the text to be streamed word by word."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function does not call any other functions directly.",
                    "called_by": "This function is called by the 'render_text_with_mermaid' function in 'Frontend.py' at line 160."
                }
            },
            "error": null
        },
        "frontend.Frontend.render_text_with_mermaid": {
            "identifier": "frontend.Frontend.render_text_with_mermaid",
            "description": {
                "overall": "This function processes a markdown text string to identify and render Mermaid diagrams embedded within code blocks. It splits the input text by Mermaid code blocks, rendering regular markdown content normally and Mermaid diagrams using a specialized streamlit component. If the input text is empty, the function returns early without processing. In case of rendering errors with Mermaid diagrams, it falls back to displaying the diagram as plain code.",
                "parameters": [
                    {
                        "name": "markdown_text",
                        "type": "str",
                        "description": "A string containing markdown-formatted text that may include Mermaid diagram code blocks enclosed in triple backticks with 'mermaid' language specifier."
                    },
                    {
                        "name": "should_stream",
                        "type": "bool",
                        "description": "A boolean flag indicating whether to stream the markdown text rendering or render it directly. Defaults to False."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "The function internally uses regular expressions to split the markdown text and utilizes Streamlit components like st.write_stream, st.markdown, and st_mermaid for rendering.",
                    "called_by": "This function is called by the render_exchange method in Frontend.py at line 238 and also by the frontend.Frontend module at line 524."
                }
            },
            "error": null
        },
        "frontend.Frontend.render_exchange": {
            "identifier": "frontend.Frontend.render_exchange",
            "description": {
                "overall": "This function renders a chat exchange in a Streamlit interface, displaying a user's question and an assistant's response. It handles both regular responses and error cases, providing interactive feedback mechanisms such as like/dislike buttons, comment functionality, and download options. The function also includes logic for deleting exchanges and rendering Mermaid diagrams in the response content.",
                "parameters": [
                    {
                        "name": "ex",
                        "type": "dict",
                        "description": "A dictionary containing the exchange data, including the question, answer, feedback status, and other metadata."
                    },
                    {
                        "name": "current_chat_name",
                        "type": "str",
                        "description": "The name of the current chat session, used for handling deletion operations."
                    }
                ],
                "returns": [],
                "usage_context": {
                    "calls": "This function internally uses several Streamlit components such as st.chat_message, st.container, st.button, st.popover, st.text_area, st.download_button, and st.error, along with custom functions like handle_feedback_change and handle_delete_exchange.",
                    "called_by": "This function is called by the frontend.Frontend class, specifically from line 429 in Frontend.py."
                }
            },
            "error": null
        }
    },
    "classes": {
        "backend.AST_Schema.ASTVisitor": {
            "identifier": "backend.AST_Schema.ASTVisitor",
            "description": {
                "overall": "The ASTVisitor class is a specialized AST (Abstract Syntax Tree) visitor that traverses Python source code to extract structural information such as imports, classes, and functions. It leverages the `ast.NodeVisitor` base class to walk through nodes in the parsed AST and builds a schema representation of the module's structure. The visitor maintains contextual information about the current class being processed and organizes collected data into a structured format including imports, functions, and classes.",
                "init_method": {
                    "description": "Initializes the ASTVisitor with source code, file path, and project root. It also computes the module path based on the file path and project root, and initializes an empty schema dictionary to store extracted information along with a placeholder for tracking the current class during traversal.",
                    "parameters": [
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "The full source code of the file being analyzed."
                        },
                        {
                            "name": "file_path",
                            "type": "str",
                            "description": "The absolute or relative path to the file being analyzed."
                        },
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "The root directory of the project to determine module paths."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles import nodes in the AST by extracting the names of imported modules and appending them to the schema's imports list. It iterates over the aliases in the import node and adds each alias name to the schema.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "The AST node representing an import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when an import node is encountered."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Handles 'from ... import ...' statements in the AST by extracting the fully qualified names of imported items and appending them to the schema's imports list. It constructs the full module path for each imported item and appends it to the schema.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "The AST node representing a 'from ... import ...' statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when an 'import from' node is encountered."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "Processes class definitions in the AST by creating a structured representation of the class and adding it to the schema. It sets up the class information including its identifier, name, docstring, source code segment, and line numbers. It also tracks the current class being visited and ensures proper cleanup after traversal.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "The AST node representing a class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when a class definition node is encountered."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Processes function definitions in the AST. If the function is defined within a class, it creates a method context entry under the current class. Otherwise, it creates a standalone function entry in the schema. It extracts function metadata such as arguments, docstring, and source code segments, and includes line number information.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "The AST node representing a function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the generic AST traversal mechanism when a function definition node is encountered."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_AsyncFunctionDef",
                        "description": {
                            "overall": "Handles asynchronous function definitions by delegating the processing to the standard function definition handler. This ensures that async functions are treated similarly to regular functions in terms of schema extraction.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AsyncFunctionDef",
                                    "description": "The AST node representing an asynchronous function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the visit_FunctionDef method to handle the core logic.",
                                "called_by": "This method is called by the generic AST traversal mechanism when an async function definition node is encountered."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on the ast module for parsing and traversing Python source code, and uses path_to_module utility to compute module paths.",
                    "instantiated_by": "This class is instantiated by the analyze_repository function located in AST_Schema.py at line 182."
                }
            },
            "error": null
        },
        "backend.AST_Schema.ASTAnalyzer": {
            "identifier": "backend.AST_Schema.ASTAnalyzer",
            "description": {
                "overall": "The ASTAnalyzer class is responsible for analyzing Python repository files by parsing their Abstract Syntax Trees (ASTs) and enriching the resulting schema with call graph information. It supports merging relationship data into the schema and integrates with Git repositories to process multiple files. The class facilitates structured representation of code elements such as functions, classes, and methods along with their contextual relationships.",
                "init_method": {
                    "description": "Initializes an instance of the ASTAnalyzer class. The constructor currently does not perform any operations and simply passes.",
                    "parameters": []
                },
                "methods": [
                    {
                        "identifier": "_enrich_schema_with_callgraph",
                        "description": {
                            "overall": "This static method enriches a given schema with call graph information by updating function and method contexts with details about what they call and who calls them. It iterates over functions and class methods in the schema and updates their 'calls' and 'called_by' fields based on entries in the provided call graph.",
                            "parameters": [
                                {
                                    "name": "schema",
                                    "type": "dict",
                                    "description": "A dictionary representing the schema containing functions and classes with their metadata."
                                },
                                {
                                    "name": "call_graph",
                                    "type": "nx.DiGraph",
                                    "description": "A NetworkX directed graph representing the call relationships between functions and methods."
                                },
                                {
                                    "name": "filename",
                                    "type": "str",
                                    "description": "The path of the file being processed, used to construct keys for looking up entries in the call graph."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by the analyze_repository method within the ASTAnalyzer class."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "merge_relationship_data",
                        "description": {
                            "overall": "Merges relationship data into the full schema by mapping identifiers from the relationship data to corresponding nodes in the schema. It updates function and class contexts with 'called_by' information and class instantiation details based on the provided relationship data.",
                            "parameters": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "A dictionary containing the full schema of the repository with file-wise AST node information."
                                },
                                {
                                    "name": "relationship_data",
                                    "type": "list",
                                    "description": "A list of dictionaries containing relationship information including identifiers and called_by lists."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "The updated full schema with merged relationship data."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is called by both evaluation() in evaluation.py at line 137 and main_workflow() in main.py at line 190."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "analyze_repository",
                        "description": {
                            "overall": "Analyzes a set of files from a Git repository by parsing their content into ASTs, visiting them with an ASTVisitor, and enriching the resulting schema with call graph information. It handles file filtering, AST parsing, and error handling for syntax and value errors during parsing.",
                            "parameters": [
                                {
                                    "name": "files",
                                    "type": "list",
                                    "description": "A list of file objects containing paths and content to be analyzed."
                                },
                                {
                                    "name": "repo",
                                    "type": "GitRepository",
                                    "description": "An object representing the Git repository containing the files to be analyzed."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "full_schema",
                                    "type": "dict",
                                    "description": "A dictionary containing the full schema of the repository with enriched AST node information per file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls build_filtered_callgraph to generate a call graph, and also calls _enrich_schema_with_callgraph to update the schema with call graph data.",
                                "called_by": "This method is called by both evaluation() in evaluation.py at line 129 and main_workflow() in main.py at line 181."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on external modules such as ast, networkx, os, callgraph.build_filtered_callgraph, and getRepo.GitRepository.",
                    "instantiated_by": "This class is instantiated in the evaluation.py file within the evaluation function at line 128 and in the main.py file within the main_workflow function at line 180."
                }
            },
            "error": null
        },
        "backend.File_Dependency.FileDependencyGraph": {
            "identifier": "backend.File_Dependency.FileDependencyGraph",
            "description": {
                "overall": "The FileDependencyGraph class is designed to analyze and resolve file-level import dependencies within a Python project, particularly handling relative imports. It extends NodeVisitor to traverse AST nodes representing import statements and builds a dependency graph by mapping files to their imported modules. The class resolves relative imports by identifying candidate files and validating module existence or symbol exports in package __init__.py files.",
                "init_method": {
                    "description": "Initializes the FileDependencyGraph with a filename and repository root path. Sets up the instance with the file being analyzed and the root directory of the repository for resolving relative paths.",
                    "parameters": [
                        {
                            "name": "filename",
                            "type": "str",
                            "description": "The name of the file for which dependencies are being analyzed."
                        },
                        {
                            "name": "repo_root",
                            "type": "Any",
                            "description": "The root directory path of the repository containing the file."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_resolve_module_name",
                        "description": {
                            "overall": "Resolves relative import statements by determining the actual module or symbol names involved. It identifies candidate files based on the current file's location and processes relative import levels to find matching modules or symbols in __init__.py files. The method raises ImportError if no valid resolution can be made.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ImportFrom",
                                    "description": "An AST node representing a relative import statement."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "",
                                    "type": "list[str]",
                                    "description": "A list of resolved module or symbol names."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls helper functions 'module_file_exists' and 'init_exports_symbol' to validate module existence and symbol exports respectively.",
                                "called_by": "This method is called by 'visit_ImportFrom' when resolving relative imports."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles import statements by adding the imported module names to the import dependencies dictionary. It ensures that the current file's dependencies are recorded, either directly from the import alias or using a provided base name.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "Import | ImportFrom",
                                    "description": "An AST node representing an import statement."
                                },
                                {
                                    "name": "base_name",
                                    "type": "str | None",
                                    "description": "Optional base name for the imported module."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls 'generic_visit' to continue traversal of the AST.",
                                "called_by": "This method is called by 'visit_ImportFrom' during import resolution."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Processes 'from ... import ...' statements by extracting module names and delegating to 'visit_Import'. For absolute imports, it uses the last part of the module path. For relative imports, it attempts to resolve them using '_resolve_module_name'. If resolution fails, it prints an error message.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ImportFrom",
                                    "description": "An AST node representing a relative or absolute import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls '_resolve_module_name' to resolve relative imports and 'visit_Import' to record dependencies.",
                                "called_by": "This method is invoked by the AST visitor framework during traversal of import statements."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on various standard library modules such as ast, pathlib, and keyword, as well as custom modules like GitRepository and make_safe_dot.",
                    "instantiated_by": "The class is instantiated by the function 'build_file_dependency_graph' located in 'File_Dependency.py' at line 156."
                }
            },
            "error": null
        },
        "backend.HelperLLM.LLMHelper": {
            "identifier": "backend.HelperLLM.LLMHelper",
            "description": {
                "overall": "The LLMHelper class serves as a centralized interface for interacting with various language models, including Google Gemini, OpenAI, custom APIs, and Ollama, to generate and validate code documentation for functions and classes. It handles API configuration, batch processing, and error management while leveraging Pydantic for input/output validation.",
                "init_method": {
                    "description": "Initializes the LLMHelper with API credentials, prompt files, and model configurations. It reads system prompts from specified files, sets up the appropriate language model based on the model name, and configures batch settings for efficient processing.",
                    "parameters": [
                        {
                            "name": "api_key",
                            "type": "str",
                            "description": "API key for accessing the language model service."
                        },
                        {
                            "name": "function_prompt_path",
                            "type": "str",
                            "description": "Path to the file containing the system prompt for function documentation generation."
                        },
                        {
                            "name": "class_prompt_path",
                            "type": "str",
                            "description": "Path to the file containing the system prompt for class documentation generation."
                        },
                        {
                            "name": "model_name",
                            "type": "str",
                            "description": "Name of the language model to use, defaulting to 'gemini-2.0-flash-lite'."
                        },
                        {
                            "name": "base_url",
                            "type": "str",
                            "description": "Base URL for custom API endpoints, optional."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_configure_batch_settings",
                        "description": {
                            "overall": "Configures the batch size for processing requests based on the specified model name. Different models have different recommended batch sizes to optimize performance and avoid rate limiting.",
                            "parameters": [
                                {
                                    "name": "model_name",
                                    "type": "str",
                                    "description": "The name of the language model being used."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is called by the __init__ method during initialization."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "generate_for_functions",
                        "description": {
                            "overall": "Processes a batch of function inputs to generate validated documentation using the configured language model. It splits inputs into batches, sends them to the LLM, and handles errors by filling missing results with None values while respecting rate limits.",
                            "parameters": [
                                {
                                    "name": "function_inputs",
                                    "type": "List[FunctionAnalysisInput]",
                                    "description": "A list of function input models to process."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "List[Optional[FunctionAnalysis]]",
                                    "description": "A list of validated function analysis outputs or None for failed items."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not directly call other functions from the provided context.",
                                "called_by": "Called by evaluation function in evaluation.py at line 245 and main_workflow function in main.py at line 302."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "generate_for_classes",
                        "description": {
                            "overall": "Processes a batch of class inputs to generate validated documentation using the configured language model. Similar to generate_for_functions, it handles batching, API calls, and error recovery while respecting rate limits.",
                            "parameters": [
                                {
                                    "name": "class_inputs",
                                    "type": "List[ClassAnalysisInput]",
                                    "description": "A list of class input models to process."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "List[Optional[ClassAnalysis]]",
                                    "description": "A list of validated class analysis outputs or None for failed items."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not directly call other functions from the provided context.",
                                "called_by": "Called by evaluation function in evaluation.py at line 271 and main_workflow function in main.py at line 333."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "No external dependencies were explicitly listed in the context.",
                    "instantiated_by": "The class is instantiated by the main_orchestrator function in HelperLLM.py at line 387, the evaluation function in evaluation.py at line 222, and the main_workflow function in main.py at line 277."
                }
            },
            "error": null
        },
        "backend.MainLLM.MainLLM": {
            "identifier": "backend.MainLLM.MainLLM",
            "description": {
                "overall": "The MainLLM class serves as the central interface for interacting with various language learning models (LLMs), including Google's Gemini models and Ollama-based models. It initializes with an API key, a prompt file path, and model specifications, and supports both synchronous and streaming responses from the LLM. The class abstracts away the complexity of model selection and interaction by dynamically choosing the appropriate LLM client based on the model name.",
                "init_method": {
                    "description": "Initializes the MainLLM instance by validating the API key, loading the system prompt from a specified file, and setting up the appropriate LLM client based on the model name. It supports different LLM backends such as Google Generative AI and Ollama.",
                    "parameters": [
                        {
                            "name": "api_key",
                            "type": "str",
                            "description": "The API key required for accessing the LLM service."
                        },
                        {
                            "name": "prompt_file_path",
                            "type": "str",
                            "description": "The file path to the system prompt used for initializing the LLM."
                        },
                        {
                            "name": "model_name",
                            "type": "str",
                            "description": "The name of the model to use, which determines the backend client to instantiate. Defaults to 'gemini-2.5-pro'."
                        },
                        {
                            "name": "ollama_base_url",
                            "type": "str",
                            "description": "The base URL for the Ollama service, used when the model is not a Google Generative AI model."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "call_llm",
                        "description": {
                            "overall": "Sends a user input message to the configured LLM and returns the response content synchronously. It constructs a message sequence including the system prompt and the user input, invokes the LLM with these messages, and logs the success or failure of the operation.",
                            "parameters": [
                                {
                                    "name": "user_input",
                                    "type": "str",
                                    "description": "The input text provided by the user to be processed by the LLM."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "response_content",
                                    "type": "str",
                                    "description": "The content of the LLM's response, or None if an error occurs during the call."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "Called by the main_workflow function in main.py at line 410."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "stream_llm",
                        "description": {
                            "overall": "Streams the response from the LLM in chunks, yielding each chunk as it becomes available. It constructs a message sequence including the system prompt and the user input, initiates a streaming call to the LLM, and handles exceptions by yielding an error message.",
                            "parameters": [
                                {
                                    "name": "user_input",
                                    "type": "str",
                                    "description": "The input text provided by the user to be processed by the LLM."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "chunk_content",
                                    "type": "str",
                                    "description": "Yields content chunks from the LLM response or an error message if an exception occurs."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions directly.",
                                "called_by": "This method is not called by any other function according to the provided context."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "The class depends on several external libraries including langchain_google_genai.ChatGoogleGenerativeAI, langchain_ollama.ChatOllama, langchain.messages.HumanMessage, and langchain.messages.SystemMessage.",
                    "instantiated_by": "The class is instantiated by the main_workflow function in main.py at line 391."
                }
            },
            "error": null
        },
        "backend.basic_info.ProjektInfoExtractor": {
            "identifier": "backend.basic_info.ProjektInfoExtractor",
            "description": {
                "overall": "The ProjektInfoExtractor class is designed to extract basic project information from common project files such as README.md, pyproject.toml, and requirements.txt. It maintains an internal dictionary structure to store extracted information under categories like 'projekt_uebersicht' (project overview) and 'installation'. The extraction process prioritizes data sources, starting with pyproject.toml for metadata, followed by requirements.txt for dependencies, and finally README for descriptive content. The class also handles fallback mechanisms and formatting of dependency lists.",
                "init_method": {
                    "description": "Initializes the ProjektInfoExtractor with a default placeholder value for missing information and sets up an internal dictionary structure to hold project details. The structure includes sections for project overview and installation instructions, each populated with placeholders indicating missing data.",
                    "parameters": []
                },
                "methods": [
                    {
                        "identifier": "_finde_datei",
                        "description": {
                            "overall": "This private method searches for a file among a list of files based on a set of filename patterns. It performs a case-insensitive comparison to find a matching file extension. The method iterates through the provided list of files and checks if any file's path ends with one of the specified patterns. If a match is found, it returns the file object; otherwise, it returns None.",
                            "parameters": [
                                {
                                    "name": "patterns",
                                    "type": "List[str]",
                                    "description": "A list of filename extensions or patterns to search for."
                                },
                                {
                                    "name": "dateien",
                                    "type": "List[Any]",
                                    "description": "A list of file objects to search through."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "result",
                                    "type": "Optional[Any]",
                                    "description": "The matched file object if found, otherwise None."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other methods within the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_extrahiere_sektion_aus_markdown",
                        "description": {
                            "overall": "This private method extracts a section of text from a markdown document based on a given list of keywords. It uses regular expressions to locate a heading (##) matching one of the keywords and captures the text that follows until the next heading or end of the document. This allows for extracting specific sections like 'Installation' or 'Features' from markdown files.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The full markdown text content to parse."
                                },
                                {
                                    "name": "keywords",
                                    "type": "List[str]",
                                    "description": "A list of alternative keywords to match against markdown headings."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "extracted_text",
                                    "type": "Optional[str]",
                                    "description": "The extracted text section if a matching heading is found, otherwise None."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other methods within the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_readme",
                        "description": {
                            "overall": "This private method parses the content of a README file to extract various project details such as title, description, key features, tech stack, current status, setup instructions, and quick start guide. It uses regex patterns to identify these elements and updates the internal info dictionary accordingly. It leverages the _extrahiere_sektion_aus_markdown helper to extract specific sections from the markdown content.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The full content of the README file as a string."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the _extrahiere_sektion_aus_markdown helper function to extract specific sections from the markdown content.",
                                "called_by": "This method is not called by any other methods within the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_toml",
                        "description": {
                            "overall": "This private method parses the content of a pyproject.toml file to extract project metadata such as name, description, and dependencies. It uses the tomllib library to load the TOML content and updates the internal info dictionary with the parsed values. If tomllib is not available, it prints a warning message. It also handles potential parsing errors gracefully.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The full content of the pyproject.toml file as a string."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other methods within the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_parse_requirements",
                        "description": {
                            "overall": "This private method parses the content of a requirements.txt file to extract dependency information. It only populates the dependencies field if it hasn't already been filled by a previous parsing step (e.g., from pyproject.toml). It filters out comments and empty lines, then formats the dependencies into a readable string format.",
                            "parameters": [
                                {
                                    "name": "inhalt",
                                    "type": "str",
                                    "description": "The full content of the requirements.txt file as a string."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other methods within the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "extrahiere_info",
                        "description": {
                            "overall": "This public method orchestrates the extraction of project information from a list of repository files. It determines which files are relevant (README, pyproject.toml, requirements.txt) using the _finde_datei helper. It processes these files in order of priority: pyproject.toml first, then requirements.txt, and finally README. After processing, it formats the dependencies list and sets the project title based on the repository URL.",
                            "parameters": [
                                {
                                    "name": "dateien",
                                    "type": "List[Any]",
                                    "description": "A list of file objects representing files in the repository."
                                },
                                {
                                    "name": "repo_url",
                                    "type": "str",
                                    "description": "The URL of the repository, used to derive the project title."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "info",
                                    "type": "Dict[str, Any]",
                                    "description": "A dictionary containing the extracted project information organized under 'projekt_uebersicht' and 'installation' keys."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls the _finde_datei helper to locate relevant files, and then calls _parse_toml, _parse_requirements, and _parse_readme to process those files.",
                                "called_by": "This method is called by the evaluation function in evaluation.py at line 105 and by the main_workflow function in main.py at line 154."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class does not depend on any external libraries beyond standard Python modules and typing annotations.",
                    "instantiated_by": "This class is instantiated in the evaluation function in evaluation.py at line 104 and in the main_workflow function in main.py at line 153."
                }
            },
            "error": null
        },
        "backend.callgraph.CallGraph": {
            "identifier": "backend.callgraph.CallGraph",
            "description": {
                "overall": "The CallGraph class is an AST visitor designed to construct a call graph from Python source code. It traverses the abstract syntax tree of a file, tracking function and class definitions, imports, and function calls to build a directed graph representing the relationships between different callable entities. The class maintains internal state such as current function and class names, local definitions, and import mappings to resolve identifiers correctly. It uses NetworkX to represent the call graph and supports both synchronous and asynchronous function definitions.",
                "init_method": {
                    "description": "Initializes the CallGraph with a filename and sets up internal data structures including tracking for current function and class, local definitions, the call graph itself, import mappings, and a set of function names. It also initializes empty dictionaries and sets for storing various metadata during AST traversal.",
                    "parameters": [
                        {
                            "name": "filename",
                            "type": "str",
                            "description": "The name of the file being processed to build the call graph."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "_recursive_call",
                        "description": {
                            "overall": "Recursively extracts the dotted name components from an AST node representing a function call or attribute access. It handles different types of nodes like ast.Call, ast.Name, and ast.Attribute to reconstruct the full dotted path of a function or method reference.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AST",
                                    "description": "The AST node to extract the dotted name components from."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "parts",
                                    "type": "list[str]",
                                    "description": "A list of strings representing the dotted name components."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the _resolve_all_callee_names method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_all_callee_names",
                        "description": {
                            "overall": "Resolves a list of dotted name components into fully qualified names based on local definitions, import mappings, and current class context. It checks for local definitions first, then import mappings, and finally constructs a full name using the filename and context information.",
                            "parameters": [
                                {
                                    "name": "callee_nodes",
                                    "type": "list[list[str]]",
                                    "description": "A list of lists containing dotted name components for potential callees."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "resolved",
                                    "type": "list[str]",
                                    "description": "A list of fully qualified names for the callees."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls the _recursive_call method to extract name components.",
                                "called_by": "This method is called by the visit_Call method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_make_full_name",
                        "description": {
                            "overall": "Constructs a fully qualified name for a function or method using the filename, optional class name, and base name. This helps in uniquely identifying functions within the context of their file and class hierarchy.",
                            "parameters": [
                                {
                                    "name": "basename",
                                    "type": "str",
                                    "description": "The base name of the function or method."
                                },
                                {
                                    "name": "class_name",
                                    "type": "Optional[str]",
                                    "description": "The name of the class if the function is a method."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "full_name",
                                    "type": "str",
                                    "description": "The fully qualified name constructed from the filename, class name (if provided), and base name."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the visit_FunctionDef method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_current_caller",
                        "description": {
                            "overall": "Determines the current caller's name based on whether there is an active function context. If a function is currently being visited, it returns the function name; otherwise, it returns a placeholder indicating global scope or the filename.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "caller",
                                    "type": "str",
                                    "description": "The name of the current caller or a placeholder if no function is active."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the visit_Call method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles import statements in the AST by mapping aliases to their actual module names. It updates the import_mapping dictionary to allow resolution of imported names later during call resolution.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "The AST node representing an import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Handles 'from ... import ...' statements by mapping imported names to their respective modules. It updates the import_mapping dictionary to support resolving names from imported modules.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "The AST node representing a 'from ... import ...' statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "Processes class definitions in the AST by temporarily setting the current class name before visiting the class body. This allows proper resolution of methods within the class context.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "The AST node representing a class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Handles function definitions by creating a fully qualified name for the function, updating local definitions, and adding the function to the call graph. It also tracks the current function context during traversal.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "The AST node representing a function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls _make_full_name and generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_AsyncFunctionDef",
                        "description": {
                            "overall": "Handles asynchronous function definitions by delegating to the visit_FunctionDef method. This ensures that async functions are treated similarly to regular functions in terms of call graph construction.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.AsyncFunctionDef",
                                    "description": "The AST node representing an asynchronous function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls visit_FunctionDef to handle the function definition.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Call",
                        "description": {
                            "overall": "Processes function calls in the AST by determining the caller, extracting the callee's name components, resolving those names, and recording the edge in the call graph. It manages the edges between callers and callees.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Call",
                                    "description": "The AST node representing a function call."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls _current_caller, _recursive_call, and _resolve_all_callee_names to process the call.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_If",
                        "description": {
                            "overall": "Handles conditional statements, specifically looking for conditions involving '__name__' which typically indicate main block execution. In such cases, it temporarily changes the current function context to '<main_block>' before visiting the condition body.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.If",
                                    "description": "The AST node representing an if statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls generic_visit to continue traversal.",
                                "called_by": "This method is called by the AST visitor framework."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on the ast, networkx, os, pathlib.Path, typing.Dict, getRepo.GitRepository, and basic_info.ProjektInfoExtractor modules.",
                    "instantiated_by": "This class is instantiated in the build_filtered_callgraph function in callgraph.py at lines 207 and 214."
                }
            },
            "error": null
        },
        "backend.getRepo.RepoFile": {
            "identifier": "backend.getRepo.RepoFile",
            "description": {
                "overall": "The RepoFile class represents a single file within a Git repository. It implements lazy loading for file metadata such as content and size to optimize performance by only loading data when needed. The class provides properties for accessing the Git blob, content, and size of the file, along with utility methods for word count analysis and converting the file representation to a dictionary format.",
                "init_method": {
                    "description": "Initializes a RepoFile object with a file path and a commit tree. It sets up internal attributes for lazy loading including placeholders for the blob, content, and size of the file.",
                    "parameters": [
                        {
                            "name": "file_path",
                            "type": "str",
                            "description": "The path to the file within the repository."
                        },
                        {
                            "name": "commit_tree",
                            "type": "git.Tree",
                            "description": "The tree object of the commit from which the file originates."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "blob",
                        "description": {
                            "overall": "A property that lazily loads and returns the Git blob object associated with the file. If the blob has not yet been loaded, it retrieves it from the commit tree using the stored file path. If the file path does not exist in the tree, it raises a FileNotFoundError.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "blob",
                                    "type": "git.Blob",
                                    "description": "The Git blob object representing the file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "content",
                        "description": {
                            "overall": "A property that lazily loads and returns the decoded content of the file. It reads the data stream from the blob and decodes it as UTF-8 text, ignoring encoding errors. The content is cached after the first access to avoid repeated reads.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "content",
                                    "type": "str",
                                    "description": "The decoded content of the file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "size",
                        "description": {
                            "overall": "A property that lazily loads and returns the size of the file in bytes. It accesses the size attribute of the blob object, caching the result after the first retrieval to improve efficiency.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "size",
                                    "type": "int",
                                    "description": "The size of the file in bytes."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "analyze_word_count",
                        "description": {
                            "overall": "An example analysis method that counts the number of words in the file's content. It splits the content by whitespace and returns the length of the resulting list.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "word_count",
                                    "type": "int",
                                    "description": "The total number of words in the file."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__repr__",
                        "description": {
                            "overall": "Provides a useful string representation of the RepoFile object, displaying the file path for debugging and logging purposes.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "repr",
                                    "type": "str",
                                    "description": "A string representation of the RepoFile object."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "to_dict",
                        "description": {
                            "overall": "Converts the RepoFile object into a dictionary format, including basic file information such as path, name, size, and type. Optionally includes the file content if specified.",
                            "parameters": [
                                {
                                    "name": "include_content",
                                    "type": "bool",
                                    "description": "If True, includes the file content in the returned dictionary."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "data",
                                    "type": "dict",
                                    "description": "A dictionary representation of the RepoFile object."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions according to the provided context."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "No external dependencies were explicitly listed in the context.",
                    "instantiated_by": "This class is instantiated by the get_all_files method in the getRepo.py file."
                }
            },
            "error": null
        },
        "backend.getRepo.GitRepository": {
            "identifier": "backend.getRepo.GitRepository",
            "description": {
                "overall": "The GitRepository class manages a Git repository by cloning it into a temporary directory and providing access to its files through RepoFile objects. It supports listing all files, retrieving a hierarchical file tree, and cleaning up the temporary directory upon closing. The class implements context manager protocols (__enter__ and __exit__) to facilitate automatic resource management.",
                "init_method": {
                    "description": "Initializes a GitRepository instance by cloning the specified repository URL into a temporary directory. It sets up necessary attributes such as the repository URL, temporary directory path, and references to the cloned repository and its latest commit. If cloning fails, it raises a RuntimeError after attempting to clean up.",
                    "parameters": [
                        {
                            "name": "repo_url",
                            "type": "str",
                            "description": "The URL of the Git repository to clone."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "get_all_files",
                        "description": {
                            "overall": "Retrieves a list of all files in the repository and creates RepoFile objects for each file. These objects are stored in the instance's 'files' attribute and returned. This method uses git's ls-files command to enumerate files.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "files",
                                    "type": "list[RepoFile]",
                                    "description": "A list of RepoFile instances representing the files in the repository."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "close",
                        "description": {
                            "overall": "Deletes the temporary directory used for cloning the repository. This method ensures cleanup of resources allocated during the lifecycle of the GitRepository instance.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__enter__",
                        "description": {
                            "overall": "Enables the use of the GitRepository instance in a 'with' statement, returning itself as the context value.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The GitRepository instance itself."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "__exit__",
                        "description": {
                            "overall": "Implements the exit protocol for the context manager, ensuring that the close() method is called when exiting the 'with' block.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                },
                                {
                                    "name": "exc_type",
                                    "type": "Any",
                                    "description": "Exception type if an exception occurred in the with block."
                                },
                                {
                                    "name": "exc_val",
                                    "type": "Any",
                                    "description": "Exception value if an exception occurred in the with block."
                                },
                                {
                                    "name": "exc_tb",
                                    "type": "Any",
                                    "description": "Exception traceback if an exception occurred in the with block."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "get_file_tree",
                        "description": {
                            "overall": "Constructs a hierarchical representation of the repository's file structure. If no files have been loaded yet, it first retrieves all files using get_all_files(). Then, it builds a nested dictionary structure where directories and files are organized according to their paths.",
                            "parameters": [
                                {
                                    "name": "self",
                                    "type": "GitRepository",
                                    "description": "The instance of the GitRepository class."
                                },
                                {
                                    "name": "include_content",
                                    "type": "bool",
                                    "description": "Whether to include file content in the returned dictionary representation."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "tree",
                                    "type": "dict",
                                    "description": "A nested dictionary representing the file tree structure."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods internally.",
                                "called_by": "This method is not called by any other methods according to the provided context."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on several modules including tempfile, shutil, git.Repo, git.GitCommandError, logging, and os.",
                    "instantiated_by": "This class is instantiated in the evaluation.py file within the evaluation function at line 86 and in main.py within the main_workflow function at line 134."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.ProjectAnalyzer": {
            "identifier": "backend.relationship_analyzer.ProjectAnalyzer",
            "description": {
                "overall": "The ProjectAnalyzer class is responsible for analyzing Python project structures by identifying definitions (functions, classes, methods) and tracking their call relationships across files. It walks through the project directory, parses Python files into Abstract Syntax Trees (ASTs), collects definitions with their metadata, resolves inter-file function calls, and formats the results for further use. The analyzer ignores common directories like .git, venv, etc., and uses AST traversal techniques to extract structural information.",
                "init_method": {
                    "description": "Initializes the ProjectAnalyzer with a project root directory. Sets up internal data structures including a dictionary for storing definitions, a call graph, and a mapping of file paths to their parsed ASTs. Also defines a set of directories to ignore during file discovery.",
                    "parameters": [
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "The root directory path of the Python project to be analyzed."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "analyze",
                        "description": {
                            "overall": "The main analysis method that orchestrates the process of finding Python files, collecting definitions from those files, resolving inter-file calls, and formatting the final results. It clears the cached ASTs after processing and returns a formatted list of definitions along with their callers.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "output_list",
                                    "type": "list",
                                    "description": "A list of dictionaries representing definitions and their callers, each containing metadata such as identifier, mode, origin, line number, and called_by details."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method calls `_find_py_files`, `_collect_definitions`, `_resolve_calls`, and `get_formatted_results`.",
                                "called_by": "This method is called by the functions 'evaluation' in 'evaluation.py' at line 120 and 'main_workflow' in 'main.py' at line 171."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_find_py_files",
                        "description": {
                            "overall": "Recursively discovers all Python (.py) files within the project root directory, excluding specified ignored directories such as .git, venv, etc. It returns a list of absolute file paths for all discovered Python files.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "py_files",
                                    "type": "list",
                                    "description": "A list of absolute file paths to Python source files in the project."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods.",
                                "called_by": "This method is called by the 'analyze' method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_collect_definitions",
                        "description": {
                            "overall": "Parses a given Python file into an AST and extracts definitions such as functions, classes, and methods. It associates these definitions with their respective modules and stores metadata including file location and line numbers. Errors during parsing are logged but do not halt execution.",
                            "parameters": [
                                {
                                    "name": "filepath",
                                    "type": "str",
                                    "description": "The absolute path to the Python file whose definitions need to be collected."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not call any other methods directly.",
                                "called_by": "This method is called by the 'analyze' method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_get_parent",
                        "description": {
                            "overall": "Traverses an AST to find the parent node of a given node. This helper method is used to determine whether a function or method definition belongs to a class or is a top-level function.",
                            "parameters": [
                                {
                                    "name": "tree",
                                    "type": "ast.AST",
                                    "description": "The AST tree being traversed."
                                },
                                {
                                    "name": "node",
                                    "type": "ast.AST",
                                    "description": "The AST node for which the parent needs to be found."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "parent",
                                    "type": "ast.AST or None",
                                    "description": "The parent AST node of the given node, or None if not found."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods directly.",
                                "called_by": "This method is called by the '_collect_definitions' method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_calls",
                        "description": {
                            "overall": "Resolves inter-file function calls by visiting the AST of a given file using a CallResolverVisitor. It updates the call graph with information about which functions call which others. Errors during resolution are logged but do not halt execution.",
                            "parameters": [
                                {
                                    "name": "filepath",
                                    "type": "str",
                                    "description": "The absolute path to the Python file whose calls need to be resolved."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls 'CallResolverVisitor.visit' and accesses 'resolver.calls'.",
                                "called_by": "This method is called by the 'analyze' method."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "get_formatted_results",
                        "description": {
                            "overall": "Formats the collected call graph and definition information into a structured list of dictionaries. Each dictionary represents a definition and includes its identifier, type, origin file, line number, and a list of callers with associated metadata. Duplicate callers are removed before returning the result.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "output_list",
                                    "type": "list",
                                    "description": "A list of dictionaries containing formatted definition and call relationship data."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other methods directly.",
                                "called_by": "This method is called by the 'analyze' method."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "This class depends on standard library modules such as 'ast', 'os', 'logging', and 'collections.defaultdict'.",
                    "instantiated_by": "This class is instantiated by the functions 'evaluation' in 'evaluation.py' at line 119 and 'main_workflow' in 'main.py' at line 170."
                }
            },
            "error": null
        },
        "backend.relationship_analyzer.CallResolverVisitor": {
            "identifier": "backend.relationship_analyzer.CallResolverVisitor",
            "description": {
                "overall": "The CallResolverVisitor class is an AST (Abstract Syntax Tree) visitor designed to analyze Python code and resolve call relationships between functions, methods, and modules. It tracks the current execution context (such as class and function names) and records information about calls made within the code. It also maintains scope mappings for imports and tracks instance types to resolve qualified names for method calls. This class is primarily used during static analysis to understand how different parts of a codebase interact with one another.",
                "init_method": {
                    "description": "Initializes the CallResolverVisitor with a file path, project root directory, and a set of definitions. It sets up internal tracking structures such as scope, instance types, and call logs, and determines the module path based on the file path and project root.",
                    "parameters": [
                        {
                            "name": "filepath",
                            "type": "str",
                            "description": "The absolute path to the Python file being analyzed."
                        },
                        {
                            "name": "project_root",
                            "type": "str",
                            "description": "The root directory of the project, used to compute relative module paths."
                        },
                        {
                            "name": "definitions",
                            "type": "dict",
                            "description": "A dictionary mapping qualified names to their definitions, used to validate and resolve call targets."
                        }
                    ]
                },
                "methods": [
                    {
                        "identifier": "visit_ClassDef",
                        "description": {
                            "overall": "Handles the visitation of class definitions in the AST. It temporarily updates the current class name in the context before visiting child nodes and restores the previous class name afterward.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ClassDef",
                                    "description": "The AST node representing a class definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor mechanism when encountering a class definition node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_FunctionDef",
                        "description": {
                            "overall": "Handles the visitation of function definitions in the AST. It temporarily updates the current caller name to the function name before visiting child nodes and restores the previous caller name afterward.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.FunctionDef",
                                    "description": "The AST node representing a function definition."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor mechanism when encountering a function definition node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Call",
                        "description": {
                            "overall": "Processes call expressions in the AST. It resolves the qualified name of the called function and logs the call if the target is defined in the provided definitions. It distinguishes between module-level, function-level, and method-level callers to categorize the call appropriately.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Call",
                                    "description": "The AST node representing a function call expression."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method calls the private helper method `_resolve_call_qname` to determine the qualified name of the called function.",
                                "called_by": "This method is called by the generic AST visitor mechanism when encountering a call expression node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Import",
                        "description": {
                            "overall": "Handles import statements in the AST by updating the internal scope mapping to associate imported names with their actual module paths. This allows for proper resolution of names in later stages of analysis.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Import",
                                    "description": "The AST node representing an import statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor mechanism when encountering an import node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_ImportFrom",
                        "description": {
                            "overall": "Handles 'from ... import ...' statements in the AST. It computes the full module path for the imported items and updates the internal scope mapping accordingly, supporting both relative and absolute imports.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.ImportFrom",
                                    "description": "The AST node representing a 'from ... import ...' statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor mechanism when encountering an 'import from' node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "visit_Assign",
                        "description": {
                            "overall": "Processes assignment statements in the AST. Specifically, it identifies assignments where the right-hand side is a call to a known class constructor. It maps the assigned variable name to the qualified class name, enabling correct resolution of method calls on instances.",
                            "parameters": [
                                {
                                    "name": "node",
                                    "type": "ast.Assign",
                                    "description": "The AST node representing an assignment statement."
                                }
                            ],
                            "returns": [],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the generic AST visitor mechanism when encountering an assignment node."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "_resolve_call_qname",
                        "description": {
                            "overall": "A private helper method that resolves the qualified name of a function call. It handles both direct function names and attribute-based access (e.g., obj.method). It uses the internal scope and instance type mappings to derive fully qualified names.",
                            "parameters": [
                                {
                                    "name": "func_node",
                                    "type": "ast.AST",
                                    "description": "The AST node representing the function being called."
                                }
                            ],
                            "returns": [
                                {
                                    "name": "qualified_name",
                                    "type": "str or None",
                                    "description": "The fully qualified name of the function if resolved, otherwise None."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not explicitly call any other methods.",
                                "called_by": "This method is called by the `visit_Call` method to resolve the qualified name of a function call."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "No external dependencies are explicitly listed in the context.",
                    "instantiated_by": "This class is instantiated in the function `_resolve_calls` located in `relationship_analyzer.py` at line 92."
                }
            },
            "error": null
        },
        "schemas.types.ParameterDescription": {
            "identifier": "schemas.types.ParameterDescription",
            "description": {
                "overall": "The ParameterDescription class is a Pydantic BaseModel designed to represent and validate the structure of a single parameter within a function. It enforces that each parameter has a name, a type, and a description, making it suitable for documenting function signatures in a standardized way.",
                "init_method": {
                    "description": "The constructor initializes a ParameterDescription instance with three required fields: name, type, and description. These fields are defined as string types and are used to describe a function parameter.",
                    "parameters": [
                        {
                            "name": "name",
                            "type": "str",
                            "description": "The name of the function parameter."
                        },
                        {
                            "name": "type",
                            "type": "str",
                            "description": "The data type of the function parameter."
                        },
                        {
                            "name": "description",
                            "type": "str",
                            "description": "A textual description of the function parameter's purpose or usage."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those already imported.",
                    "instantiated_by": "This class is not instantiated by any other component as per the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ReturnDescription": {
            "identifier": "schemas.types.ReturnDescription",
            "description": {
                "overall": "The ReturnDescription class is a Pydantic model designed to represent and validate the description of a function's return value. It encapsulates three key pieces of information: the name of the return value, its type, and a textual description. This class ensures that any return value description adheres to a consistent structure and can be easily validated and serialized.",
                "init_method": {
                    "description": "Initializes a ReturnDescription instance with a name, type, and description. These fields are required and must be provided during instantiation.",
                    "parameters": [
                        {
                            "name": "name",
                            "type": "str",
                            "description": "The name of the return value."
                        },
                        {
                            "name": "type",
                            "type": "str",
                            "description": "The type of the return value."
                        },
                        {
                            "name": "description",
                            "type": "str",
                            "description": "A textual description of the return value."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
                    "instantiated_by": "This class is not instantiated by any other components as indicated by the context."
                }
            },
            "error": null
        },
        "schemas.types.UsageContext": {
            "identifier": "schemas.types.UsageContext",
            "description": {
                "overall": "The UsageContext class is a Pydantic model designed to describe the calling context of a function, capturing information about what functions are called and by whom. It serves as a structured representation of call relationships within a codebase, enabling better understanding and analysis of function interactions.",
                "init_method": {
                    "description": "Initializes a UsageContext instance with two string fields: 'calls' and 'called_by'. These fields represent the functions called by the current function and the function that calls the current function, respectively.",
                    "parameters": [
                        {
                            "name": "calls",
                            "type": "str",
                            "description": "A string describing the functions or methods that are called by the current function."
                        },
                        {
                            "name": "called_by",
                            "type": "str",
                            "description": "A string describing the function or method that calls the current function."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond its base Pydantic model.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.FunctionDescription": {
            "identifier": "schemas.types.FunctionDescription",
            "description": {
                "overall": "The FunctionDescription class is a Pydantic model designed to encapsulate detailed metadata about a function, including its overall purpose, parameter descriptions, return value details, and usage context. It serves as a structured representation for documenting function signatures and behaviors.",
                "init_method": {
                    "description": "Initializes a FunctionDescription instance with fields for overall function description, a list of parameter descriptions, a list of return value descriptions, and usage context information.",
                    "parameters": []
                },
                "methods": [
                    {
                        "identifier": "overall",
                        "description": {
                            "overall": "Represents the overall purpose and functionality of the function being described. This field captures a high-level summary of what the function does.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "overall",
                                    "type": "str",
                                    "description": "A string describing the overall purpose of the function."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "parameters",
                        "description": {
                            "overall": "Stores a list of ParameterDescription objects that detail each parameter accepted by the function, including their types, names, and descriptions.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "parameters",
                                    "type": "List[ParameterDescription]",
                                    "description": "A list of ParameterDescription objects detailing each function parameter."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "returns",
                        "description": {
                            "overall": "Holds a list of ReturnDescription objects that specify the return values of the function, including their types and descriptions.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "returns",
                                    "type": "List[ReturnDescription]",
                                    "description": "A list of ReturnDescription objects detailing the function's return values."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions."
                            }
                        },
                        "error": null
                    },
                    {
                        "identifier": "usage_context",
                        "description": {
                            "overall": "Provides contextual information about how the function is used, such as dependencies and instantiation points.",
                            "parameters": [],
                            "returns": [
                                {
                                    "name": "usage_context",
                                    "type": "UsageContext",
                                    "description": "An object containing usage-related metadata for the function."
                                }
                            ],
                            "usage_context": {
                                "calls": "This method does not call any other functions.",
                                "called_by": "This method is not called by any other functions."
                            }
                        },
                        "error": null
                    }
                ],
                "usage_context": {
                    "dependencies": "No external dependencies were identified for this class.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.FunctionAnalysis": {
            "identifier": "schemas.types.FunctionAnalysis",
            "description": {
                "overall": "The FunctionAnalysis class is a Pydantic model designed to represent the complete JSON schema for a function. It encapsulates essential information about a function including its unique identifier, a detailed description, and an optional error field. This class serves as a structured way to define and validate function metadata, making it suitable for use in systems that require standardized function representations.",
                "init_method": {
                    "description": "Initializes a FunctionAnalysis instance with an identifier, a FunctionDescription object, and an optional error string. The constructor sets up the basic structure required to represent a function's metadata.",
                    "parameters": [
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A unique string identifier for the function."
                        },
                        {
                            "name": "description",
                            "type": "FunctionDescription",
                            "description": "An object containing detailed information about the function's purpose, parameters, and behavior."
                        },
                        {
                            "name": "error",
                            "type": "Optional[str]",
                            "description": "An optional string field to store any error messages related to the function."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "No external dependencies are explicitly listed for this class.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ConstructorDescription": {
            "identifier": "schemas.types.ConstructorDescription",
            "description": {
                "overall": "The ConstructorDescription class is a Pydantic model designed to describe the initialization method (__init__) of a class. It encapsulates a textual description of the constructor's purpose and a list of parameters that the constructor accepts. This class serves as a structured representation for documenting constructor details, likely used in automated documentation or introspection systems.",
                "init_method": {
                    "description": "Initializes a ConstructorDescription instance with a description of the constructor and a list of parameter descriptions.",
                    "parameters": [
                        {
                            "name": "description",
                            "type": "str",
                            "description": "A textual description of the constructor's purpose."
                        },
                        {
                            "name": "parameters",
                            "type": "List[ParameterDescription]",
                            "description": "A list of ParameterDescription objects detailing each parameter accepted by the constructor."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those already imported in the file.",
                    "instantiated_by": "This class is not instantiated by any other components as per the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ClassContext": {
            "identifier": "schemas.types.ClassContext",
            "description": {
                "overall": "The ClassContext class is a Pydantic BaseModel designed to encapsulate metadata about a class's external dependencies and the entities that instantiate it. It serves as a structured representation of information typically used for documentation, introspection, or dependency tracking within a system.",
                "init_method": {
                    "description": "Initializes a ClassContext instance with two string attributes: 'dependencies' and 'instantiated_by'. These fields are intended to store descriptions or identifiers related to the class's external dependencies and instantiation sources.",
                    "parameters": [
                        {
                            "name": "dependencies",
                            "type": "str",
                            "description": "A string describing the external dependencies of the class."
                        },
                        {
                            "name": "instantiated_by",
                            "type": "str",
                            "description": "A string describing the entities or classes that instantiate this class."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ClassDescription": {
            "identifier": "schemas.types.ClassDescription",
            "description": {
                "overall": "The ClassDescription class is a Pydantic model designed to encapsulate a comprehensive analysis of a class. It holds information about the class's overall purpose, its constructor details, a list of its methods along with their descriptions, and contextual usage information. This structure serves as a standardized way to represent detailed metadata about a class within a documentation or analysis system.",
                "init_method": {
                    "description": "Initializes an instance of the ClassDescription model with specified attributes for overall purpose, constructor description, methods analysis, and usage context.",
                    "parameters": [
                        {
                            "name": "overall",
                            "type": "str",
                            "description": "A string describing the overall purpose and functionality of the class being analyzed."
                        },
                        {
                            "name": "init_method",
                            "type": "ConstructorDescription",
                            "description": "An object containing detailed information about the class's constructor, including its parameters and initialization logic."
                        },
                        {
                            "name": "methods",
                            "type": "List[FunctionAnalysis]",
                            "description": "A list of FunctionAnalysis objects, each representing a method within the class along with its description and metadata."
                        },
                        {
                            "name": "usage_context",
                            "type": "ClassContext",
                            "description": "An object providing contextual information about how the class is used, such as dependencies and instantiation points."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules or libraries beyond those specified in the imports.",
                    "instantiated_by": "This class is not instantiated by any other component within the provided context."
                }
            },
            "error": null
        },
        "schemas.types.ClassAnalysis": {
            "identifier": "schemas.types.ClassAnalysis",
            "description": {
                "overall": "The ClassAnalysis class serves as the primary data model for representing the complete JSON schema of a class. It encapsulates essential information about a class including its identifier, a detailed description, and an optional error field for capturing any issues during processing.",
                "init_method": {
                    "description": "Initializes a new instance of the ClassAnalysis class with required fields for the identifier and description, and an optional error field.",
                    "parameters": [
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string identifier for the class being analyzed."
                        },
                        {
                            "name": "description",
                            "type": "ClassDescription",
                            "description": "An instance of ClassDescription providing detailed metadata about the class."
                        },
                        {
                            "name": "error",
                            "type": "Optional[str]",
                            "description": "An optional string field to capture any errors encountered during class analysis."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those imported in the file.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.CallInfo": {
            "identifier": "schemas.types.CallInfo",
            "description": {
                "overall": "The CallInfo class represents a specific call event from the relationship analyzer, used to track information about function calls including the file, function name, call mode, and line number. It is a Pydantic BaseModel that enforces type safety and validation for these attributes.",
                "init_method": {
                    "description": "Initializes a CallInfo instance with file, function, mode, and line attributes. This constructor sets up the basic structure for tracking call events with required fields.",
                    "parameters": [
                        {
                            "name": "file",
                            "type": "str",
                            "description": "The file path where the call occurred."
                        },
                        {
                            "name": "function",
                            "type": "str",
                            "description": "The name of the function that made the call."
                        },
                        {
                            "name": "mode",
                            "type": "str",
                            "description": "The mode of the call, such as 'method', 'function', or 'module'."
                        },
                        {
                            "name": "line",
                            "type": "int",
                            "description": "The line number in the file where the call occurred."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "No external dependencies were specified for this class.",
                    "instantiated_by": "This class is not instantiated by any other components according to the provided context."
                }
            },
            "error": null
        },
        "schemas.types.FunctionContextInput": {
            "identifier": "schemas.types.FunctionContextInput",
            "description": {
                "overall": "The FunctionContextInput class is a Pydantic model designed to represent structured context for analyzing a function. It encapsulates two key pieces of information: a list of function calls made within the function and a list of CallInfo objects indicating which functions call this one. This model serves as a data transfer object to facilitate communication between different components of a system that evaluates or analyzes function behavior.",
                "init_method": {
                    "description": "Initializes the FunctionContextInput model with two fields: 'calls', a list of strings representing function names that are called within the analyzed function, and 'called_by', a list of CallInfo objects detailing which functions invoke the analyzed function.",
                    "parameters": [
                        {
                            "name": "calls",
                            "type": "List[str]",
                            "description": "A list of string identifiers representing the names of functions called within the analyzed function."
                        },
                        {
                            "name": "called_by",
                            "type": "List[CallInfo]",
                            "description": "A list of CallInfo objects describing the functions that call the analyzed function."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports list, which include standard typing constructs and pydantic BaseModel.",
                    "instantiated_by": "The class is instantiated in two locations: within the 'evaluation' function at line 162 of evaluation.py and in the 'main_workflow' function at line 216 of main.py."
                }
            },
            "error": null
        },
        "schemas.types.FunctionAnalysisInput": {
            "identifier": "schemas.types.FunctionAnalysisInput",
            "description": {
                "overall": "The FunctionAnalysisInput class serves as a structured input model for generating FunctionAnalysis objects. It encapsulates all necessary information including the mode of operation, identifier, source code, imports, and contextual data required for function analysis.",
                "init_method": {
                    "description": "Initializes the FunctionAnalysisInput instance with required fields including the mode, identifier, source code, imports list, and context object.",
                    "parameters": [
                        {
                            "name": "mode",
                            "type": "Literal[\"function_analysis\"]",
                            "description": "Specifies the mode of operation as 'function_analysis'."
                        },
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A unique identifier for the function being analyzed."
                        },
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "The raw source code of the function to be analyzed."
                        },
                        {
                            "name": "imports",
                            "type": "List[str]",
                            "description": "A list of import statements used in the function's source code."
                        },
                        {
                            "name": "context",
                            "type": "FunctionContextInput",
                            "description": "Contextual information about the function including its dependencies and usage."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports list.",
                    "instantiated_by": "The class is instantiated by the evaluation function in evaluation.py at line 167 and by the main_workflow function in main.py at line 221."
                }
            },
            "error": null
        },
        "schemas.types.MethodContextInput": {
            "identifier": "schemas.types.MethodContextInput",
            "description": {
                "overall": "The MethodContextInput class is a Pydantic model designed to structure contextual information about a method within a class. It encapsulates details such as the method's identifier, the methods it calls, the methods that call it, its arguments, and its docstring. This class serves as a standardized way to represent and pass around metadata related to method usage and dependencies.",
                "init_method": {
                    "description": "The class is initialized with a set of predefined fields including identifier, calls, called_by, args, and docstring. These fields are typed using Pydantic's type hints and optional types to enforce data integrity.",
                    "parameters": [
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string identifier for the method."
                        },
                        {
                            "name": "calls",
                            "type": "List[str]",
                            "description": "A list of strings representing the identifiers of methods called by this method."
                        },
                        {
                            "name": "called_by",
                            "type": "List[CallInfo]",
                            "description": "A list of CallInfo objects indicating which methods call this method."
                        },
                        {
                            "name": "args",
                            "type": "List[str]",
                            "description": "A list of strings representing the argument names of the method."
                        },
                        {
                            "name": "docstring",
                            "type": "Optional[str]",
                            "description": "An optional string containing the docstring of the method."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports.",
                    "instantiated_by": "This class is instantiated in the evaluation.py file within the evaluation function at line 187 and in the main.py file within the main_workflow function at line 241."
                }
            },
            "error": null
        },
        "schemas.types.ClassContextInput": {
            "identifier": "schemas.types.ClassContextInput",
            "description": {
                "overall": "The ClassContextInput class is a Pydantic model designed to encapsulate structured context information for analyzing a class. It holds three main pieces of data: a list of dependencies, a list of call information for instances where the class is instantiated, and a list of method context inputs. This model serves as a data transfer object to convey contextual metadata about a class during analysis.",
                "init_method": {
                    "description": "The constructor initializes the ClassContextInput model with three fields: dependencies, instantiated_by, and method_context. These fields are typed as List[str], List[CallInfo], and List[MethodContextInput] respectively, aligning with the Pydantic BaseModel structure.",
                    "parameters": [
                        {
                            "name": "dependencies",
                            "type": "List[str]",
                            "description": "A list of strings representing the dependencies of the class being analyzed."
                        },
                        {
                            "name": "instantiated_by",
                            "type": "List[CallInfo]",
                            "description": "A list of CallInfo objects detailing where and how the class is instantiated."
                        },
                        {
                            "name": "method_context",
                            "type": "List[MethodContextInput]",
                            "description": "A list of MethodContextInput objects describing the context of methods within the class."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond standard typing and pydantic.BaseModel.",
                    "instantiated_by": "The class is instantiated by the functions 'main_orchestrator' in HelperLLM.py at line 369, 'evaluation' in evaluation.py at line 199, and 'main_workflow' in main.py at line 253."
                }
            },
            "error": null
        },
        "schemas.types.ClassAnalysisInput": {
            "identifier": "schemas.types.ClassAnalysisInput",
            "description": {
                "overall": "The ClassAnalysisInput class serves as a structured input model for generating a ClassAnalysis object. It encapsulates all necessary information required for performing a detailed analysis of a Python class, including the class's source code, its identifier, associated imports, and contextual metadata.",
                "init_method": {
                    "description": "Initializes the ClassAnalysisInput instance with fields representing the mode of analysis, the class identifier, the source code of the class, a list of import statements, and contextual information.",
                    "parameters": [
                        {
                            "name": "mode",
                            "type": "Literal[\"class_analysis\"]",
                            "description": "A literal string indicating the mode of analysis, specifically set to \"class_analysis\"."
                        },
                        {
                            "name": "identifier",
                            "type": "str",
                            "description": "A string representing the name of the class being analyzed."
                        },
                        {
                            "name": "source_code",
                            "type": "str",
                            "description": "A string containing the complete source code of the class under analysis."
                        },
                        {
                            "name": "imports",
                            "type": "List[str]",
                            "description": "A list of strings representing the import statements used in the file containing the class."
                        },
                        {
                            "name": "context",
                            "type": "ClassContextInput",
                            "description": "An object containing contextual metadata about the class, such as dependencies and instantiation details."
                        }
                    ]
                },
                "methods": [],
                "usage_context": {
                    "dependencies": "This class does not depend on any external modules beyond those specified in the imports list.",
                    "instantiated_by": "The class is instantiated by the main_orchestrator function in HelperLLM.py at line 338, the evaluation function in evaluation.py at line 205, and the main_workflow function in main.py at line 259."
                }
            },
            "error": null
        }
    }
}