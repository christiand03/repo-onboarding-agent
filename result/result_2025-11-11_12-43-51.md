['[!!] **WARNING: ANALYSIS INCOMPLETE**\nThis documentation may be incomplete due to errors encountered during repository analysis or because certain information could not be located. Sections with missing data are marked accordingly.\n\n# Project Documentation: repo-onboarding-agent\n\n## 1. Project Overview\n- **Description:** Weitere Schritte folgen...\n- **Key Features:** \n  - [Information not found]\n- **Tech Stack:** [Information not found]\n\n## 2. Architecture\n### Repository Structure', '```mermaid\ngraph TD\n    A[repo-onboarding-agent] --> B[.env.example]\n    A --> C[.gitignore]\n    A --> D[SystemPrompts]\n    D --> D1[SystemPromptHelperLLM.txt]\n    D --> D2[SystemPromptMainLLM.txt]\n    A --> E[backend]\n    E --> E1[AST.py]\n    E --> E2[HelperLLM.py]\n    E --> E3[basic_info.py]\n    E --> E4[callgraph.py]\n    E --> E5[getRepo.py]\n    E --> E6[main.py]\n    E --> E7[tool.py]\n    A --> F[frontend]\n    F --> F1[Frontend.py]\n    A --> G[notizen]\n    G --> G1[doc_bestandteile.md]\n    G --> G2[notizen.md]\n    G --> G3[paul_notizen.md]\n    G --> G4[praesentation_notizen.md]\n    G --> G5[technische_notizen.md]\n    A --> H[readme.md]\n    A --> I[requirements.txt]\n    A --> J[schemas]\n    J --> J1[types.py]\n```', '\n\n### Repository Call Graph', '```mermaid\ngraph TD\n    subgraph backend/AST.py\n        analyze_repository["analyze_repository"]\n        visit_ClassDef["visit_ClassDef"]\n        visit_Import["visit_Import"]\n        visit_ImportFrom["visit_ImportFrom"]\n    end\n    subgraph backend/HelperLLM.py\n        __init__["__init__"]\n        _call_llm_and_parse["_call_llm_and_parse"]\n        generate_for_class["generate_for_class"]\n        generate_for_function["generate_for_function"]\n        main_orchestrator["main_orchestrator"]\n    end\n    subgraph backend/basic_info.py\n        _extrahiere_sektion_aus_markdown["_extrahiere_sektion_aus_markdown"]\n        _finde_datei["_finde_datei"]\n        _parse_readme["_parse_readme"]\n        _parse_requirements["_parse_requirements"]\n        _parse_toml["_parse_toml"]\n        extrahiere_info["extrahiere_info"]\n    end\n    subgraph backend/callgraph.py\n        build_callGraph["build_callGraph"]\n        graph_to_adj_list["graph_to_adj_list"]\n        visit_AsyncFunctionDef["visit_AsyncFunctionDef"]\n        visit_Call["visit_Call"]\n        visit_FunctionDef["visit_FunctionDef"]\n        visit_If["visit_If"]\n    end\n    subgraph backend/getRepo.py\n        __exit__["__exit__"]\n        __init__init["__init__"]\n        _traverse_tree["_traverse_tree"]\n        analyze_word_count["analyze_word_count"]\n        blob["blob"]\n        close["close"]\n        content["content"]\n        get_all_files["get_all_files"]\n        get_file_tree["get_file_tree"]\n    end\n    subgraph backend/main.py\n        print_basic_info["print_basic_info"]\n        print_tree_view["print_tree_view"]\n    end\n    subgraph backend/tool.py\n        analyze_repository_tool["analyze_repository"]\n        simplify_tree["simplify_tree"]\n    end\n    subgraph frontend/Frontend.py\n        frontend_module["<frontend/Frontend.py>"]\n    end\n    subgraph schemas/types.py\n        types_module["<schemas/types.py>"]\n    end\n\n    analyze_repository --> PythonASTVisitor\n    analyze_repository --> endswith\n    analyze_repository --> parse\n    analyze_repository --> print\n    analyze_repository --> strip\n    analyze_repository --> visit\n    visit_ClassDef --> isinstance\n    visit_ClassDef --> iter_child_nodes\n    visit_Import --> append\n    visit_Import --> generic_visit\n    visit_ImportFrom --> append\n    visit_ImportFrom --> generic_visit\n    __init__ --> ChatGoogleGenerativeAI\n    __init__ --> ValueError\n    __init__ --> error\n    __init__ --> info\n    __init__ --> open\n    __init__ --> read\n    _call_llm_and_parse --> HumanMessage\n    _call_llm_and_parse --> SystemMessage\n    _call_llm_and_parse --> debug\n    _call_llm_and_parse --> error\n    _call_llm_and_parse --> info\n    _call_llm_and_parse --> invoke\n    _call_llm_and_parse --> loads\n    generate_for_class --> _call_llm_and_parse\n    generate_for_class --> dumps\n    generate_for_class --> error\n    generate_for_class --> model_dump\n    generate_for_class --> model_validate\n    generate_for_class --> warning\n    generate_for_function --> _call_llm_and_parse\n    generate_for_function --> dumps\n    generate_for_function --> error\n    generate_for_function --> model_dump\n    generate_for_function --> model_validate\n    generate_for_function --> warning\n    main_orchestrator --> ClassContextInput\n    main_orchestrator --> FunctionContextInput\n    main_orchestrator --> LLMHelper\n    main_orchestrator --> dumps\n    main_orchestrator --> generate_for_class\n    main_orchestrator --> generate_for_function\n    main_orchestrator --> info\n    main_orchestrator --> print\n    main_orchestrator --> warning\n    _extrahiere_sektion_aus_markdown --> compile\n    _extrahiere_sektion_aus_markdown --> escape\n    _extrahiere_sektion_aus_markdown --> group\n    _extrahiere_sektion_aus_markdown --> join\n    _extrahiere_sektion_aus_markdown --> search\n    _extrahiere_sektion_aus_markdown --> strip\n    _finde_datei --> endswith\n    _finde_datei --> lower\n    _parse_readme --> _extrahiere_sektion_aus_markdown\n    _parse_readme --> group\n    _parse_readme --> search\n    _parse_readme --> split\n    _parse_readme --> strip\n    _parse_requirements --> splitlines\n    _parse_requirements --> startswith\n    _parse_requirements --> strip\n    _parse_toml --> get\n    _parse_toml --> loads\n    _parse_toml --> print\n    extrahiere_info --> _finde_datei\n    extrahiere_info --> _parse_readme\n    extrahiere_info --> _parse_requirements\n    extrahiere_info --> _parse_toml\n    extrahiere_info --> basename\n    extrahiere_info --> isinstance\n    extrahiere_info --> join\n    extrahiere_info --> removesuffix\n    graph_to_adj_list --> list\n    graph_to_adj_list --> nodes\n    graph_to_adj_list --> sorted\n    graph_to_adj_list --> successors\n    visit_AsyncFunctionDef --> add_node\n    visit_AsyncFunctionDef --> generic_visit\n    visit_Call --> add\n    visit_Call --> dump\n    visit_Call --> generic_visit\n    visit_Call --> get_source_segment\n    visit_Call --> getattr\n    visit_Call --> hasattr\n    visit_Call --> isinstance\n    visit_Call --> print\n    visit_Call --> type\n    visit_FunctionDef --> add_node\n    visit_FunctionDef --> generic_visit\n    visit_If --> generic_visit\n    visit_If --> isinstance\n    __exit__ --> close\n    __init__init --> RuntimeError\n    __init__init --> clone_from\n    __init__init --> close\n    __init__init --> mkdtemp\n    __init__init --> print\n    _traverse_tree --> RepoFile\n    _traverse_tree --> _traverse_tree\n    analyze_word_count --> len\n    analyze_word_count --> split\n    get_all_files --> RepoFile\n    get_all_files --> ls_files\n    get_all_files --> split\n    get_file_tree --> _traverse_tree\n    print_basic_info --> get\n    print_basic_info --> print\n    print_tree_view --> enumerate\n    print_tree_view --> isinstance\n    print_tree_view --> items\n    print_tree_view --> len\n    print_tree_view --> print\n    print_tree_view --> print_tree_view\n    print_tree_view --> sorted\n    analyze_repository_tool --> GitRepository\n    analyze_repository_tool --> ProjektInfoExtractor\n    analyze_repository_tool --> basename\n    analyze_repository_tool --> extrahiere_info\n    analyze_repository_tool --> get_all_files\n    analyze_repository_tool --> get_file_tree\n    analyze_repository_tool --> print\n    analyze_repository_tool --> removesuffix\n    simplify_tree --> isinstance\n    simplify_tree --> items\n    simplify_tree --> simplify_tree\n    \n    subgraph backend/HelperLLM.py (main_block)\n        <main_block>["<main_block>"]\n    end\n    <main_block> --> main_orchestrator\n    <main_block> --> print\n    \n    subgraph backend/main.py (main_block)\n        <main_block>_2["<main_block>"]\n    end\n    <main_block>_2 --> ASTAnalyzer\n    <main_block>_2 --> GitRepository\n    <main_block>_2 --> ProjektInfoExtractor\n    <main_block>_2 --> analyze_repository_tool\n    <main_block>_2 --> basename\n    <main_block>_2 --> build_callGraph\n    <main_block>_2 --> endswith\n    <main_block>_2 --> extrahiere_info\n    <main_block>_2 --> get_all_files\n    <main_block>_2 --> get_file_tree\n    <main_block>_2 --> graph_to_adj_list\n    <main_block>_2 --> len\n    <main_block>_2 --> parse\n    <main_block>_2 --> print\n    <main_block>_2 --> print_basic_info\n    <main_block>_2 --> print_tree_view\n    <main_block>_2 --> removesuffix\n    \n    subgraph backend/tool.py (main_block)\n        <main_block>_3["<main_block>"]\n    end\n    <main_block>_3 --> analyze_repository_tool\n    <main_block>_3 --> dumps\n    <main_block>_3 --> get\n    <main_block>_3 --> iter\n    <main_block>_3 --> model_validate\n    <main_block>_3 --> next\n    <main_block>_3 --> print\n    \n    subgraph backend/HelperLLM.py (Module)\n        <backend/HelperLLM.py>["<backend/HelperLLM.py>"]\n    end\n    <backend/HelperLLM.py> --> basicConfig\n    <backend/HelperLLM.py> --> getenv\n    <backend/HelperLLM.py> --> load_dotenv\n    \n    subgraph backend/callgraph.py (Module)\n        <backend/callgraph.py>["<backend/callgraph.py>"]\n    end\n    <backend/callgraph.py> --> CallGraph\n    <backend/callgraph.py> --> add_edge\n    <backend/callgraph.py> --> items\n    <backend/callgraph.py> --> visit\n    \n    subgraph backend/tool.py (Module)\n        <backend/tool.py>["<backend/tool.py>"]\n    end\n    <backend/tool.py> --> ASTAnalyzer\n    <backend/tool.py> --> analyze_repository_tool\n    <backend/tool.py> --> build_callGraph\n    <backend/tool.py> --> endswith\n    <backend/tool.py> --> graph_to_adj_list\n    <backend/tool.py> --> parse\n    <backend/tool.py> --> print\n    <backend/tool.py> --> simplify_tree\n    <backend/tool.py> --> str\n```', "\n\n## 3. Installation\n### Dependencies\n`pip install -r requirements.txt`\n### Setup Guide\n[Information not found]\n### Quick Startup\n[Information not found]\n\n## 4. Use Cases & Commands\nThe repository appears to be an internal agent for analyzing and documenting other Git repositories. The primary use cases are inferred to be:\n1. **Repository Cloning and Traversal:** Using `backend/getRepo.py` to clone a given URL and iterate through its file structure.\n2. **Static Analysis:** Applying AST parsing and Call Graph generation (`backend/AST.py`, `backend/callgraph.py`) to understand the repository's code structure.\n3. **Information Extraction:** Parsing standard files like `README`, `requirements.txt`, and `pyproject.toml` (`backend/basic_info.py`).\n4. **LLM Integration:** Utilizing the `backend/HelperLLM.py` to generate descriptions for functions and classes based on their context.\n5. **Tool Orchestration:** The `backend/tool.py` seems to be the main orchestrator providing the `analyze_repository` function for external use, likely for a larger agent system or API.\n\n**Primary Commands (Inferred):**\nThe project is likely run via one of the main entry points (`backend/main.py` or `backend/tool.py` if used as a library).\n- To run the analysis tool (if exposed): `python backend/tool.py <repo_url>` (Hypothetical, based on module structure)\n- To run the main module for local testing: `python backend/main.py` (Hypothetical)\n\n## 5. Function & Class Reference\n### File: `backend/AST.py`\n**Function: `analyze_repository`**\n- **Signature:**\n  ", '```python\n  def analyze_repository(repo: GitRepository, all_py_files: list[RepoFile], helper: LLMHelper):\n  ```', "\n- **Description:** This function iterates over all Python files in the repository. For each file, it parses the content into an Abstract Syntax Tree (AST) and then uses the `PythonASTVisitor` to extract classes and functions, generating descriptions for them using the provided `LLMHelper`.\n- **Parameters:**\n  - `repo` (GitRepository): The object representing the cloned Git repository.\n  - `all_py_files` (list[RepoFile]): A list of all Python files found in the repository.\n  - `helper` (LLMHelper): The LLM helper object used for generating descriptions.\n- **Returns:** \n  - 'dict' (dict) [A dictionary containing the structured AST analysis, including classes and functions for each Python file.]\n- **Calls:** [`PythonASTVisitor`, `endswith`, `parse`, `print`, `strip`, `visit`]\n- **Called By:** [`analyze_repository`]\n\n**Class: `PythonASTVisitor`**\n*Description: A specialized AST visitor that traverses the Python source code tree to identify and extract definitions for classes and functions, preparing them for analysis and documentation.*\n\n**Function: `visit_ClassDef`**\n- **Signature:**\n  ", '```python\n  def visit_ClassDef(self, node):\n  ```', "\n- **Description:** Visits a ClassDef node in the AST, records the class name and its properties, and recursively visits its child nodes.\n- **Parameters:**\n  - `node` (ClassDef): The AST node representing the class definition.\n- **Returns:** \n  - 'None' (None) [Returns None, as the changes are made to the internal state of the visitor.]\n- **Calls:** [`isinstance`, `iter_child_nodes`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `visit_Import`**\n- **Signature:**\n  ", '```python\n  def visit_Import(self, node):\n  ```', "\n- **Description:** Visits an Import node and records the imported module names.\n- **Parameters:**\n  - `node` (Import): The AST node for a simple import statement.\n- **Returns:** \n  - 'None' (None) [Returns None.]\n- **Calls:** [`append`, `generic_visit`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `visit_ImportFrom`**\n- **Signature:**\n  ", '```python\n  def visit_ImportFrom(self, node):\n  ```', "\n- **Description:** Visits an ImportFrom node and records the imported items from a specific module.\n- **Parameters:**\n  - `node` (ImportFrom): The AST node for a 'from module import item' statement.\n- **Returns:** \n  - 'None' (None) [Returns None.]\n- **Calls:** [`append`, `generic_visit`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n---\n### File: `backend/HelperLLM.py`\n**Class: `LLMHelper`**\n*Description: A class that encapsulates the logic for interacting with a Language Model (LLM) to generate structured descriptions and documentation for functions and classes extracted from a code base.*\n\n**Function: `__init__`**\n- **Signature:**\n  ", '```python\n  def __init__(self, system_prompt_path: str, model_name: str = "gemini-2.5-flash"):\n  ```', '\n- **Description:** Initializes the LLMHelper, setting up the model and loading the system prompt from the specified path.\n- **Parameters:**\n  - `system_prompt_path` (str): Path to the text file containing the system prompt for the LLM.\n  - `model_name` (str): The name of the model to use (defaults to "gemini-2.5-flash").\n- **Returns:** \n  - \'None\' (None) [Constructor returns nothing.]\n- **Calls:** [`ChatGoogleGenerativeAI`, `ValueError`, `error`, `info`, `open`, `read`]\n- **Called By:** [`main_orchestrator`]\n\n**Function: `_call_llm_and_parse`**\n- **Signature:**\n  ', '```python\n  def _call_llm_and_parse(self, input_context: BaseModel, response_schema: type[BaseModel]) -> BaseModel:\n  ```', "\n- **Description:** An internal helper method that constructs the LLM call with system/user messages, invokes the LLM, and parses the JSON response into the specified Pydantic schema.\n- **Parameters:**\n  - `input_context` (BaseModel): The Pydantic model containing the context (code snippet, file name) for the LLM.\n  - `response_schema` (type[BaseModel]): The expected Pydantic schema for the LLM's structured output.\n- **Returns:** \n  - 'BaseModel' (BaseModel) [An instance of the Pydantic response schema populated with data from the LLM.]\n- **Calls:** [`HumanMessage`, `SystemMessage`, `debug`, `error`, `info`, `invoke`, `loads`]\n- **Called By:** [`generate_for_class`, `generate_for_function`]\n\n**Function: `generate_for_function`**\n- **Signature:**\n  ", '```python\n  def generate_for_function(self, function_context: FunctionContextInput) -> FunctionContextOutput:\n  ```', "\n- **Description:** Generates a structured description for a given function using the LLM.\n- **Parameters:**\n  - `function_context` (FunctionContextInput): The context containing function code, signature, and surrounding file context.\n- **Returns:** \n  - 'FunctionContextOutput' (FunctionContextOutput) [The structured output from the LLM, including a description, parameters, and return information.]\n- **Calls:** [`_call_llm_and_parse`, `dumps`, `error`, `model_dump`, `model_validate`, `warning`]\n- **Called By:** [`main_orchestrator`]\n\n**Function: `generate_for_class`**\n- **Signature:**\n  ", '```python\n  def generate_for_class(self, class_context: ClassContextInput) -> ClassContextOutput:\n  ```', "\n- **Description:** Generates a structured description for a given class using the LLM.\n- **Parameters:**\n  - `class_context` (ClassContextInput): The context containing class code and surrounding file context.\n- **Returns:** \n  - 'ClassContextOutput' (ClassContextOutput) [The structured output from the LLM, including a class description.]\n- **Calls:** [`_call_llm_and_parse`, `dumps`, `error`, `model_dump`, `model_validate`, `warning`]\n- **Called By:** [`main_orchestrator`]\n\n**Function: `main_orchestrator`**\n- **Signature:**\n  ", '```python\n  def main_orchestrator():\n  ```', "\n- **Description:** [Could not be determined from the source code.]\n- **Parameters:**\n  - `[No Parameters Found]`\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`ClassContextInput`, `FunctionContextInput`, `LLMHelper`, `dumps`, `generate_for_class`, `generate_for_function`, `info`, `print`, `warning`]\n- **Called By:** [`<main_block>`]\n\n---\n### File: `backend/basic_info.py`\n**Function: `_extrahiere_sektion_aus_markdown`**\n- **Signature:**\n  ", '```python\n  def _extrahiere_sektion_aus_markdown(readme_inhalt: str, sektion_name: str) -> str | None:\n  ```', '\n- **Description:** Extracts the content of a specific section from a Markdown file (like a README), identified by its heading. It is case-insensitive and stops at the next heading.\n- **Parameters:**\n  - `readme_inhalt` (str): The full content of the Markdown file.\n  - `sektion_name` (str): The name of the section heading to extract (e.g., "Installation").\n- **Returns:** \n  - \'str | None\' (str | None) [The content of the section as a single string, or None if the section is not found.]\n- **Calls:** [`compile`, `escape`, `group`, `join`, `search`, `strip`]\n- **Called By:** [`_parse_readme`]\n\n**Function: `_finde_datei`**\n- **Signature:**\n  ', '```python\n  def _finde_datei(files: list[RepoFile], datei_name_teil: str) -> RepoFile | None:\n  ```', '\n- **Description:** Searches a list of repository files for a file whose name contains a specified substring (case-insensitive).\n- **Parameters:**\n  - `files` (list[RepoFile]): A list of file objects in the repository.\n  - `datei_name_teil` (str): The part of the file name to search for (e.g., "requirements").\n- **Returns:** \n  - \'RepoFile | None\' (RepoFile | None) [The first matching `RepoFile` object, or None if no match is found.]\n- **Calls:** [`endswith`, `lower`]\n- **Called By:** [`extrahiere_info`]\n\n**Function: `_parse_readme`**\n- **Signature:**\n  ', '```python\n  def _parse_readme(readme_inhalt: str) -> Dict[str, Any]:\n  ```', "\n- **Description:** Parses the content of a README file to extract a high-level description, installation steps, and key features.\n- **Parameters:**\n  - `readme_inhalt` (str): The full text content of the README file.\n- **Returns:** \n  - 'Dict[str, Any]' (Dict[str, Any]) [A dictionary containing extracted `beschreibung`, `setup_anleitung`, and `quick_start_guide`.]\n- **Calls:** [`_extrahiere_sektion_aus_markdown`, `group`, `search`, `split`, `strip`]\n- **Called By:** [`extrahiere_info`]\n\n**Function: `_parse_requirements`**\n- **Signature:**\n  ", '```python\n  def _parse_requirements(inhalt: str) -> list[str]:\n  ```', "\n- **Description:** Parses the content of a `requirements.txt` file to extract a list of dependencies. It filters out comments and empty lines.\n- **Parameters:**\n  - `inhalt` (str): The content of the `requirements.txt` file.\n- **Returns:** \n  - 'list[str]' (list[str]) [A list of dependency strings.]\n- **Calls:** [`splitlines`, `startswith`, `strip`]\n- **Called By:** [`extrahiere_info`]\n\n**Function: `_parse_toml`**\n- **Signature:**\n  ", '```python\n  def _parse_toml(inhalt: str) -> dict[str, Any]:\n  ```', "\n- **Description:** Parses the content of a TOML file (like `pyproject.toml`) to extract information, specifically looking for `tool.poetry.dependencies`.\n- **Parameters:**\n  - `inhalt` (str): The content of the TOML file.\n- **Returns:** \n  - 'dict[str, Any]' (dict[str, Any]) [A dictionary containing extracted dependencies, or an empty dict if parsing fails.]\n- **Calls:** [`get`, `loads`, `print`]\n- **Called By:** [`extrahiere_info`]\n\n**Function: `extrahiere_info`**\n- **Signature:**\n  ", '```python\n  def extrahiere_info(repo: GitRepository) -> Dict[str, Any]:\n  ```', "\n- **Description:** The main function for extracting basic project information by searching for and parsing files like `README.md`, `requirements.txt`, and `pyproject.toml`.\n- **Parameters:**\n  - `repo` (GitRepository): The object representing the cloned Git repository.\n- **Returns:** \n  - 'Dict[str, Any]' (Dict[str, Any]) [A consolidated dictionary of project overview and installation details.]\n- **Calls:** [`_finde_datei`, `_parse_readme`, `_parse_requirements`, `_parse_toml`, `basename`, `isinstance`, `join`, `removesuffix`]\n- **Called By:** [`analyze_repository`]\n\n---\n### File: `backend/callgraph.py`\n**Class: `CallGraph`**\n*Description: An AST visitor that generates a directed graph representing the function call relationships within a single Python file.*\n\n**Function: `build_callGraph`**\n- **Signature:**\n  ", '```python\n  def build_callGraph(py_file: str, file_content: str, module_path: str) -> DiGraph:\n  ```', "\n- **Description:** Parses the content of a Python file into an AST and uses the `CallGraph` visitor to generate a NetworkX directed graph representing function calls.\n- **Parameters:**\n  - `py_file` (str): The path to the Python file being analyzed.\n  - `file_content` (str): The source code content of the Python file.\n  - `module_path` (str): The module path (e.g., `backend.module`) for generating unique node IDs.\n- **Returns:** \n  - 'DiGraph' (DiGraph) [A NetworkX Directed Graph object.]\n- **Calls:** [`DiGraph`]\n- **Called By:** [`analyze_repository`]\n\n**Function: `graph_to_adj_list`**\n- **Signature:**\n  ", '```python\n  def graph_to_adj_list(graph: DiGraph) -> dict:\n  ```', "\n- **Description:** Converts a NetworkX directed graph into a simplified adjacency list representation (dictionary) where keys are nodes (functions/classes) and values are lists of nodes they call.\n- **Parameters:**\n  - `graph` (DiGraph): The NetworkX directed graph object.\n- **Returns:** \n  - 'dict' (dict) [An adjacency list mapping a caller to a list of callees.]\n- **Calls:** [`list`, `nodes`, `sorted`, `successors`]\n- **Called By:** [`analyze_repository`]\n\n**Function: `visit_AsyncFunctionDef`**\n- **Signature:**\n  ", '```python\n  def visit_AsyncFunctionDef(self, node):\n  ```', "\n- **Description:** Visits an asynchronous function definition node, registers it as a node in the graph, and continues to visit its body for internal calls.\n- **Parameters:**\n  - `node` (AsyncFunctionDef): The AST node for an async function.\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`add_node`, `generic_visit`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `visit_Call`**\n- **Signature:**\n  ", '```python\n  def visit_Call(self, node):\n  ```', "\n- **Description:** Visits a function call node, attempts to determine the name of the called function, and adds an edge from the current function to the called function in the graph.\n- **Parameters:**\n  - `node` (Call): The AST node representing a function call.\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`add`, `dump`, `generic_visit`, `get_source_segment`, `getattr`, `hasattr`, `isinstance`, `print`, `type`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `visit_FunctionDef`**\n- **Signature:**\n  ", '```python\n  def visit_FunctionDef(self, node):\n  ```', "\n- **Description:** Visits a function definition node, registers it as a node in the graph, and continues to visit its body for internal calls.\n- **Parameters:**\n  - `node` (FunctionDef): The AST node for a standard function definition.\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`add_node`, `generic_visit`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `visit_If`**\n- **Signature:**\n  ", '```python\n  def visit_If(self, node):\n  ```', '\n- **Description:** Visits an If statement, primarily to check for the standard `if __name__ == "__main__":` block to register the module\'s main execution block in the graph.\n- **Parameters:**\n  - `node` (If): The AST node for an If statement.\n- **Returns:** \n  - \'None\' (None) [Returns nothing.]\n- **Calls:** [`generic_visit`, `isinstance`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n---\n### File: `backend/getRepo.py`\n**Class: `GitRepository`**\n*Description: A context manager class designed to clone a Git repository into a temporary directory, provide methods for file access and analysis, and automatically clean up the directory upon exit.*\n\n**Function: `__init__`**\n- **Signature:**\n  ', '```python\n  def __init__(self, repo_url: str):\n  ```', "\n- **Description:** Initializes the repository object by creating a temporary directory and attempting to clone the repository from the provided URL.\n- **Parameters:**\n  - `repo_url` (str): The URL of the Git repository to clone.\n- **Returns:** \n  - 'None' (None) [Constructor returns nothing.]\n- **Calls:** [`RuntimeError`, `clone_from`, `close`, `mkdtemp`, `print`]\n- **Called By:** [`analyze_repository`]\n\n**Function: `__exit__`**\n- **Signature:**\n  ", '```python\n  def __exit__(self, exc_type, exc_val, exc_tb):\n  ```', "\n- **Description:** Context manager exit method. It ensures the repository object is closed and the temporary directory is cleaned up, even if an exception occurred.\n- **Parameters:**\n  - `exc_type` (type): The type of exception raised.\n  - `exc_val` (Exception): The exception instance.\n  - `exc_tb` (Traceback): The traceback object.\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`close`]\n- **Called By:** [`[Context Manager Exit]`]\n\n**Function: `_traverse_tree`**\n- **Signature:**\n  ", '```python\n  def _traverse_tree(self, path: Path, tree_dict: dict):\n  ```', "\n- **Description:** Recursively traverses the repository's file system, starting from the given path, and builds a dictionary representation of the file tree.\n- **Parameters:**\n  - `path` (Path): The current path in the repository to traverse.\n  - `tree_dict` (dict): The dictionary being built, representing the file tree structure.\n- **Returns:** \n  - 'None' (None) [The function updates `tree_dict` in place.]\n- **Calls:** [`RepoFile`, `_traverse_tree`]\n- **Called By:** [`get_file_tree`, `_traverse_tree`]\n\n**Function: `analyze_word_count`**\n- **Signature:**\n  ", '```python\n  def analyze_word_count(self) -> int:\n  ```', "\n- **Description:** Calculates the total number of words in all files within the repository.\n- **Parameters:**\n  - `[No Parameters Found]`\n- **Returns:** \n  - 'int' (int) [The total word count.]\n- **Calls:** [`len`, `split`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `blob`**\n- **Signature:**\n  ", '```python\n  def blob(self, file_path: str) -> bytes | None:\n  ```', "\n- **Description:** Reads and returns the raw binary content of a specific file in the repository.\n- **Parameters:**\n  - `file_path` (str): The path to the file relative to the repository root.\n- **Returns:** \n  - 'bytes | None' (bytes | None) [The binary content of the file, or None if the file is not found.]\n- **Calls:** [`FileNotFoundError`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `close`**\n- **Signature:**\n  ", '```python\n  def close(self):\n  ```', "\n- **Description:** Explicitly closes the repository object and removes the temporary working directory.\n- **Parameters:**\n  - `[No Parameters Found]`\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`print`]\n- **Called By:** [`__init__`, `__exit__`]\n\n**Function: `content`**\n- **Signature:**\n  ", '```python\n  def content(self, file_path: str) -> str | None:\n  ```', "\n- **Description:** Reads and returns the content of a file as a string, assuming it is UTF-8 encoded.\n- **Parameters:**\n  - `file_path` (str): The path to the file relative to the repository root.\n- **Returns:** \n  - 'str | None' (str | None) [The decoded string content of the file, or None if the file is not readable or does not exist.]\n- **Calls:** [`decode`, `read`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n**Function: `get_all_files`**\n- **Signature:**\n  ", '```python\n  def get_all_files(self) -> list[RepoFile]:\n  ```', "\n- **Description:** Retrieves a flat list of all files present in the repository, excluding the `.git` directory.\n- **Parameters:**\n  - `[No Parameters Found]`\n- **Returns:** \n  - 'list[RepoFile]' (list[RepoFile]) [A list of `RepoFile` objects for every file.]\n- **Calls:** [`RepoFile`, `ls_files`, `split`]\n- **Called By:** [`analyze_repository`, `<main_block>`]\n\n**Function: `get_file_tree`**\n- **Signature:**\n  ", '```python\n  def get_file_tree(self) -> dict:\n  ```', "\n- **Description:** Generates a hierarchical dictionary representing the directory and file structure of the repository.\n- **Parameters:**\n  - `[No Parameters Found]`\n- **Returns:** \n  - 'dict' (dict) [A dictionary structure of the file tree.]\n- **Calls:** [`_traverse_tree`]\n- **Called By:** [`analyze_repository`, `<main_block>`]\n\n---\n### File: `backend/main.py`\n**Function: `print_basic_info`**\n- **Signature:**\n  ", '```python\n  def print_basic_info(basic_info: dict):\n  ```', "\n- **Description:** Utility function to print the extracted basic project information in a structured, readable format to the console.\n- **Parameters:**\n  - `basic_info` (dict): The dictionary containing project overview and installation details.\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`get`, `print`]\n- **Called By:** [`<main_block>`]\n\n**Function: `print_tree_view`**\n- **Signature:**\n  ", '```python\n  def print_tree_view(tree: dict, prefix: str = "", is_last: bool = False):\n  ```', "\n- **Description:** Recursively prints the file tree structure of the repository to the console using a graphical ASCII format.\n- **Parameters:**\n  - `tree` (dict): The file tree dictionary to print.\n  - `prefix` (str): The string prefix used for indentation and lines.\n  - `is_last` (bool): Flag indicating if the current item is the last one in its parent directory.\n- **Returns:** \n  - 'None' (None) [Returns nothing.]\n- **Calls:** [`enumerate`, `isinstance`, `items`, `len`, `print`, `print_tree_view`, `sorted`]\n- **Called By:** [`print_tree_view`, `<main_block>`]\n\n---\n### File: `backend/tool.py`\n**Function: `analyze_repository`**\n- **Signature:**\n  ", '```python\n  def analyze_repository(repo_url: str) -> tuple[dict | None, dict]:\n  ```', "\n- **Description:** The primary external function of the tool. It orchestrates the entire analysis workflow: clones the repo, extracts basic info, performs AST/call graph analysis, and returns the consolidated results.\n- **Parameters:**\n  - `repo_url` (str): The URL of the Git repository to be analyzed.\n- **Returns:** \n  - 'tuple[dict | None, dict]' (tuple[dict | None, dict]) [A tuple containing the analysis dictionary and a self-descriptive dictionary for validation.]\n- **Calls:** [`GitRepository`, `ProjektInfoExtractor`, `basename`, `extrahiere_info`, `get_all_files`, `get_file_tree`, `print`, `removesuffix`]\n- **Called By:** [`<main_block>`, `main_script`, `api_endpoint`]\n\n**Function: `simplify_tree`**\n- **Signature:**\n  ", '```python\n  def simplify_tree(tree: dict) -> dict:\n  ```', "\n- **Description:** Recursively converts the complex `RepoFile` objects within the file tree dictionary into simple strings, making the tree structure easily serializable for output (e.g., JSON).\n- **Parameters:**\n  - `tree` (dict): The hierarchical file tree dictionary containing `RepoFile` objects.\n- **Returns:** \n  - 'dict' (dict) [A simplified file tree dictionary with only string values.]\n- **Calls:** [`isinstance`, `items`, `simplify_tree`]\n- **Called By:** [`analyze_repository`, `simplify_tree`]\n\n---\n### File: `schemas/types.py`\n**Function: `__init__`**\n- **Signature:**\n  ", '```python\n  def __init__(self, **data: Any):\n  ```', "\n- **Description:** [Could not be determined from the source code.]\n- **Parameters:**\n  - `**data` (Any): Arbitrary keyword arguments to initialize the model fields.\n- **Returns:** \n  - 'None' (None) [Constructor returns nothing.]\n- **Calls:** [`[No Calls Found]`]\n- **Called By:** [`[Not Called By Any Function]`]\n\n---"]